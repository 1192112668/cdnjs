"use strict";function _objectSpread(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},r=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(n).filter(function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.forEach(function(t){_defineProperty(e,t,n[t])})}return e}function _defineProperty(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}import React from"react";var __DEV__="production"!==process.env.NODE_ENV;function cloneReferencedElement(e,t){for(var n=t.ref,r=e.ref,c=arguments.length,o=new Array(c>2?c-2:0),a=2;a<c;a++)o[a-2]=arguments[a];return null==r||null==n?React.cloneElement.apply(React,[e,t].concat(o)):"function"!=typeof r?(__DEV__&&console.warn("Cloning an element with a ref that will be overwritten because it is not a function. Use a composable callback-style ref instead. Ignoring ref: "+r),React.cloneElement.apply(React,[e,t].concat(o))):React.cloneElement.apply(React,[e,_objectSpread({},t,{ref:function(e){n(e),r(e)}})].concat(o))}export default cloneReferencedElement;
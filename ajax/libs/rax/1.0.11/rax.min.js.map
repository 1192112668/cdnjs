{"version":3,"file":"rax.min.js","sources":["../src/vdom/host.js","../src/vdom/element.js","../src/types.js","../src/vdom/flattenChildren.js","../src/error.js","../src/createElement.js","../src/invokeFunctionsWithContext.js","../src/vdom/scheduler.js","../src/vdom/shallowEqual.js","../src/constant.js","../src/hooks.js","../src/toArray.js","../src/createContext.js","../src/vdom/base.js","../src/vdom/empty.js","../src/vdom/ref.js","../src/vdom/instantiateComponent.js","../src/vdom/shouldUpdateComponent.js","../src/vdom/getElementKeyName.js","../src/vdom/getPrevSiblingNativeNode.js","../src/vdom/component.js","../src/vdom/root.js","../src/vdom/instance.js","../src/assign.js","../src/vdom/native.js","../src/vdom/text.js","../src/vdom/reactive.js","../src/vdom/updater.js","../src/vdom/composite.js","../src/vdom/fragment.js","../src/createRef.js","../src/forwardRef.js","../src/memo.js","../src/fragment.js","../src/render.js","../src/vdom/inject.js","../src/version.js","../src/index.js","../src/index.js"],"sourcesContent":["/*\n * Stateful things in runtime\n */\nexport default {\n  mountID: 1,\n  // Current owner component\n  owner: null,\n  __isUpdating: false,\n  // Roots\n  rootComponents: {},\n  rootInstances: {},\n  // Inject\n  driver: null,\n};\n","export default function Element(type, key, ref, props, owner) {\n  return {\n    // Built-in properties that belong on the element\n    type,\n    key,\n    ref,\n    props,\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n};","export const NULL = null;\n\nexport function isNull(obj) {\n  return obj === NULL;\n}\n\nexport function isFunction(obj) {\n  return typeof obj === 'function';\n}\n\nexport function isObject(obj) {\n  return typeof obj === 'object';\n}\n\nexport function isArray(array) {\n  return Array.isArray(array);\n}\n\nexport function isString(string) {\n  return typeof string === 'string';\n}\n\nexport function isNumber(string) {\n  return typeof string === 'number';\n}\n","import { isArray } from '../types';\n\nfunction traverseChildren(children, result) {\n  if (isArray(children)) {\n    for (let i = 0, l = children.length; i < l; i++) {\n      traverseChildren(children[i], result);\n    }\n  } else {\n    result.push(children);\n  }\n}\n\nexport default function flattenChildren(children) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  traverseChildren(children, result);\n\n  // If length equal 1, return the only one.\n  return result.length - 1 ? result : result[0];\n}\n","/**\n * ErrorCode mapping:\n *  0: Type of createElement  should not be null or undefined.\n *  1: Hooks can only be called inside a component.\n *  2: Invalid element type.\n *  3: ref: multiple version of Rax used in project.\n * @param errCode {Number}\n */\nexport function invokeMinifiedError(errCode) {\n  throw new Error('Minified error: ' + errCode);\n}\n","import Host from './vdom/host';\nimport Element from './vdom/element';\nimport flattenChildren from './vdom/flattenChildren';\nimport { invokeMinifiedError } from './error';\nimport { isString, isArray } from './types';\n\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n};\n\nfunction getRenderErrorInfo() {\n  const ownerComponent = Host.owner;\n  if (ownerComponent) {\n    const name = ownerComponent.__getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nexport default function createElement(type, config, children) {\n  if (type == null) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error('createElement: type should not be null or undefined.' + getRenderErrorInfo());\n    } else {\n      invokeMinifiedError(0);\n    }\n  }\n  // Reserved names are extracted\n  let props = {};\n  let propName;\n  let key = null;\n  let ref = null;\n  const ownerComponent = Host.owner;\n\n  if (config != null) {\n    let hasReservedProps = false;\n\n    if (config.ref != null) {\n      hasReservedProps = true;\n      ref = config.ref;\n      if (process.env.NODE_ENV !== 'production') {\n        if (isString(ref) && !ownerComponent) {\n          console.error('createElement: adding a string ref \"' + ref + '\" outside the render method.');\n        }\n      }\n    }\n\n    if (config.key != null) {\n      hasReservedProps = true;\n      key = '' + config.key;\n    }\n\n    // if no reserved props, assign config to props for better performance\n    if (hasReservedProps) {\n      for (propName in config) {\n        // extract reserved props\n        if (!RESERVED_PROPS[propName]) {\n          props[propName] = config[propName];\n        }\n      }\n    } else {\n      props = config;\n    }\n  }\n\n  // Children arguments can be more than one\n  const childrenLength = arguments.length - 2;\n  if (childrenLength > 0) {\n    if (childrenLength === 1 && !isArray(children)) {\n      props.children = children;\n    } else {\n      let childArray = children;\n      if (childrenLength > 1) {\n        childArray = new Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n      }\n      props.children = flattenChildren(childArray);\n    }\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    let defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return new Element(\n    type,\n    key,\n    ref,\n    props,\n    ownerComponent\n  );\n}\n\n","export default function invokeFunctionsWithContext(fns, context, value) {\n  for (let i = 0, l = fns && fns.length; i < l; i++) {\n    fns[i].call(context, value);\n  }\n}\n","let updateCallbacks = [];\nlet effectCallbacks = [];\nexport let scheduler = setTimeout;\n\nif (process.env.NODE_ENV !== 'production') {\n  // Wrapper timer for hijack timers in jest\n  scheduler = (callback) => {\n    setTimeout(callback);\n  };\n}\n\n// Schedule before next render\nexport function schedule(callback) {\n  if (updateCallbacks.length === 0) {\n    scheduler(flush);\n  }\n  updateCallbacks.push(callback);\n}\n\n// Flush before next render\nexport function flush() {\n  let callback;\n  while (callback = updateCallbacks.shift()) {\n    callback();\n  }\n}\n\nexport function scheduleEffect(callback) {\n  if (effectCallbacks.length === 0) {\n    scheduler(flushEffect);\n  }\n  effectCallbacks.push(callback);\n}\n\nexport function flushEffect() {\n  let callback;\n  while (callback = effectCallbacks.shift()) {\n    callback();\n  }\n}\n","import {isNull, isObject} from '../types';\n\nconst hasOwnProperty = {}.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nexport function is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y; // eslint-disable-line no-self-compare\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nexport default function shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (!isObject(objA) || isNull(objA) || !isObject(objB) || isNull(objB)) {\n    return false;\n  }\n\n  let keysA = Object.keys(objA);\n  let keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/* Common constant variables for rax */\n\nexport const INTERNAL = '_internal';\nexport const INSTANCE = '_instance';\nexport const NATIVE_NODE = '_nativeNode';\nexport const RENDERED_COMPONENT = '_renderedComponent';\n","import Host from './vdom/host';\nimport { scheduleEffect, flushEffect } from './vdom/scheduler';\nimport { is } from './vdom/shallowEqual';\nimport { isArray, isFunction, isNull } from './types';\nimport { invokeMinifiedError } from './error';\nimport { INSTANCE } from './constant';\n\nfunction getCurrentInstance() {\n  return Host.owner && Host.owner[INSTANCE];\n}\n\nfunction getCurrentRenderingInstance() {\n  const currentInstance = getCurrentInstance();\n  if (currentInstance) {\n    return currentInstance;\n  } else {\n    if (process.env.NODE_ENV === 'production') {\n      invokeMinifiedError(1);\n    } else {\n      throw new Error('Hooks can only be called inside a component.');\n    }\n  }\n}\n\nfunction areInputsEqual(inputs, prevInputs) {\n  if (isNull(prevInputs) || inputs.length !== prevInputs.length) {\n    return false;\n  }\n\n  for (let i = 0; i < inputs.length; i++) {\n    if (is(inputs[i], prevInputs[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function useState(initialState) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n\n  if (!hooks[hookID]) {\n    // If the initial state is the result of an expensive computation,\n    // you may provide a function instead for lazy initial state.\n    if (isFunction(initialState)) {\n      initialState = initialState();\n    }\n\n    const setState = newState => {\n      // Flush all effects first before update state\n      if (!Host.__isUpdating) {\n        flushEffect();\n      }\n\n      const hook = hooks[hookID];\n      const eagerState = hook[2];\n      // function updater\n      if (isFunction(newState)) {\n        newState = newState(eagerState);\n      }\n\n      if (!is(newState, eagerState)) {\n        // Current instance is in render update phase.\n        // After this one render finish, will containue run.\n        hook[2] = newState;\n        if (getCurrentInstance() === currentInstance) {\n          // Marked as is scheduled that could finish hooks.\n          currentInstance.__isScheduled = true;\n        } else {\n          currentInstance.update();\n        }\n      }\n    };\n\n    hooks[hookID] = [\n      initialState,\n      setState,\n      initialState\n    ];\n  }\n\n  const hook = hooks[hookID];\n  if (!is(hook[0], hook[2])) {\n    hook[0] = hook[2];\n    currentInstance.__shouldUpdate = true;\n  }\n\n  return hook;\n}\n\nexport function useContext(context) {\n  const currentInstance = getCurrentRenderingInstance();\n  return currentInstance.readContext(context);\n}\n\nexport function useEffect(effect, inputs) {\n  useEffectImpl(effect, inputs, true);\n}\n\nexport function useLayoutEffect(effect, inputs) {\n  useEffectImpl(effect, inputs);\n}\n\nfunction useEffectImpl(effect, inputs, defered) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n  inputs = inputs === undefined ? null : inputs;\n\n  if (!hooks[hookID]) {\n    const __create = (immediately) => {\n      if (!immediately && defered) return scheduleEffect(() => __create(true));\n      const { current } = __create;\n      if (current) {\n        __destory.current = current();\n        __create.current = null;\n      }\n    };\n\n    const __destory = (immediately) => {\n      if (!immediately && defered) return scheduleEffect(() => __destory(true));\n      const { current } = __destory;\n      if (current) {\n        current();\n        __destory.current = null;\n      }\n    };\n\n    __create.current = effect;\n\n    hooks[hookID] = {\n      __create,\n      __destory,\n      __prevInputs: inputs,\n      __inputs: inputs\n    };\n\n    currentInstance.didMount.push(__create);\n    currentInstance.willUnmount.push(__destory);\n    currentInstance.didUpdate.push(() => {\n      const { __prevInputs, __inputs, __create } = hooks[hookID];\n      if (__inputs == null || !areInputsEqual(__inputs, __prevInputs)) {\n        __destory();\n        __create();\n      }\n    });\n  } else {\n    const hook = hooks[hookID];\n    const { __create, __inputs: prevInputs } = hook;\n    hook.__inputs = inputs;\n    hook.__prevInputs = prevInputs;\n    __create.current = effect;\n  }\n}\n\nexport function useImperativeHandle(ref, create, inputs) {\n  const nextInputs = isArray(inputs) ? inputs.concat([ref]) : null;\n\n  useLayoutEffect(() => {\n    if (isFunction(ref)) {\n      ref(create());\n      return () => ref(null);\n    } else if (ref != null) {\n      ref.current = create();\n      return () => {\n        ref.current = null;\n      };\n    }\n  }, nextInputs);\n}\n\nexport function useRef(initialValue) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n\n  if (!hooks[hookID]) {\n    hooks[hookID] = {\n      current: initialValue\n    };\n  }\n\n  return hooks[hookID];\n}\n\nexport function useCallback(callback, inputs) {\n  return useMemo(() => callback, inputs);\n}\n\nexport function useMemo(create, inputs) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n  inputs = inputs === undefined ? null : inputs;\n\n  if (!hooks[hookID]) {\n    hooks[hookID] = [create(), inputs];\n  } else {\n    const prevInputs = hooks[hookID][1];\n    if (isNull(inputs) || !areInputsEqual(inputs, prevInputs)) {\n      hooks[hookID] = [create(), inputs];\n    }\n  }\n\n  return hooks[hookID][0];\n}\n\nexport function useReducer(reducer, initialArg, init) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n  const hook = hooks[hookID];\n\n  if (!hook) {\n    const initialState = isFunction(init) ? init(initialArg) : initialArg;\n\n    const dispatch = action => {\n      // Flush all effects first before update state\n      if (!Host.__isUpdating) {\n        flushEffect();\n      }\n\n      const hook = hooks[hookID];\n      // Reducer will update in the next render, before that we add all\n      // actions to the queue\n      const queue = hook[2];\n\n      if (getCurrentInstance() === currentInstance) {\n        queue.__actions.push(action);\n        currentInstance.__isScheduled = true;\n      } else {\n        const currentState = queue.__eagerState;\n        const eagerReducer = queue.__eagerReducer;\n        const eagerState = eagerReducer(currentState, action);\n        if (is(eagerState, currentState)) {\n          return;\n        }\n        queue.__eagerState = eagerState;\n        queue.__actions.push(action);\n        currentInstance.update();\n      }\n    };\n\n    return hooks[hookID] = [\n      initialState,\n      dispatch,\n      {\n        __actions: [],\n        __eagerReducer: reducer,\n        __eagerState: initialState\n      }\n    ];\n  }\n\n  const queue = hook[2];\n  let next = hook[0];\n\n  if (currentInstance.__reRenders > 0) {\n    for (let i = 0; i < queue.__actions.length; i++) {\n      next = reducer(next, queue.__actions[i]);\n    }\n  } else {\n    next = queue.__eagerState;\n  }\n\n  if (!is(next, hook[0])) {\n    hook[0] = next;\n    currentInstance.__shouldUpdate = true;\n  }\n\n  queue.__eagerReducer = reducer;\n  queue.__eagerState = next;\n  queue.__actions.length = 0;\n\n  return hooks[hookID];\n}\n","import { isArray } from './types';\n\nexport default function toArray(obj) {\n  return isArray(obj) ? obj : [obj];\n}\n","import invokeFunctionsWithContext from './invokeFunctionsWithContext';\nimport { useState, useEffect } from './hooks';\nimport { isFunction } from './types';\nimport { INTERNAL } from './constant';\nimport toArray from './toArray';\n\nclass ValueEmitter {\n  constructor(defaultValue) {\n    this.handlers = [];\n    this.value = defaultValue;\n  }\n\n  on(handler) {\n    this.handlers.push(handler);\n  }\n\n  off(handler) {\n    this.handlers = this.handlers.filter(h => h !== handler);\n  }\n\n  emit() {\n    invokeFunctionsWithContext(this.handlers, null, this.value);\n  }\n}\n\nlet uniqueId = 0;\n\nexport default function createContext(defaultValue) {\n  const contextProp = '__ctx' + uniqueId++;\n  const stack = [];\n  const defaultEmitter = new ValueEmitter(defaultValue);\n\n  function Provider(props) {\n    const propsValue = props.value !== undefined ? props.value : defaultValue;\n    const [value, setValue] = useState(propsValue);\n    const [emitter] = useState(() => new ValueEmitter(value));\n    emitter.value = propsValue;\n\n    if (propsValue !== value) setValue(propsValue);\n\n    useEffect(() => {\n      stack.pop();\n    });\n\n    useEffect(() => {\n      emitter.emit();\n    }, [value]);\n\n    stack.push(emitter);\n    return props.children;\n  }\n\n  function readEmitter(instance) {\n    const emitter = stack[stack.length - 1];\n    if (emitter) return emitter;\n    while (instance && instance[INTERNAL]) {\n      if (instance instanceof Provider) {\n        break;\n      }\n      instance = instance[INTERNAL].__parentInstance;\n    }\n    return instance && instance.emitter || defaultEmitter;\n  }\n\n  Provider.readEmitter = readEmitter;\n  Provider.contextProp = contextProp;\n\n  function Consumer(props) {\n    const [emitter] = useState(() => readEmitter(this));\n    const [value, setValue] = useState(emitter.value);\n\n    if (value !== emitter.value) {\n      setValue(emitter.value);\n      return; // Interrupt execution of consumer.\n    }\n\n    function onUpdate(updatedValue) {\n      if (value !== updatedValue) {\n        setValue(updatedValue);\n      }\n    }\n\n    useEffect(() => {\n      emitter.on(onUpdate);\n      return () => {\n        emitter.off(onUpdate);\n      };\n    }, []);\n\n    const children = props.children;\n    const consumer = toArray(children)[0];\n    if (isFunction(consumer)) {\n      return consumer(value);\n    }\n  }\n\n  return {\n    Provider,\n    Consumer,\n  };\n}\n","import Host from './host';\nimport { INSTANCE, INTERNAL, NATIVE_NODE } from '../constant';\n\n/**\n * Base Component\n */\nexport default class BaseComponent {\n  constructor(element) {\n    this.__currentElement = element;\n  }\n\n  __initComponent(parent, parentInstance, context) {\n    this._parent = parent;\n    this.__parentInstance = parentInstance;\n    this._context = context;\n    this._mountID = Host.mountID++;\n  }\n\n  __destoryComponent() {\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.unmountComponent(this);\n    }\n\n    this.__currentElement\n      = this[NATIVE_NODE]\n      = this._parent\n      = this.__parentInstance\n      = this._context\n      = null;\n\n    if (this[INSTANCE]) {\n      this[INSTANCE] = this[INSTANCE][INTERNAL] = null;\n    }\n  }\n\n  __mountComponent(parent, parentInstance, context, nativeNodeMounter) {\n    this.__initComponent(parent, parentInstance, context);\n    this.__mountNativeNode(nativeNodeMounter);\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.mountComponent(this);\n    }\n\n    const instance = {};\n    instance[INTERNAL] = this;\n\n    return instance;\n  }\n\n  unmountComponent(shouldNotRemoveChild) {\n    if (this[NATIVE_NODE] && !shouldNotRemoveChild) {\n      Host.driver.removeChild(this[NATIVE_NODE], this._parent);\n    }\n\n    this.__destoryComponent();\n  }\n\n  __getName() {\n    let currentElement = this.__currentElement;\n    let type = currentElement && currentElement.type;\n\n    return (\n      type && type.displayName ||\n      type && type.name ||\n      type || // Native component's name is type\n      currentElement\n    );\n  }\n\n  __mountNativeNode(nativeNodeMounter) {\n    let nativeNode = this.__getNativeNode();\n    let parent = this._parent;\n\n    if (nativeNodeMounter) {\n      nativeNodeMounter(nativeNode, parent);\n    } else {\n      Host.driver.appendChild(nativeNode, parent);\n    }\n  }\n\n  __getNativeNode() {\n    return this[NATIVE_NODE] == null\n      ? this[NATIVE_NODE] = this.__createNativeNode()\n      : this[NATIVE_NODE];\n  }\n\n  __getPublicInstance() {\n    return this.__getNativeNode();\n  }\n}\n","import Host from './host';\nimport BaseComponent from './base';\n\n/**\n * Empty Component\n */\nclass EmptyComponent extends BaseComponent {\n  __createNativeNode() {\n    return Host.driver.createEmpty(this);\n  }\n}\n\nexport default EmptyComponent;\n","/*\n * Ref manager\n */\nimport { invokeMinifiedError } from '../error';\nimport { isFunction, isObject } from '../types';\nimport { INSTANCE } from '../constant';\n\nexport function updateRef(prevElement, nextElement, component) {\n  let prevRef = prevElement ? prevElement.ref : null;\n  let nextRef = nextElement ? nextElement.ref : null;\n\n  // Update refs in owner component\n  if (prevRef !== nextRef) {\n    // Detach prev RenderedElement's ref\n    prevRef && detachRef(prevElement._owner, prevRef, component);\n    // Attach next RenderedElement's ref\n    nextRef && attachRef(nextElement._owner, nextRef, component);\n  }\n}\n\nexport function attachRef(ownerComponent, ref, component) {\n  if (!ownerComponent) {\n    if (process.env.NODE_ENV !== 'production') {\n      return console.error('ref: multiple version of Rax used in project.');\n    } else {\n      invokeMinifiedError(3);\n    }\n  }\n\n  let instance = component.__getPublicInstance();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (instance == null) {\n      console.error('ref: do not attach ref to function components because they don’t have instances.');\n    }\n  }\n\n  if (isFunction(ref)) {\n    ref(instance);\n  } else if (isObject(ref)) {\n    ref.current = instance;\n  } else {\n    ownerComponent[INSTANCE].refs[ref] = instance;\n  }\n}\n\nexport function detachRef(ownerComponent, ref, component) {\n  if (isFunction(ref)) {\n    // When the referenced component is unmounted and whenever the ref changes, the old ref will be called with null as an argument.\n    ref(null);\n  } else {\n    // Must match component and ref could detach the ref on owner when A's before ref is B's current ref\n    let instance = component.__getPublicInstance();\n\n    if (isObject(ref) && ref.current === instance) {\n      ref.current = null;\n    } else if (ownerComponent[INSTANCE].refs[ref] === instance) {\n      delete ownerComponent[INSTANCE].refs[ref];\n    }\n  }\n}\n","import Host from './host';\nimport {isString, isNumber, isObject, isArray, isNull} from '../types';\nimport { invokeMinifiedError } from '../error';\n\nexport default function instantiateComponent(element) {\n  let instance;\n\n  if (isObject(element) && element !== null && element.type) {\n    // Special case string values\n    if (isString(element.type)) {\n      instance = new Host.Native(element);\n    } else {\n      instance = new Host.Composite(element);\n    }\n  } else if (isString(element) || isNumber(element)) {\n    instance = new Host.Text(String(element));\n  } else if (element === undefined || isNull(element) || element === false || element === true) {\n    instance = new Host.Empty();\n  } else if (isArray(element)) {\n    instance = new Host.Fragment(element);\n  } else {\n    throwInvalidComponentError(element);\n  }\n\n  return instance;\n}\n\nexport function throwInvalidComponentError(element) {\n  if (process.env.NODE_ENV === 'production') {\n    invokeMinifiedError(2);\n  } else {\n    throw new Error(`Invalid element type: ${element}. (current: ${isObject(element) && Object.keys(element) || typeof element})`);\n  }\n}\n","import {isArray, isString, isNumber, isObject, isNull} from '../types';\n\nfunction shouldUpdateComponent(prevElement, nextElement) {\n  let prevEmpty = isNull(prevElement);\n  let nextEmpty = isNull(nextElement);\n  if (prevEmpty || nextEmpty) {\n    return prevEmpty === nextEmpty;\n  }\n\n  if (isArray(prevElement) && isArray(nextElement)) {\n    return true;\n  }\n\n  const isPrevStringOrNumber = isString(prevElement) || isNumber(prevElement);\n  if (isPrevStringOrNumber) {\n    return isString(nextElement) || isNumber(nextElement);\n  } else {\n    // prevElement and nextElement could be array, typeof [] is \"object\"\n    return (\n      isObject(prevElement) &&\n      isObject(nextElement) &&\n      prevElement.type === nextElement.type &&\n      prevElement.key === nextElement.key\n    );\n  }\n}\n\nexport default shouldUpdateComponent;\n","import { isString } from '../types';\n\nexport default function getElementKeyName(children, element, index) {\n  const elementKey = element && element.key;\n  const defaultName = '.' + index.toString(36); // Inner child name default format fallback\n\n  // Key should must be string type\n  if (isString(elementKey)) {\n    let keyName = '$' + elementKey;\n    // Child keys must be unique.\n    let keyUnique = children[keyName] === undefined;\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Only the first child will be used when encountered two children with the same key\n      if (!keyUnique) {\n        console.warn(`Encountered two children with the same key \"${elementKey}\".`);\n      }\n    }\n\n    return keyUnique ? keyName : defaultName;\n  } else {\n    return defaultName;\n  }\n}\n","import Host from './host';\nimport toArray from '../toArray';\nimport { INTERNAL } from '../constant';\n\n/**\n * This function is usually been used to find the closet previous sibling native node of FragmentComponent.\n * FragmentComponent does not have a native node in the DOM tree, so when it is replaced, the new node has no corresponding location to insert.\n * So we need to look forward from the current mount position of the FragmentComponent to the nearest component which have the native node.\n * @param component\n * @return nativeNode\n */\nexport default function getPrevSiblingNativeNode(component) {\n  let parent = component;\n  while (parent = component.__parentInstance &&\n    component.__parentInstance[INTERNAL]) {\n    if (parent instanceof Host.Composite) {\n      component = parent;\n      continue;\n    }\n\n    const keys = Object.keys(parent._renderedChildren);\n    for (let i = component.__mountIndex - 1; i >= 0; i--) {\n      const nativeNode = toArray(parent._renderedChildren[keys[i]].__getNativeNode());\n      if (nativeNode.length > 0) {\n        return nativeNode[nativeNode.length - 1];\n      }\n    }\n    if (parent instanceof Host.Fragment) {\n      component = parent;\n    } else {\n      return null;\n    }\n  }\n}\n","/**\n * Base component class.\n */\nexport default class Component {\n  constructor(props, context) {\n    this.props = props;\n    this.context = context;\n    this.refs = {};\n  }\n\n  setState(partialState, callback) {\n    // The updater property is injected when composite component mounting\n    this.updater.setState(this, partialState, callback);\n  }\n\n  forceUpdate(callback) {\n    this.updater.forceUpdate(this, callback);\n  }\n}\n\n/**\n * Pure component.\n */\nexport class PureComponent extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.isPureComponent = true;\n  }\n}\n","import Component from './component';\nimport {INTERNAL, RENDERED_COMPONENT} from '../constant';\n\nlet rootID = 1;\n\nclass Root extends Component {\n  constructor() {\n    super();\n    // Using fragment instead of null for avoid create a comment node when init mount\n    this.element = [];\n    this.rootID = rootID++;\n  }\n\n  __getPublicInstance() {\n    return this.__getRenderedComponent().__getPublicInstance();\n  }\n\n  __getRenderedComponent() {\n    return this[INTERNAL][RENDERED_COMPONENT];\n  }\n\n  update(element) {\n    this.element = element;\n    this.forceUpdate();\n  }\n\n  render() {\n    return this.element;\n  }\n}\n\nexport default Root;\n","import Host from './host';\nimport createElement from '../createElement';\nimport instantiateComponent from './instantiateComponent';\nimport Root from './root';\nimport {INTERNAL, RENDERED_COMPONENT} from '../constant';\n\n/**\n * Instance manager\n * @NOTE Key should not be compressed, for that will be added to native node and cause DOM Exception.\n */\nconst KEY = '_r';\n\nexport default {\n  set(node, instance) {\n    if (!node[KEY]) {\n      node[KEY] = instance;\n      // Record root instance to roots map\n      if (instance.rootID) {\n        Host.rootInstances[instance.rootID] = instance;\n        Host.rootComponents[instance.rootID] = instance[INTERNAL];\n      }\n    }\n  },\n  get(node) {\n    return node[KEY];\n  },\n  remove(node) {\n    let instance = this.get(node);\n    if (instance) {\n      node[KEY] = null;\n      if (instance.rootID) {\n        delete Host.rootComponents[instance.rootID];\n        delete Host.rootInstances[instance.rootID];\n      }\n    }\n  },\n  mount(element, container, { parent, hydrate }) {\n    if (process.env.NODE_ENV !== 'production') {\n      Host.measurer && Host.measurer.beforeRender();\n    }\n\n    const driver = Host.driver;\n\n    // Real native root node is body\n    if (container == null) {\n      container = driver.createBody();\n    }\n\n    const renderOptions = {\n      element,\n      container,\n      hydrate\n    };\n\n    // Before render callback\n    driver.beforeRender && driver.beforeRender(renderOptions);\n\n    // Get the context from the conceptual parent component.\n    let parentContext;\n    if (parent) {\n      let parentInternal = parent[INTERNAL];\n      parentContext = parentInternal.__processChildContext(parentInternal._context);\n    }\n\n    // Update root component\n    let prevRootInstance = this.get(container);\n    if (prevRootInstance && prevRootInstance.rootID) {\n      if (parentContext) {\n        // Using __penddingContext to pass new context\n        prevRootInstance[INTERNAL].__penddingContext = parentContext;\n      }\n      prevRootInstance.update(element);\n      return prevRootInstance;\n    }\n\n    // Init root component with empty children\n    let renderedComponent = instantiateComponent(createElement(Root));\n    let defaultContext = parentContext || {};\n    let rootInstance = renderedComponent.__mountComponent(container, null, defaultContext);\n    this.set(container, rootInstance);\n    // Mount new element through update queue avoid when there is in rendering phase\n    rootInstance.update(element);\n\n    // After render callback\n    driver.afterRender && driver.afterRender(renderOptions);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Devtool render new root hook\n      Host.reconciler.renderNewRootComponent(rootInstance[INTERNAL][RENDERED_COMPONENT]);\n\n      Host.measurer && Host.measurer.afterRender();\n    }\n\n    return rootInstance;\n  }\n};\n","export default Object.assign;\n","import Host from './host';\nimport { detachRef, attachRef, updateRef } from './ref';\nimport instantiateComponent from './instantiateComponent';\nimport shouldUpdateComponent from './shouldUpdateComponent';\nimport getElementKeyName from './getElementKeyName';\nimport getPrevSiblingNativeNode from './getPrevSiblingNativeNode';\nimport Instance from './instance';\nimport BaseComponent from './base';\nimport toArray from '../toArray';\nimport { isFunction, isArray, isNull } from '../types';\nimport assign from '../assign';\nimport { INSTANCE, INTERNAL, NATIVE_NODE } from '../constant';\n\nconst STYLE = 'style';\nconst CHILDREN = 'children';\nconst TREE = 'tree';\nconst EVENT_PREFIX_REGEXP = /^on[A-Z]/;\n\n/**\n * Native Component\n */\nexport default class NativeComponent extends BaseComponent {\n  __mountComponent(parent, parentInstance, context, nativeNodeMounter) {\n    this.__initComponent(parent, parentInstance, context);\n\n    const currentElement = this.__currentElement;\n    const props = currentElement.props;\n    const type = currentElement.type;\n    const children = props[CHILDREN];\n    const appendType = props.append || TREE; // Default is tree\n\n    // Clone a copy for style diff\n    this.__prevStyleCopy = assign({}, props[STYLE]);\n\n    let instance = {\n      type,\n      props,\n    };\n    instance[INTERNAL] = this;\n\n    this[INSTANCE] = instance;\n\n    if (appendType === TREE) {\n      // Should after process children when mount by tree mode\n      this.__mountChildren(children, context);\n      this.__mountNativeNode(nativeNodeMounter);\n    } else {\n      // Should before process children when mount by node mode\n      this.__mountNativeNode(nativeNodeMounter);\n      this.__mountChildren(children, context);\n    }\n\n    // Ref acttach\n    if (currentElement && currentElement.ref) {\n      attachRef(currentElement._owner, currentElement.ref, this);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.mountComponent(this);\n    }\n\n    return instance;\n  }\n\n  __mountChildren(children, context) {\n    if (children == null) return children;\n\n    const nativeNode = this.__getNativeNode();\n    return this.__mountChildrenImpl(nativeNode, toArray(children), context);\n  }\n\n  __mountChildrenImpl(parent, children, context, nativeNodeMounter) {\n    let renderedChildren = this._renderedChildren = {};\n\n    const renderedChildrenImage = [];\n    for (let i = 0, l = children.length; i < l; i++) {\n      const element = children[i];\n      const renderedChild = instantiateComponent(element);\n      const name = getElementKeyName(renderedChildren, element, i);\n      renderedChildren[name] = renderedChild;\n      renderedChild.__mountIndex = i;\n      // Mount children\n      const mountImage = renderedChild.__mountComponent(\n        parent,\n        this[INSTANCE],\n        context,\n        nativeNodeMounter\n      );\n      renderedChildrenImage.push(mountImage);\n    }\n\n    return renderedChildrenImage;\n  }\n\n  __unmountChildren(shouldNotRemoveChild) {\n    let renderedChildren = this._renderedChildren;\n\n    if (renderedChildren) {\n      for (let name in renderedChildren) {\n        let renderedChild = renderedChildren[name];\n        renderedChild.unmountComponent(shouldNotRemoveChild);\n      }\n      this._renderedChildren = null;\n    }\n  }\n\n  unmountComponent(shouldNotRemoveChild) {\n    if (this[NATIVE_NODE]) {\n      let ref = this.__currentElement.ref;\n      if (ref) {\n        detachRef(this.__currentElement._owner, ref, this);\n      }\n\n      Instance.remove(this[NATIVE_NODE]);\n\n      if (!shouldNotRemoveChild) {\n        Host.driver.removeChild(this[NATIVE_NODE], this._parent);\n\n        // If the parent node has been removed, child node don't need to be removed\n        shouldNotRemoveChild = true;\n      }\n    }\n\n    this.__unmountChildren(shouldNotRemoveChild);\n\n    this.__prevStyleCopy = null;\n    this.__destoryComponent();\n  }\n\n  __updateComponent(prevElement, nextElement, prevContext, nextContext) {\n    // Replace current element\n    this.__currentElement = nextElement;\n\n    updateRef(prevElement, nextElement, this);\n\n    let prevProps = prevElement.props;\n    let nextProps = nextElement.props;\n\n    this.__updateProperties(prevProps, nextProps);\n\n    // If the prevElement has no child, mount children directly\n    if (prevProps[CHILDREN] == null ||\n      isArray(prevProps[CHILDREN]) && prevProps[CHILDREN].length === 0) {\n      this.__mountChildren(nextProps[CHILDREN], nextContext);\n    } else {\n      this.__updateChildren(nextProps[CHILDREN], nextContext);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.receiveComponent(this);\n    }\n  }\n\n  __updateProperties(prevProps, nextProps) {\n    let propKey;\n    let styleName;\n    let styleUpdates;\n    const driver = Host.driver;\n    const nativeNode = this.__getNativeNode();\n\n    for (propKey in prevProps) {\n      // Continue children and null value prop or nextProps has some propKey that do noting\n      if (\n        propKey === CHILDREN ||\n        prevProps[propKey] == null ||\n        // Use hasOwnProperty here for avoid propKey name is some with method name in object proptotype\n        nextProps.hasOwnProperty(propKey)\n      ) {\n        continue;\n      }\n\n      if (propKey === STYLE) {\n        // Remove all style\n        let lastStyle = this.__prevStyleCopy;\n        for (styleName in lastStyle) {\n          styleUpdates = styleUpdates || {};\n          styleUpdates[styleName] = '';\n        }\n        this.__prevStyleCopy = null;\n      } else if (EVENT_PREFIX_REGEXP.test(propKey)) {\n        // Remove event\n        const eventListener = prevProps[propKey];\n\n        if (isFunction(eventListener)) {\n          driver.removeEventListener(\n            nativeNode,\n            propKey.slice(2).toLowerCase(),\n            eventListener\n          );\n        }\n      } else {\n        // Remove attribute\n        driver.removeAttribute(\n          nativeNode,\n          propKey,\n          prevProps[propKey]\n        );\n      }\n    }\n\n    for (propKey in nextProps) {\n      let nextProp = nextProps[propKey];\n      let prevProp = propKey === STYLE ? this.__prevStyleCopy :\n        prevProps != null ? prevProps[propKey] : undefined;\n\n      // Continue children or prevProp equal nextProp\n      if (\n        propKey === CHILDREN ||\n        prevProp === nextProp ||\n        nextProp == null && prevProp == null\n      ) {\n        continue;\n      }\n\n      // Update style\n      if (propKey === STYLE) {\n        if (nextProp) {\n          // Clone property\n          nextProp = this.__prevStyleCopy = assign({}, nextProp);\n        } else {\n          this.__prevStyleCopy = null;\n        }\n\n        if (prevProp != null) {\n          // Unset styles on `prevProp` but not on `nextProp`.\n          for (styleName in prevProp) {\n            if (!nextProp || !nextProp[styleName] && nextProp[styleName] !== 0) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = '';\n            }\n          }\n          // Update styles that changed since `prevProp`.\n          for (styleName in nextProp) {\n            if (prevProp[styleName] !== nextProp[styleName]) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = nextProp[styleName];\n            }\n          }\n        } else {\n          // Assign next prop when prev style is null\n          styleUpdates = nextProp;\n        }\n      } else if (EVENT_PREFIX_REGEXP.test(propKey)) {\n        // Update event binding\n        let eventName = propKey.slice(2).toLowerCase();\n\n        if (isFunction(prevProp)) {\n          driver.removeEventListener(nativeNode, eventName, prevProp, nextProps);\n        }\n\n        if (isFunction(nextProp)) {\n          driver.addEventListener(nativeNode, eventName, nextProp, nextProps);\n        }\n      } else {\n        // Update other property\n        if (nextProp != null) {\n          driver.setAttribute(\n            nativeNode,\n            propKey,\n            nextProp\n          );\n        } else {\n          driver.removeAttribute(\n            nativeNode,\n            propKey,\n            prevProps[propKey]\n          );\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          Host.measurer && Host.measurer.recordOperation({\n            instanceID: this._mountID,\n            type: 'update attribute',\n            payload: {\n              [propKey]: nextProp\n            }\n          });\n        }\n      }\n    }\n\n    if (styleUpdates) {\n      if (process.env.NODE_ENV !== 'production') {\n        Host.measurer && Host.measurer.recordOperation({\n          instanceID: this._mountID,\n          type: 'update style',\n          payload: styleUpdates\n        });\n      }\n\n      driver.setStyle(nativeNode, styleUpdates);\n    }\n  }\n\n  __updateChildren(nextChildrenElements, context) {\n    // prev rendered children\n    let prevChildren = this._renderedChildren;\n    let driver = Host.driver;\n\n    if (nextChildrenElements == null && prevChildren == null) {\n      return;\n    }\n\n    let nextChildren = {};\n\n    if (nextChildrenElements != null) {\n      nextChildrenElements = toArray(nextChildrenElements);\n\n      // Update next children elements\n      for (let index = 0, length = nextChildrenElements.length; index < length; index++) {\n        let nextElement = nextChildrenElements[index];\n        let name = getElementKeyName(nextChildren, nextElement, index);\n        let prevChild = prevChildren && prevChildren[name];\n        let prevElement = prevChild && prevChild.__currentElement;\n        let prevContext = prevChild && prevChild._context;\n\n        // Try to update between the two of some name that has some element type,\n        // and move child in next children loop if need\n        if (prevChild != null && shouldUpdateComponent(prevElement, nextElement)) {\n          if (prevElement !== nextElement || prevContext !== context) {\n            // Pass the same context when updating children\n            prevChild.__updateComponent(prevElement, nextElement, context,\n              context);\n          }\n\n          nextChildren[name] = prevChild;\n        } else {\n          // Unmount the prevChild when some name with nextChild but different element type,\n          // and move child node in next children loop\n          if (prevChild) {\n            prevChild.__unmount = true;\n          }\n          // The child must be instantiated before it's mounted.\n          nextChildren[name] = instantiateComponent(nextElement);\n        }\n      }\n    }\n\n    let prevFirstChild;\n    let prevFirstNativeNode;\n    let shouldUnmountPrevFirstChild;\n\n    // Directly remove all children from component, if nextChildren is empty (null, [], '').\n    // `driver.removeChildren` is optional driver protocol.\n    let shouldRemoveAllChildren = Boolean(\n      driver.removeChildren\n      // nextChildElements == null or nextChildElements is empty\n      && (isNull(nextChildrenElements) || nextChildrenElements && !nextChildrenElements.length)\n    );\n\n    // Unmount children that are no longer present.\n    if (prevChildren != null) {\n      for (let name in prevChildren) {\n        let prevChild = prevChildren[name];\n        let shouldUnmount = prevChild.__unmount || !nextChildren[name];\n\n        // Store old first child ref for append node ahead and maybe delay remove it\n        if (!prevFirstChild) {\n          shouldUnmountPrevFirstChild = shouldUnmount;\n          prevFirstChild = prevChild;\n          prevFirstNativeNode = prevFirstChild.__getNativeNode();\n\n          if (isArray(prevFirstNativeNode)) {\n            prevFirstNativeNode = prevFirstNativeNode[0];\n          }\n        } else if (shouldUnmount) {\n          prevChild.unmountComponent(shouldRemoveAllChildren);\n        }\n      }\n    }\n\n    if (nextChildren != null) {\n      // `nextIndex` will increment for each child in `nextChildren`\n      let nextIndex = 0;\n      let lastPlacedNode = null;\n      let nextNativeNodes = [];\n      let isFragmentAsParent = false;\n      let insertNodes = (nativeNodes, parent) => {\n        // The nativeNodes maybe fragment, so convert to array type\n        nativeNodes = toArray(nativeNodes);\n        let prevSiblingNativeNode;\n\n        // Only parent is fragment need to get the prev sibling node\n        if (isFragmentAsParent) {\n          prevSiblingNativeNode = getPrevSiblingNativeNode(this);\n        }\n\n        for (let i = 0, l = nativeNodes.length; i < l; i++) {\n          if (lastPlacedNode) {\n            // Should reverse order when insert new child after lastPlacedNode:\n            // [lastPlacedNode, *newChild1, *newChild2]\n            driver.insertAfter(nativeNodes[l - i - 1], lastPlacedNode);\n          } else if (prevFirstNativeNode) {\n            // [*newChild1, *newChild2, prevFirstNativeNode]\n            driver.insertBefore(nativeNodes[i], prevFirstNativeNode);\n          } else if (prevSiblingNativeNode) {\n            // If parent is fragment, find nativeNode previous sibling node\n            driver.insertAfter(nativeNodes[i], prevSiblingNativeNode);\n          } else if (parent) {\n            // [*newChild1, *newChild2]\n            driver.appendChild(nativeNodes[i], parent);\n          }\n        }\n      };\n\n      for (let name in nextChildren) {\n        let nextChild = nextChildren[name];\n        let prevChild = prevChildren && prevChildren[name];\n\n        // Try to move the some key prevChild but current not at the some position\n        if (prevChild === nextChild) {\n          let prevChildNativeNode = prevChild.__getNativeNode();\n\n          if (prevChild.__mountIndex !== nextIndex) {\n            insertNodes(prevChildNativeNode);\n          }\n        } else {\n          // Mount nextChild that in prevChildren there has no some name\n\n          let parent = this.__getNativeNode();\n          // Fragment extended native component, so if parent is fragment should get this._parent\n          if (isArray(parent)) {\n            isFragmentAsParent = true;\n            parent = this._parent;\n          }\n\n          nextChild.__mountComponent(\n            parent,\n            this[INSTANCE],\n            context,\n            insertNodes // Insert nodes mounter\n          );\n        }\n\n        // Update to the latest mount order\n        nextChild.__mountIndex = nextIndex++;\n\n        // Get the last child\n        lastPlacedNode = nextChild.__getNativeNode();\n\n        // Push to nextNativeNodes\n        if (isArray(lastPlacedNode)) {\n          nextNativeNodes = nextNativeNodes.concat(lastPlacedNode);\n          lastPlacedNode = lastPlacedNode[lastPlacedNode.length - 1];\n        } else {\n          nextNativeNodes.push(lastPlacedNode);\n        }\n      }\n\n      // Sync update native refs\n      if (isArray(this[NATIVE_NODE])) {\n        // Clear all and push the new array\n        this[NATIVE_NODE].length = 0;\n        assign(this[NATIVE_NODE], nextNativeNodes);\n      }\n    }\n\n    if (shouldUnmountPrevFirstChild) {\n      prevFirstChild.unmountComponent(shouldRemoveAllChildren);\n    }\n\n    if (shouldRemoveAllChildren) {\n      driver.removeChildren(this[NATIVE_NODE]);\n    }\n\n    this._renderedChildren = nextChildren;\n  }\n\n  __createNativeNode() {\n    const instance = this[INSTANCE];\n    const nativeNode = Host.driver.createElement(instance.type, instance.props, this);\n    Instance.set(nativeNode, instance);\n    return nativeNode;\n  }\n}\n","import Host from './host';\nimport BaseComponent from './base';\n\n/**\n * Text Component\n */\nclass TextComponent extends BaseComponent {\n  __updateComponent(prevElement, nextElement, context) {\n    nextElement = '' + nextElement;\n    // If text is some value that do not update even there number 1 and string \"1\"\n    if (prevElement !== nextElement) {\n      // Replace current element\n      this.__currentElement = nextElement;\n      Host.driver.updateText(this.__getNativeNode(), nextElement);\n\n      if (process.env.NODE_ENV !== 'production') {\n        this._stringText = this.__currentElement;\n        Host.reconciler.receiveComponent(this);\n      }\n    }\n  }\n\n  __createNativeNode() {\n    if (process.env.NODE_ENV !== 'production') {\n      this._stringText = this.__currentElement;\n    }\n    return Host.driver.createText(this.__currentElement, this);\n  }\n}\n\nexport default TextComponent;\n","import Host from './host';\nimport Component from './component';\nimport invokeFunctionsWithContext from '../invokeFunctionsWithContext';\nimport { invokeMinifiedError } from '../error';\nimport { INTERNAL } from '../constant';\n\nconst RE_RENDER_LIMIT = 24;\n/**\n * Functional Reactive Component Class Wrapper\n */\nexport default class ReactiveComponent extends Component {\n  constructor(pureRender, ref) {\n    super();\n    // Marked ReactiveComponent.\n    this.__isReactiveComponent = true;\n\n    // A pure function\n    this.__render = pureRender;\n    this._hookID = 0;\n    // Number of rerenders\n    this.__reRenders = 0;\n    this._hooks = {};\n    // Handles store\n    this.didMount = [];\n    this.didUpdate = [];\n    this.willUnmount = [];\n    // Is render scheduled\n    this.__isScheduled = false;\n    this.__shouldUpdate = false;\n    this.__children = null;\n    this.__dependencies = {};\n\n    this.state = {};\n\n    if (pureRender.forwardRef) {\n      this.prevForwardRef = this.forwardRef = ref;\n    }\n\n    const compares = pureRender.compares;\n    if (compares) {\n      this.shouldComponentUpdate = (nextProps) => {\n        // Process composed compare\n        let arePropsEqual = true;\n\n        // Compare push in and pop out\n        for (let i = compares.length - 1; i > -1; i--) {\n          if (arePropsEqual = compares[i](this.props, nextProps)) {\n            break;\n          }\n        }\n\n        return !arePropsEqual || this.prevForwardRef !== this.forwardRef;\n      };\n    }\n  }\n\n  getHooks() {\n    return this._hooks;\n  }\n\n  getHookID() {\n    return ++this._hookID;\n  }\n\n  readContext(context) {\n    const Provider = context.Provider;\n    const contextProp = Provider.contextProp;\n    let contextItem = this.__dependencies[contextProp];\n    if (!contextItem) {\n      const readEmitter = Provider.readEmitter;\n      const contextEmitter = readEmitter(this);\n      contextItem = {\n        emitter: contextEmitter,\n        renderedContext: contextEmitter.value,\n      };\n\n      const contextUpdater = (newContext) => {\n        if (newContext !== contextItem.renderedContext) {\n          this.__shouldUpdate = true;\n          this.update();\n        }\n      };\n\n      contextEmitter.on(contextUpdater);\n      this.willUnmount.push(contextEmitter.off.bind(contextEmitter, contextUpdater));\n      this.__dependencies[contextProp] = contextItem;\n    }\n    return contextItem.renderedContext = contextItem.emitter.value;\n  }\n\n  componentWillMount() {\n    this.__shouldUpdate = true;\n  }\n\n  componentDidMount() {\n    invokeFunctionsWithContext(this.didMount);\n  }\n\n  componentWillReceiveProps() {\n    this.__shouldUpdate = true;\n  }\n\n  componentDidUpdate() {\n    invokeFunctionsWithContext(this.didUpdate);\n  }\n\n  componentWillUnmount() {\n    invokeFunctionsWithContext(this.willUnmount);\n  }\n\n  update() {\n    this[INTERNAL].__isPendingForceUpdate = true;\n    this.setState({});\n  }\n\n  render() {\n    if (process.env.NODE_ENV !== 'production') {\n      Host.measurer && Host.measurer.beforeRender();\n    }\n\n    this._hookID = 0;\n    this.__reRenders = 0;\n    this.__isScheduled = false;\n    let children = this.__render(this.props, this.forwardRef ? this.forwardRef : this.context);\n\n    while (this.__isScheduled) {\n      this.__reRenders++;\n      if (this.__reRenders > RE_RENDER_LIMIT) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error('Too many re-renders, the number of renders is limited to prevent an infinite loop.');\n        } else {\n          invokeMinifiedError(4);\n        }\n      }\n\n      this._hookID = 0;\n      this.__isScheduled = false;\n      children = this.__render(this.props, this.forwardRef ? this.forwardRef : this.context);\n    }\n\n    if (this.__shouldUpdate) {\n      this.__children = children;\n      this.__shouldUpdate = false;\n    }\n\n    return this.__children;\n  }\n}\n","import Host from './host';\nimport { flushEffect, schedule } from './scheduler';\nimport invokeFunctionsWithContext from '../invokeFunctionsWithContext';\nimport { INTERNAL, RENDERED_COMPONENT } from '../constant';\n\n// Dirty components store\nlet dirtyComponents = [];\n\nfunction getPendingCallbacks(internal) {\n  return internal.__pendingCallbacks;\n}\n\nfunction setPendingCallbacks(internal, callbacks) {\n  return internal.__pendingCallbacks = callbacks;\n}\n\nfunction getPendingStateQueue(internal) {\n  return internal.__pendingStateQueue;\n}\n\nfunction setPendingStateQueue(internal, partialState) {\n  return internal.__pendingStateQueue = partialState;\n}\n\nfunction enqueueCallback(internal, callback) {\n  let callbackQueue = getPendingCallbacks(internal) || setPendingCallbacks(internal, []);\n  callbackQueue.push(callback);\n}\n\nfunction enqueueState(internal, partialState) {\n  let stateQueue = getPendingStateQueue(internal) || setPendingStateQueue(internal, []);\n  stateQueue.push(partialState);\n}\n\nfunction runUpdate(component) {\n  let internal = component[INTERNAL];\n  if (!internal) {\n    return;\n  }\n\n  Host.__isUpdating = true;\n\n  // If updateComponent happens to enqueue any new updates, we\n  // shouldn't execute the callbacks until the next render happens, so\n  // stash the callbacks first\n  let callbacks = getPendingCallbacks(internal);\n  setPendingCallbacks(internal, null);\n\n  let prevElement = internal.__currentElement;\n  let prevUnmaskedContext = internal._context;\n  let nextUnmaskedContext = internal.__penddingContext || prevUnmaskedContext;\n  internal.__penddingContext = undefined;\n\n  if (getPendingStateQueue(internal) || internal.__isPendingForceUpdate) {\n    internal.__updateComponent(\n      prevElement,\n      prevElement,\n      prevUnmaskedContext,\n      nextUnmaskedContext\n    );\n  }\n\n  invokeFunctionsWithContext(callbacks, component);\n\n  Host.__isUpdating = false;\n}\n\nfunction mountOrderComparator(c1, c2) {\n  return c2[INTERNAL]._mountID - c1[INTERNAL]._mountID;\n}\n\nfunction performUpdate() {\n  if (Host.__isUpdating) {\n    return schedule(performUpdate);\n  }\n\n  let component;\n  let dirties = dirtyComponents;\n  if (dirties.length > 0) {\n    // Before next render, we will flush all the effects\n    flushEffect();\n    dirtyComponents = [];\n    // Since reconciling a component higher in the owner hierarchy usually (not\n    // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n    // them before their children by sorting the array.\n    if (dirties.length > 1) {\n      dirties = dirties.sort(mountOrderComparator);\n    }\n\n    while (component = dirties.pop()) {\n      runUpdate(component);\n    }\n  }\n}\n\nfunction scheduleUpdate(component, shouldAsyncUpdate) {\n  if (dirtyComponents.indexOf(component) < 0) {\n    dirtyComponents.push(component);\n  }\n\n  if (shouldAsyncUpdate) {\n    // If have been scheduled before, don't not need schedule again\n    if (dirtyComponents.length > 1) {\n      return;\n    }\n    schedule(performUpdate);\n  } else {\n    performUpdate();\n  }\n}\n\nfunction requestUpdate(component, partialState, callback) {\n  let internal = component[INTERNAL];\n\n  if (!internal) {\n    return;\n  }\n\n  if (callback) {\n    enqueueCallback(internal, callback);\n  }\n\n  const hasComponentRendered = internal[RENDERED_COMPONENT];\n\n  // setState\n  if (partialState) {\n    enqueueState(internal, partialState);\n    // State pending when request update in componentWillMount and componentWillReceiveProps,\n    // isPendingState default is false value (false or null) and set to true after componentWillReceiveProps,\n    // _renderedComponent is null when componentWillMount exec.\n    if (!internal.__isPendingState && hasComponentRendered) {\n      scheduleUpdate(component, true);\n    }\n  } else {\n    // forceUpdate\n    internal.__isPendingForceUpdate = true;\n\n    if (hasComponentRendered) {\n      scheduleUpdate(component);\n    }\n  }\n}\n\nconst Updater = {\n  setState(component, partialState, callback) {\n    // Flush all effects first before update state\n    if (!Host.__isUpdating) {\n      flushEffect();\n    }\n    requestUpdate(component, partialState, callback);\n  },\n  forceUpdate(component, callback) {\n    requestUpdate(component, null, callback);\n  },\n  runCallbacks: invokeFunctionsWithContext,\n};\n\nexport default Updater;\n","import ReactiveComponent from './reactive';\nimport updater from './updater';\nimport Host from './host';\nimport { attachRef, updateRef, detachRef } from './ref';\nimport instantiateComponent, { throwInvalidComponentError } from './instantiateComponent';\nimport shouldUpdateComponent from './shouldUpdateComponent';\nimport shallowEqual from './shallowEqual';\nimport BaseComponent from './base';\nimport toArray from '../toArray';\nimport { scheduler } from './scheduler';\nimport { isFunction, isArray } from '../types';\nimport assign from '../assign';\nimport { INSTANCE, INTERNAL, RENDERED_COMPONENT } from '../constant';\nimport getPrevSiblingNativeNode from './getPrevSiblingNativeNode';\nimport invokeFunctionsWithContext from '../invokeFunctionsWithContext';\n\nfunction performInSandbox(fn, instance, callback) {\n  try {\n    return fn();\n  } catch (e) {\n    if (callback) {\n      callback(e);\n    } else {\n      handleError(instance, e);\n    }\n  }\n}\n\nfunction handleError(instance, error) {\n  let boundary;\n\n  while (instance) {\n    let internal = instance[INTERNAL];\n    if (instance.componentDidCatch) {\n      boundary = instance;\n      break;\n    } else if (internal && internal.__parentInstance) {\n      instance = internal.__parentInstance;\n    } else {\n      break;\n    }\n  }\n\n  if (boundary) {\n    // Should not attempt to recover an unmounting error boundary\n    const boundaryInternal = boundary[INTERNAL];\n    if (boundaryInternal) {\n      let callbackQueue = boundaryInternal.__pendingCallbacks || (boundaryInternal.__pendingCallbacks = []);\n      callbackQueue.push(() => boundary.componentDidCatch(error));\n    }\n  } else {\n    // Do not break when error happens\n    scheduler(() => {\n      throw error;\n    }, 0);\n  }\n}\n\nlet measureLifeCycle;\nif (process.env.NODE_ENV !== 'production') {\n  measureLifeCycle = function(callback, instanceID, type) {\n    Host.measurer && Host.measurer.beforeLifeCycle(instanceID, type);\n    callback();\n    Host.measurer && Host.measurer.afterLifeCycle(instanceID, type);\n  };\n}\n\n/**\n * Composite Component\n */\nclass CompositeComponent extends BaseComponent {\n  __mountComponent(parent, parentInstance, context, nativeNodeMounter) {\n    this.__initComponent(parent, parentInstance, context);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._updateCount = 0;\n      Host.measurer && Host.measurer.beforeMountComponent(this._mountID, this);\n    }\n\n    let currentElement = this.__currentElement;\n    let Component = currentElement.type;\n    let ref = currentElement.ref;\n    let publicProps = currentElement.props;\n    let componentPrototype = Component.prototype;\n\n    // Context process\n    let publicContext = this.__processContext(context);\n\n    // Initialize the public class\n    let instance;\n    let renderedElement;\n\n    try {\n      if (componentPrototype && componentPrototype.render) {\n        // Class Component instance\n        instance = new Component(publicProps, publicContext);\n      } else if (isFunction(Component)) {\n        // Functional reactive component with hooks\n        instance = new ReactiveComponent(Component, ref);\n      } else {\n        throwInvalidComponentError(Component);\n      }\n    } catch (e) {\n      return handleError(parentInstance, e);\n    }\n\n    // These should be set up in the constructor, but as a convenience for\n    // simpler class abstractions, we set them up after the fact.\n    instance.props = publicProps;\n    instance.context = publicContext;\n    instance.refs = {};\n\n    // Inject the updater into instance\n    instance.updater = updater;\n    instance[INTERNAL] = this;\n    this[INSTANCE] = instance;\n\n    // Init state, must be set to an object or null\n    let initialState = instance.state;\n    if (initialState === undefined) {\n      // TODO clone the state?\n      instance.state = initialState = null;\n    }\n\n    let error = null;\n    let errorCallback = (e) => {\n      error = e;\n    };\n\n    if (instance.componentWillMount) {\n      performInSandbox(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          measureLifeCycle(() => {\n            instance.componentWillMount();\n          }, this._mountID, 'componentWillMount');\n        } else {\n          instance.componentWillMount();\n        }\n      }, instance, errorCallback);\n    }\n\n    if (renderedElement == null) {\n      Host.owner = this;\n      // Process pending state when call setState in componentWillMount\n      instance.state = this.__processPendingState(publicProps, publicContext);\n\n      performInSandbox(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          measureLifeCycle(() => {\n            renderedElement = instance.render();\n          }, this._mountID, 'render');\n        } else {\n          renderedElement = instance.render();\n        }\n      }, instance, errorCallback);\n\n      Host.owner = null;\n    }\n\n    this[RENDERED_COMPONENT] = instantiateComponent(renderedElement);\n    this[RENDERED_COMPONENT].__mountComponent(\n      this._parent,\n      instance,\n      this.__processChildContext(context),\n      nativeNodeMounter\n    );\n\n    if (error) {\n      handleError(instance, error);\n    }\n\n    if (!currentElement.type.forwardRef && ref) {\n      attachRef(currentElement._owner, ref, this);\n    }\n\n    if (instance.componentDidMount) {\n      performInSandbox(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          measureLifeCycle(() => {\n            instance.componentDidMount();\n          }, this._mountID, 'componentDidMount');\n        } else {\n          instance.componentDidMount();\n        }\n      }, instance);\n    }\n\n    // Trigger setState callback in componentWillMount or boundary callback after rendered\n    let callbacks = this.__pendingCallbacks;\n    if (callbacks) {\n      this.__pendingCallbacks = null;\n      invokeFunctionsWithContext(callbacks, instance);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.mountComponent(this);\n      Host.measurer && Host.measurer.afterMountComponent(this._mountID);\n    }\n\n    return instance;\n  }\n\n  unmountComponent(shouldNotRemoveChild) {\n    let instance = this[INSTANCE];\n\n    // Unmounting a composite component maybe not complete mounted\n    // when throw error in component constructor stage\n    if (instance && instance.componentWillUnmount) {\n      performInSandbox(() => {\n        instance.componentWillUnmount();\n      }, instance);\n    }\n\n    if (this[RENDERED_COMPONENT] != null) {\n      let currentElement = this.__currentElement;\n      let ref = currentElement.ref;\n\n      if (!currentElement.type.forwardRef && ref) {\n        detachRef(currentElement._owner, ref, this);\n      }\n\n      this[RENDERED_COMPONENT].unmountComponent(shouldNotRemoveChild);\n      this[RENDERED_COMPONENT] = null;\n    }\n\n    // Reset pending fields\n    // Even if this component is scheduled for another async update,\n    // it would still be ignored because these fields are reset.\n    this.__pendingStateQueue = null;\n    this.__isPendingForceUpdate = false;\n\n    this.__destoryComponent();\n  }\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`\n   */\n  __processContext(context) {\n    let maskedContext = {};\n    let Component = this.__currentElement.type;\n    let contextTypes = Component.contextTypes;\n\n    if (contextTypes) {\n      for (let contextName in contextTypes) {\n        maskedContext[contextName] = context[contextName];\n      }\n    }\n\n    return maskedContext;\n  }\n\n  __processChildContext(currentContext) {\n    let instance = this[INSTANCE];\n    // The getChildContext method context should be current instance\n    let childContext = instance.getChildContext && instance.getChildContext();\n\n    if (childContext) {\n      return assign({}, currentContext, childContext);\n    }\n\n    return currentContext;\n  }\n\n  __processPendingState(props, context) {\n    let instance = this[INSTANCE];\n    let queue = this.__pendingStateQueue;\n    if (!queue) {\n      return instance.state;\n    }\n    // Reset pending queue\n    this.__pendingStateQueue = null;\n    let nextState = assign({}, instance.state);\n    for (let i = 0; i < queue.length; i++) {\n      let partial = queue[i];\n      assign(\n        nextState,\n        isFunction(partial) ?\n          partial.call(instance, nextState, props, context) :\n          partial\n      );\n    }\n\n    return nextState;\n  }\n\n  __updateComponent(\n    prevElement,\n    nextElement,\n    prevUnmaskedContext,\n    nextUnmaskedContext\n  ) {\n    let instance = this[INSTANCE];\n\n    // Maybe update component that has already been unmounted or failed mount.\n    if (!instance) {\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.measurer && Host.measurer.beforeUpdateComponent(this._mountID, this);\n    }\n\n    let willReceive;\n    let nextContext;\n    let nextProps;\n\n    // Determine if the context has changed or not\n    if (this._context === nextUnmaskedContext) {\n      nextContext = instance.context;\n    } else {\n      nextContext = this.__processContext(nextUnmaskedContext);\n      willReceive = true;\n    }\n\n    // Distinguish between a props update versus a simple state update\n    // Skip checking prop types again -- we don't read component.props to avoid\n    // warning for DOM component props in this upgrade\n    nextProps = nextElement.props;\n    if (prevElement !== nextElement) {\n      willReceive = true;\n    }\n\n    if (willReceive && instance.componentWillReceiveProps) {\n      // Calling this.setState() within componentWillReceiveProps will not trigger an additional render.\n      this.__isPendingState = true;\n      performInSandbox(() => {\n        instance.componentWillReceiveProps(nextProps, nextContext);\n      }, instance);\n      this.__isPendingState = false;\n    }\n\n    // Update refs\n    if (this.__currentElement.type.forwardRef) {\n      instance.prevForwardRef = prevElement.ref;\n      instance.forwardRef = nextElement.ref;\n    } else {\n      updateRef(prevElement, nextElement, this);\n    }\n\n    // Shoud update default\n    let shouldUpdate = true;\n    let prevProps = instance.props;\n    let prevState = instance.state;\n    // TODO: could delay execution processPendingState\n    let nextState = this.__processPendingState(nextProps, nextContext);\n\n    // ShouldComponentUpdate is not called when forceUpdate is used\n    if (!this.__isPendingForceUpdate) {\n      if (instance.shouldComponentUpdate) {\n        shouldUpdate = performInSandbox(() => {\n          return instance.shouldComponentUpdate(nextProps, nextState, nextContext);\n        }, instance);\n      } else if (instance.isPureComponent) {\n        // Pure Component\n        shouldUpdate = !shallowEqual(prevProps, nextProps) ||\n          !shallowEqual(prevState, nextState);\n      }\n    }\n\n    if (shouldUpdate) {\n      this.__isPendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      let prevContext = instance.context;\n\n      // Cannot use this.setState() in componentWillUpdate.\n      // If need to update state in response to a prop change, use componentWillReceiveProps instead.\n      if (instance.componentWillUpdate) {\n        performInSandbox(() => {\n          instance.componentWillUpdate(nextProps, nextState, nextContext);\n        }, instance);\n      }\n\n      // Replace with next\n      this.__currentElement = nextElement;\n      this._context = nextUnmaskedContext;\n      instance.props = nextProps;\n      instance.state = nextState;\n      instance.context = nextContext;\n\n      this.__updateRenderedComponent(nextUnmaskedContext);\n\n      if (instance.componentDidUpdate) {\n        performInSandbox(() => {\n          instance.componentDidUpdate(prevProps, prevState, prevContext);\n        }, instance);\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Calc update count.\n        this._updateCount++;\n      }\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state but we shortcut the rest of the update.\n      this.__currentElement = nextElement;\n      this._context = nextUnmaskedContext;\n      instance.props = nextProps;\n      instance.state = nextState;\n      instance.context = nextContext;\n    }\n\n    // Flush setState callbacks set in componentWillReceiveProps or boundary callback\n    let callbacks = this.__pendingCallbacks;\n    if (callbacks) {\n      this.__pendingCallbacks = null;\n      invokeFunctionsWithContext(callbacks, instance);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.measurer && Host.measurer.afterUpdateComponent(this._mountID);\n      Host.reconciler.receiveComponent(this);\n    }\n  }\n\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   */\n  __updateRenderedComponent(context) {\n    let prevRenderedComponent = this[RENDERED_COMPONENT];\n    let prevRenderedElement = prevRenderedComponent.__currentElement;\n\n    let instance = this[INSTANCE];\n    let nextRenderedElement;\n\n    Host.owner = this;\n\n    performInSandbox(() => {\n      if (process.env.NODE_ENV !== 'production') {\n        measureLifeCycle(() => {\n          nextRenderedElement = instance.render();\n        }, this._mountID, 'render');\n      } else {\n        nextRenderedElement = instance.render();\n      }\n    }, instance);\n\n    Host.owner = null;\n\n    if (shouldUpdateComponent(prevRenderedElement, nextRenderedElement)) {\n      const prevRenderedUnmaskedContext = prevRenderedComponent._context;\n      const nextRenderedUnmaskedContext = this.__processChildContext(context);\n\n      if (prevRenderedElement !== nextRenderedElement || prevRenderedUnmaskedContext !== nextRenderedUnmaskedContext) {\n        prevRenderedComponent.__updateComponent(\n          prevRenderedElement,\n          nextRenderedElement,\n          prevRenderedUnmaskedContext,\n          nextRenderedUnmaskedContext\n        );\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        Host.measurer && Host.measurer.recordOperation({\n          instanceID: this._mountID,\n          type: 'update component',\n          payload: {}\n        });\n      }\n    } else {\n      let prevNativeNode = prevRenderedComponent.__getNativeNode();\n      prevRenderedComponent.unmountComponent(true);\n\n      this[RENDERED_COMPONENT] = instantiateComponent(nextRenderedElement);\n      this[RENDERED_COMPONENT].__mountComponent(\n        this._parent,\n        instance,\n        this.__processChildContext(context),\n        (newNativeNode, parent) => {\n          prevNativeNode = toArray(prevNativeNode);\n          newNativeNode = toArray(newNativeNode);\n          let isFragmentAsPreNativeNode = isArray(prevNativeNode);\n\n          const driver = Host.driver;\n\n          // If the new length large then prev\n          let lastNativeNode;\n          for (let i = 0; i < newNativeNode.length; i++) {\n            let nativeNode = newNativeNode[i];\n            if (prevNativeNode[i]) {\n              driver.replaceChild(nativeNode, prevNativeNode[i]);\n            } else if (lastNativeNode) {\n              driver.insertAfter(nativeNode, lastNativeNode);\n            } else if (isFragmentAsPreNativeNode && this.__parentInstance) {\n              let mountedNode = getPrevSiblingNativeNode(this);\n              if (mountedNode) {\n                driver.insertAfter(nativeNode, mountedNode, parent);\n              } else {\n                driver.appendChild(nativeNode, parent);\n              }\n            } else {\n              driver.appendChild(nativeNode, parent);\n            }\n            lastNativeNode = nativeNode;\n          }\n\n          // If the new length less then prev\n          for (let i = newNativeNode.length; i < prevNativeNode.length; i++) {\n            driver.removeChild(prevNativeNode[i]);\n          }\n        }\n      );\n    }\n  }\n\n  __getNativeNode() {\n    let renderedComponent = this[RENDERED_COMPONENT];\n    if (renderedComponent) {\n      return renderedComponent.__getNativeNode();\n    }\n  }\n\n  __getPublicInstance() {\n    let instance = this[INSTANCE];\n\n    // The functional components cannot be given refs\n    if (instance.__isReactiveComponent) return null;\n\n    return instance;\n  }\n}\n\nexport default CompositeComponent;\n","import Host from './host';\nimport NativeComponent from './native';\nimport Instance from './instance';\nimport toArray from '../toArray';\nimport { INSTANCE, INTERNAL, NATIVE_NODE } from '../constant';\n\n/**\n * Fragment Component\n */\nclass FragmentComponent extends NativeComponent {\n  __mountComponent(parent, parentInstance, context, nativeNodeMounter) {\n    this.__initComponent(parent, parentInstance, context);\n\n    let instance = this[INSTANCE] = {};\n    instance[INTERNAL] = this;\n\n    // Mount children\n    this.__mountChildren(this.__currentElement, context);\n\n    let fragment = this.__getNativeNode();\n\n    if (nativeNodeMounter) {\n      nativeNodeMounter(fragment, parent);\n    } else {\n      for (let i = 0; i < fragment.length; i++) {\n        Host.driver.appendChild(fragment[i], parent);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      this.__currentElement.type = FragmentComponent;\n      Host.reconciler.mountComponent(this);\n    }\n\n    return instance;\n  }\n\n  __mountChildren(children, context) {\n    let fragment = this.__getNativeNode();\n\n    return this.__mountChildrenImpl(this._parent, children, context, (nativeNode) => {\n      nativeNode = toArray(nativeNode);\n      for (let i = 0; i < nativeNode.length; i++) {\n        fragment.push(nativeNode[i]);\n      }\n    });\n  }\n\n  unmountComponent(shouldNotRemoveChild) {\n    let nativeNode = this[NATIVE_NODE];\n\n    if (nativeNode) {\n      Instance.remove(nativeNode);\n\n      if (!shouldNotRemoveChild) {\n        for (let i = 0, l = nativeNode.length; i < l; i++) {\n          Host.driver.removeChild(nativeNode[i]);\n        }\n      }\n    }\n\n    // Do not need remove child when their parent is removed\n    this.__unmountChildren(true);\n\n    this.__destoryComponent();\n  }\n\n  __updateComponent(prevElement, nextElement, prevContext, nextContext) {\n    // Replace current element\n    this.__currentElement = nextElement;\n    this.__updateChildren(this.__currentElement, nextContext);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this.__currentElement.type = FragmentComponent;\n      Host.reconciler.receiveComponent(this);\n    }\n  }\n\n  __createNativeNode() {\n    return [];\n  }\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  FragmentComponent.displayName = 'Fragment';\n}\n\nexport default FragmentComponent;\n","export default function createRef() {\n  return {\n    current: null\n  };\n}","export default function(render) {\n  render.forwardRef = true;\n  return render;\n}","import shallowEqual from './vdom/shallowEqual';\n\nexport default function memo(type, compare) {\n  compare = compare || shallowEqual;\n\n  // Memo could composed\n  if (type.compares) {\n    type.compares.push(compare);\n  } else {\n    type.compares = [compare];\n  }\n\n  return type;\n}\n","export default function Fragment(props) {\n  return props.children;\n}","import inject from './vdom/inject';\nimport Instance from './vdom/instance';\nimport { isFunction } from './types';\n\nfunction render(element, container, options, callback) {\n  // Compatible with `render(element, container, callback)`\n  if (isFunction(options)) {\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n  // Init inject\n  inject(options);\n\n  let rootComponent = Instance.mount(element, container, options);\n  let componentInstance = rootComponent.__getPublicInstance();\n\n  if (callback) {\n    callback.call(componentInstance);\n  }\n\n  return componentInstance;\n}\n\nexport default render;\n","import Host from './host';\nimport EmptyComponent from './empty';\nimport NativeComponent from './native';\nimport TextComponent from './text';\nimport CompositeComponent from './composite';\nimport FragmentComponent from './fragment';\nimport reconciler from '../devtools/reconciler';\nimport { invokeMinifiedError } from '../error';\n\nexport default function inject({ driver, measurer }) {\n  // Inject component class\n  Host.Empty = EmptyComponent;\n  Host.Native = NativeComponent;\n  Host.Text = TextComponent;\n  Host.Fragment = FragmentComponent;\n  Host.Composite = CompositeComponent;\n\n  // Inject render driver\n  if (!(Host.driver = driver || Host.driver)) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error('Driver not found.');\n    } else {\n      invokeMinifiedError(5);\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Inject devtool renderer hook\n    Host.reconciler = reconciler;\n\n    // Inject performance measurer\n    Host.measurer = measurer;\n  }\n}\n","export default '1.0.11';\n","export createElement from './createElement';\nexport createContext from './createContext';\nexport createRef from './createRef';\nexport forwardRef from './forwardRef';\nexport { useState, useContext, useEffect, useLayoutEffect, useRef, useCallback, useMemo, useReducer, useImperativeHandle } from './hooks';\nexport memo from './memo';\nexport Fragment from './fragment';\nexport render from './render';\nexport Component, { PureComponent } from './vdom/component';\nexport version from './version';\n\nimport Host from './vdom/host';\nimport Instance from './vdom/instance';\nimport Element from './vdom/element';\nimport flattenChildren from './vdom/flattenChildren';\n\nexport const shared = {\n  Host,\n  Instance,\n  Element,\n  flattenChildren\n};\n","\n    import * as Rax from './index.js';\n    if (typeof module !== 'undefined') module.exports = Rax;\n    else self.Rax = Rax;\n    "],"names":["mountID","owner","__isUpdating","rootComponents","rootInstances","driver","Element","type","key","ref","props","_owner","NULL","isNull","obj","isFunction","isObject","isArray","array","Array","isString","string","isNumber","flattenChildren","children","result","traverseChildren","i","l","length","push","invokeMinifiedError","errCode","Error","RESERVED_PROPS","createElement","config","propName","ownerComponent","Host","hasReservedProps","childrenLength","arguments","childArray","defaultProps","undefined","invokeFunctionsWithContext","fns","context","value","call","updateCallbacks","effectCallbacks","scheduler","setTimeout","schedule","callback","flush","shift","scheduleEffect","flushEffect","hasOwnProperty","is","x","y","shallowEqual","objA","objB","keysA","Object","keys","INTERNAL","INSTANCE","NATIVE_NODE","RENDERED_COMPONENT","getCurrentInstance","getCurrentRenderingInstance","currentInstance","areInputsEqual","inputs","prevInputs","useState","initialState","hookID","getHookID","hooks","getHooks","newState","hook","eagerState","__isScheduled","update","__shouldUpdate","useEffect","effect","useEffectImpl","useLayoutEffect","defered","__create","__inputs","__prevInputs","current","immediately","__destory","didMount","willUnmount","didUpdate","useMemo","create","toArray","ValueEmitter","defaultValue","handlers","on","handler","off","this","filter","h","emit","uniqueId","BaseComponent","element","__currentElement","__initComponent","parent","parentInstance","_parent","__parentInstance","_context","_mountID","__destoryComponent","__mountComponent","nativeNodeMounter","__mountNativeNode","instance","unmountComponent","shouldNotRemoveChild","removeChild","__getName","currentElement","displayName","name","nativeNode","__getNativeNode","appendChild","__createNativeNode","__getPublicInstance","EmptyComponent","createEmpty","updateRef","prevElement","nextElement","component","prevRef","nextRef","detachRef","attachRef","refs","instantiateComponent","Native","Composite","Text","String","Empty","Fragment","throwInvalidComponentError","shouldUpdateComponent","prevEmpty","nextEmpty","getElementKeyName","index","elementKey","defaultName","toString","keyName","getPrevSiblingNativeNode","_renderedChildren","__mountIndex","Component","setState","partialState","updater","forceUpdate","PureComponent","isPureComponent","rootID","Root","__getRenderedComponent","render","set","node","get","remove","mount","container","hydrate","createBody","parentContext","renderOptions","beforeRender","parentInternal","__processChildContext","prevRootInstance","__penddingContext","rootInstance","afterRender","assign","STYLE","CHILDREN","EVENT_PREFIX_REGEXP","NativeComponent","appendType","append","__prevStyleCopy","__mountChildren","__mountChildrenImpl","renderedChildren","renderedChildrenImage","renderedChild","mountImage","__unmountChildren","Instance","__updateComponent","prevContext","nextContext","prevProps","nextProps","__updateProperties","__updateChildren","propKey","styleName","styleUpdates","lastStyle","test","eventListener","removeEventListener","slice","toLowerCase","removeAttribute","nextProp","prevProp","eventName","addEventListener","setAttribute","setStyle","nextChildrenElements","prevChildren","prevFirstChild","prevFirstNativeNode","shouldUnmountPrevFirstChild","nextChildren","prevChild","__unmount","shouldRemoveAllChildren","removeChildren","shouldUnmount","nextIndex","lastPlacedNode","nextNativeNodes","isFragmentAsParent","insertNodes","nativeNodes","prevSiblingNativeNode","_this","insertAfter","insertBefore","nextChild","prevChildNativeNode","concat","TextComponent","updateText","createText","ReactiveComponent","pureRender","__isReactiveComponent","__render","_hookID","__reRenders","_hooks","__children","__dependencies","state","forwardRef","prevForwardRef","compares","shouldComponentUpdate","arePropsEqual","readContext","Provider","contextProp","contextItem","contextEmitter","readEmitter","emitter","renderedContext","contextUpdater","newContext","_this2","bind","componentWillMount","componentDidMount","componentWillReceiveProps","componentDidUpdate","componentWillUnmount","__isPendingForceUpdate","dirtyComponents","getPendingCallbacks","internal","__pendingCallbacks","setPendingCallbacks","callbacks","getPendingStateQueue","__pendingStateQueue","runUpdate","prevUnmaskedContext","nextUnmaskedContext","mountOrderComparator","c1","c2","performUpdate","dirties","sort","pop","scheduleUpdate","shouldAsyncUpdate","indexOf","requestUpdate","hasComponentRendered","__isPendingState","Updater","runCallbacks","performInSandbox","fn","e","handleError","error","boundary","componentDidCatch","boundaryInternal","CompositeComponent","renderedElement","publicProps","componentPrototype","prototype","publicContext","__processContext","errorCallback","__processPendingState","maskedContext","contextTypes","contextName","currentContext","childContext","getChildContext","queue","nextState","partial","willReceive","shouldUpdate","prevState","componentWillUpdate","__updateRenderedComponent","nextRenderedElement","prevRenderedComponent","prevRenderedElement","prevRenderedUnmaskedContext","nextRenderedUnmaskedContext","prevNativeNode","newNativeNode","lastNativeNode","isFragmentAsPreNativeNode","replaceChild","mountedNode","renderedComponent","FragmentComponent","fragment","stack","defaultEmitter","propsValue","setValue","Consumer","onUpdate","consumer","updatedValue","compare","options","componentInstance","initialValue","reducer","initialArg","init","action","__actions","currentState","__eagerState","eagerReducer","__eagerReducer","next","module","exports","Rax","self"],"mappings":"+BAGe,CACbA,QAAS,EAETC,MAAO,KACPC,GAAc,EAEdC,eAAgB,GAChBC,cAAe,GAEfC,OAAQ,MCZK,SAASC,EAAQC,EAAMC,EAAKC,EAAKC,EAAOT,SAC9C,CAELM,KAAAA,EACAC,IAAAA,EACAC,IAAAA,EACAC,MAAAA,EAEAC,OAAQV,GCRL,IAAMW,EAAO,KAEb,SAASC,EAAOC,UACdA,IAAQF,EAGV,SAASG,EAAWD,SACH,mBAARA,EAGT,SAASE,EAASF,SACD,iBAARA,EAGT,SAASG,EAAQC,UACfC,MAAMF,QAAQC,GAGhB,SAASE,EAASC,SACE,iBAAXA,EAGT,SAASC,EAASD,SACE,iBAAXA,ECXD,SAASE,EAAgBC,MACtB,MAAZA,SACKA,MAEHC,EAAS,UAdjB,SAASC,EAAiBF,EAAUC,MAC9BR,EAAQO,OACL,IAAIG,EAAI,EAAGC,EAAIJ,EAASK,OAAQF,EAAIC,EAAGD,IAC1CD,EAAiBF,EAASG,GAAIF,QAGhCA,EAAOK,KAAKN,GASdE,CAAiBF,EAAUC,GAGpBA,EAAOI,OAAS,EAAIJ,EAASA,EAAO,GCZtC,SAASM,EAAoBC,SACxBC,MAAM,mBAAqBD,OCHjCE,EAAiB,CACrB1B,KAAK,EACLC,KAAK,GAcQ,SAAS0B,EAAc5B,EAAM6B,EAAQZ,GACtC,MAARjB,GAIAwB,EAAoB,OAKpBM,EADA3B,EAAQ,GAERF,EAAM,KACNC,EAAM,KACJ6B,EAAiBC,EAAKtC,SAEd,MAAVmC,EAAgB,KACdI,GAAmB,KAEL,MAAdJ,EAAO3B,MACT+B,GAAmB,EACnB/B,EAAM2B,EAAO3B,KAQG,MAAd2B,EAAO5B,MACTgC,GAAmB,EACnBhC,EAAM,GAAK4B,EAAO5B,KAIhBgC,MACGH,KAAYD,EAEVF,EAAeG,KAClB3B,EAAM2B,GAAYD,EAAOC,SAI7B3B,EAAQ0B,MAKNK,EAAiBC,UAAUb,OAAS,KACrB,EAAjBY,KACqB,IAAnBA,GAAyBxB,EAAQO,GAE9B,KACDmB,EAAanB,KACI,EAAjBiB,EAAoB,CACtBE,EAAiBxB,MAAMsB,OAClB,IAAId,EAAI,EAAGA,EAAIc,EAAgBd,IAClCgB,EAAWhB,GAAKe,UAAUf,EAAI,GAGlCjB,EAAMc,SAAWD,EAAgBoB,QATjCjC,EAAMc,SAAWA,KAcjBjB,GAAQA,EAAKqC,aAAc,KACzBA,EAAerC,EAAKqC,iBACnBP,KAAYO,OACSC,IAApBnC,EAAM2B,KACR3B,EAAM2B,GAAYO,EAAaP,WAK9B,IAAI/B,EACTC,EACAC,EACAC,EACAC,EACA4B,YCpGoBQ,EAA2BC,EAAKC,EAASC,OAC1D,IAAItB,EAAI,EAAGC,EAAImB,GAAOA,EAAIlB,OAAQF,EAAIC,EAAGD,IAC5CoB,EAAIpB,GAAGuB,KAAKF,EAASC,GCFzB,IAAIE,EAAkB,GAClBC,EAAkB,GACXC,EAAYC,WAUhB,SAASC,EAASC,GACQ,IAA3BL,EAAgBtB,QAClBwB,EAAUI,GAEZN,EAAgBrB,KAAK0B,GAIhB,SAASC,QACVD,QACGA,EAAWL,EAAgBO,QAChCF,IAIG,SAASG,EAAeH,GACE,IAA3BJ,EAAgBvB,QAClBwB,EAAUO,GAEZR,EAAgBtB,KAAK0B,GAGhB,SAASI,QACVJ,QACGA,EAAWJ,EAAgBM,QAChCF,ICnCJ,IAAMK,EAAiB,GAAGA,eAMnB,SAASC,EAAGC,EAAGC,UAEhBD,IAAMC,EAGK,IAAND,GAAW,EAAIA,GAAM,EAAIC,EAGzBD,GAAMA,GAAKC,GAAMA,EASb,SAASC,EAAaC,EAAMC,MACrCL,EAAGI,EAAMC,UACJ,MAGJnD,EAASkD,IAASrD,EAAOqD,KAAUlD,EAASmD,IAAStD,EAAOsD,UACxD,MAGLC,EAAQC,OAAOC,KAAKJ,MAGpBE,EAAMvC,SAFEwC,OAAOC,KAAKH,GAEGtC,cAClB,MAIJ,IAAIF,EAAI,EAAGA,EAAIyC,EAAMvC,OAAQF,QAC3BkC,EAAeX,KAAKiB,EAAMC,EAAMzC,MAAQmC,EAAGI,EAAKE,EAAMzC,IAAKwC,EAAKC,EAAMzC,YAClE,SAIJ,EC9CF,IAAM4C,EAAW,YACXC,EAAW,YACXC,EAAc,cACdC,EAAqB,8BCEzBC,WACApC,EAAKtC,OAASsC,EAAKtC,MAAMuE,GAGlC,SAASI,QACDC,EAAkBF,OACpBE,SACKA,EAGL9C,EAAoB,GAO1B,SAAS+C,EAAeC,EAAQC,MAC1BnE,EAAOmE,IAAeD,EAAOlD,SAAWmD,EAAWnD,cAC9C,MAGJ,IAAIF,EAAI,EAAGA,EAAIoD,EAAOlD,OAAQF,QAC7BmC,EAAGiB,EAAOpD,GAAIqD,EAAWrD,WAGtB,SAEF,EAGF,SAASsD,EAASC,OACjBL,EAAkBD,IAClBO,EAASN,EAAgBO,YACzBC,EAAQR,EAAgBS,eAEzBD,EAAMF,GAAS,CAGdpE,EAAWmE,KACbA,EAAeA,KA6BjBG,EAAMF,GAAU,CACdD,EA3Be,SAAAK,GAEVhD,EAAKrC,GACR0D,QAGI4B,EAAOH,EAAMF,GACbM,EAAaD,EAAK,GAEpBzE,EAAWwE,KACbA,EAAWA,EAASE,IAGjB3B,EAAGyB,EAAUE,KAGhBD,EAAK,GAAKD,EACNZ,MAAyBE,EAE3BA,EAAgBa,GAAgB,EAEhCb,EAAgBc,WAQpBT,OAIEM,EAAOH,EAAMF,UACdrB,EAAG0B,EAAK,GAAIA,EAAK,MACpBA,EAAK,GAAKA,EAAK,GACfX,EAAgBe,GAAiB,GAG5BJ,EAQF,SAASK,EAAUC,EAAQf,GAChCgB,EAAcD,EAAQf,GAAQ,GAGzB,SAASiB,EAAgBF,EAAQf,GACtCgB,EAAcD,EAAQf,GAGxB,SAASgB,EAAcD,EAAQf,EAAQkB,OAC/BpB,EAAkBD,IAClBO,EAASN,EAAgBO,YACzBC,EAAQR,EAAgBS,cAC9BP,OAAoBlC,IAAXkC,EAAuB,KAAOA,EAElCM,EAAMF,GAqCJ,KACCK,EAAOH,EAAMF,GACXe,EAAmCV,EAAnCU,EAAoBlB,EAAeQ,EAAzBW,EAClBX,EAAKW,EAAWpB,EAChBS,EAAKY,EAAepB,EACpBkB,EAASG,QAAUP,MA1CD,KACZI,EAAW,SAAXA,EAAYI,OACXA,GAAeL,EAAS,OAAOtC,EAAe,kBAAMuC,GAAS,SAC1DG,EAAYH,EAAZG,QACJA,IACFE,EAAUF,QAAUA,IACpBH,EAASG,QAAU,OAIjBE,EAAY,SAAZA,EAAaD,OACZA,GAAeL,EAAS,OAAOtC,EAAe,kBAAM4C,GAAU,SAC3DF,EAAYE,EAAZF,QACJA,IACFA,IACAE,EAAUF,QAAU,OAIxBH,EAASG,QAAUP,EAEnBT,EAAMF,GAAU,CACde,EAAAA,EACAK,EAAAA,EACAH,EAAcrB,EACdoB,EAAUpB,GAGZF,EAAgB2B,SAAS1E,KAAKoE,GAC9BrB,EAAgB4B,YAAY3E,KAAKyE,GACjC1B,EAAgB6B,UAAU5E,KAAK,iBACgBuD,EAAMF,GAA7BgB,IAAAA,EAAUD,IAAAA,EAChB,MAAZC,GAAqBrB,EAAeqB,IADhCC,KAENG,IACAL,QA8CD,SAASS,EAAQC,EAAQ7B,OACxBF,EAAkBD,IAClBO,EAASN,EAAgBO,YACzBC,EAAQR,EAAgBS,cAC9BP,OAAoBlC,IAAXkC,EAAuB,KAAOA,EAElCM,EAAMF,GAEJ,KACCH,EAAaK,EAAMF,GAAQ,IAC7BtE,EAAOkE,IAAYD,EAAeC,EAAQC,KAC5CK,EAAMF,GAAU,CAACyB,IAAU7B,SAJ7BM,EAAMF,GAAU,CAACyB,IAAU7B,UAQtBM,EAAMF,GAAQ,GC5MR,SAAS0B,EAAQ/F,UACvBG,EAAQH,GAAOA,EAAM,CAACA,OCGzBgG,wBACQC,QACLC,SAAW,QACX/D,MAAQ8D,6BAGfE,GAAA,SAAGC,QACIF,SAASlF,KAAKoF,MAGrBC,IAAA,SAAID,QACGF,SAAWI,KAAKJ,SAASK,OAAO,SAAAC,UAAKA,IAAMJ,OAGlDK,KAAA,WACEzE,EAA2BsE,KAAKJ,SAAU,KAAMI,KAAKnE,aAIrDuE,EAAW,qGCnBMC,wBACPC,QACLC,EAAmBD,6BAG1BE,EAAA,SAAgBC,EAAQC,EAAgB9E,QACjC+E,QAAUF,OACVG,EAAmBF,OACnBG,SAAWjF,OACXkF,SAAW3F,EAAKvC,aAGvBmI,EAAA,gBAKOR,EACDP,KAAK3C,GACL2C,KAAKW,QACLX,KAAKY,EACLZ,KAAKa,SACL,KAEAb,KAAK5C,UACFA,GAAY4C,KAAK5C,GAAUD,GAAY,SAIhD6D,EAAA,SAAiBP,EAAQC,EAAgB9E,EAASqF,QAC3CT,EAAgBC,EAAQC,EAAgB9E,QACxCsF,EAAkBD,OAMjBE,EAAW,UACjBA,EAAShE,GAAY6C,KAEdmB,KAGTC,iBAAA,SAAiBC,GACXrB,KAAK3C,KAAiBgE,GACxBlG,EAAKlC,OAAOqI,YAAYtB,KAAK3C,GAAc2C,KAAKW,cAG7CI,OAGPQ,EAAA,eACMC,EAAiBxB,KAAKO,EACtBpH,EAAOqI,GAAkBA,EAAerI,YAG1CA,GAAQA,EAAKsI,aACbtI,GAAQA,EAAKuI,MACbvI,GACAqI,KAIJN,EAAA,SAAkBD,OACZU,EAAa3B,KAAK4B,IAClBnB,EAAST,KAAKW,QAEdM,EACFA,EAAkBU,EAAYlB,GAE9BtF,EAAKlC,OAAO4I,YAAYF,EAAYlB,MAIxCmB,EAAA,kBAC8B,MAArB5B,KAAK3C,GACR2C,KAAK3C,GAAe2C,KAAK8B,IACzB9B,KAAK3C,MAGX0E,EAAA,kBACS/B,KAAK4B,UCjFVI,0FACJF,EAAA,kBACS3G,EAAKlC,OAAOgJ,YAAYjC,UAFNK,GCCtB,SAAS6B,EAAUC,EAAaC,EAAaC,OAC9CC,EAAUH,EAAcA,EAAY9I,IAAM,KAC1CkJ,EAAUH,EAAcA,EAAY/I,IAAM,KAG1CiJ,IAAYC,IAEdD,GAAWE,EAAUL,EAAY5I,OAAQ+I,EAASD,GAElDE,GAAWE,EAAUL,EAAY7I,OAAQgJ,EAASF,IAI/C,SAASI,EAAUvH,EAAgB7B,EAAKgJ,GACxCnH,GAIDP,EAAoB,OAIpBwG,EAAWkB,EAAUN,IAQrBpI,EAAWN,GACbA,EAAI8H,GACKvH,EAASP,GAClBA,EAAI4F,QAAUkC,EAEdjG,EAAekC,GAAUsF,KAAKrJ,GAAO8H,EAIlC,SAASqB,EAAUtH,EAAgB7B,EAAKgJ,MACzC1I,EAAWN,GAEbA,EAAI,UACC,KAED8H,EAAWkB,EAAUN,IAErBnI,EAASP,IAAQA,EAAI4F,UAAYkC,EACnC9H,EAAI4F,QAAU,KACL/D,EAAekC,GAAUsF,KAAKrJ,KAAS8H,UACzCjG,EAAekC,GAAUsF,KAAKrJ,ICrD5B,SAASsJ,EAAqBrC,OACvCa,SAEAvH,EAAS0G,IAAwB,OAAZA,GAAoBA,EAAQnH,KAGjDgI,EADEnH,EAASsG,EAAQnH,MACR,IAAIgC,EAAKyH,OAAOtC,GAEhB,IAAInF,EAAK0H,UAAUvC,GAEvBtG,EAASsG,IAAYpG,EAASoG,GACvCa,EAAW,IAAIhG,EAAK2H,KAAYxC,EAAPyC,SACJtH,IAAZ6E,GAAyB7G,EAAO6G,KAAwB,IAAZA,IAAiC,IAAZA,EAC1Ea,EAAW,IAAIhG,EAAK6H,MACXnJ,EAAQyG,GACjBa,EAAW,IAAIhG,EAAK8H,SAAS3C,GAE7B4C,IAGK/B,EAGF,SAAS+B,IAEZvI,EAAoB,GC3BxB,SAASwI,EAAsBhB,EAAaC,OACtCgB,EAAY3J,EAAO0I,GACnBkB,EAAY5J,EAAO2I,UACnBgB,GAAaC,EACRD,IAAcC,KAGnBxJ,EAAQsI,KAAgBtI,EAAQuI,MAIPpI,EAASmI,IAAgBjI,EAASiI,GAEtDnI,EAASoI,IAAgBlI,EAASkI,GAIvCxI,EAASuI,IACTvI,EAASwI,IACTD,EAAYhJ,OAASiJ,EAAYjJ,MACjCgJ,EAAY/I,MAAQgJ,EAAYhJ,KCpBvB,SAASkK,EAAkBlJ,EAAUkG,EAASiD,OACrDC,EAAalD,GAAWA,EAAQlH,IAChCqK,EAAc,IAAMF,EAAMG,SAAS,OAGrC1J,EAASwJ,GAAa,KACpBG,EAAU,IAAMH,cAEkB/H,IAAtBrB,EAASuJ,GASNA,EAAUF,SAEtBA,ECVI,SAASG,EAAyBvB,OAC3C5B,EAAS4B,QACN5B,EAAS4B,EAAUzB,GACxByB,EAAUzB,EAAiBzD,MACvBsD,aAAkBtF,EAAK0H,UACzBR,EAAY5B,eAIRvD,EAAOD,OAAOC,KAAKuD,EAAOoD,mBACvBtJ,EAAI8H,EAAUyB,EAAe,EAAQ,GAALvJ,EAAQA,IAAK,KAC9CoH,EAAalC,EAAQgB,EAAOoD,kBAAkB3G,EAAK3C,IAAIqH,QACrC,EAApBD,EAAWlH,cACNkH,EAAWA,EAAWlH,OAAS,QAGtCgG,aAAkBtF,EAAK8H,iBAGlB,KAFPZ,EAAY5B,OCzBGsD,wBACPzK,EAAOsC,QACZtC,MAAQA,OACRsC,QAAUA,OACV8G,KAAO,8BAGdsB,SAAA,SAASC,EAAc7H,QAEhB8H,QAAQF,SAAShE,KAAMiE,EAAc7H,MAG5C+H,YAAA,SAAY/H,QACL8H,QAAQC,YAAYnE,KAAM5D,SAOtBgI,EAAb,uBACc9K,EAAOsC,8BACXtC,EAAOsC,UACRyI,iBAAkB,oBAH3B,CAAmCN,GCpB/BO,EAAS,EAEPC,8DAIGjE,QAAU,KACVgE,OAASA,wCAGhBvC,EAAA,kBACS/B,KAAKwE,IAAyBzC,OAGvCyC,EAAA,kBACSxE,KAAK7C,GAAUG,MAGxBiB,OAAA,SAAO+B,QACAA,QAAUA,OACV6D,iBAGPM,OAAA,kBACSzE,KAAKM,YAtBGyD,MCOJ,CACbW,aAAIC,EAAMxD,GACHwD,EAAI,KACPA,EAAI,GAAQxD,GAECmD,SACXnJ,EAAKnC,cAAcmI,EAASmD,QAAUnD,EACtChG,EAAKpC,eAAeoI,EAASmD,QAAUnD,EAAShE,KAItDyH,aAAID,UACKA,EAAI,IAEbE,gBAAOF,OACDxD,EAAWnB,KAAK4E,IAAID,GACpBxD,IACFwD,EAAI,GAAQ,KACRxD,EAASmD,gBACJnJ,EAAKpC,eAAeoI,EAASmD,eAC7BnJ,EAAKnC,cAAcmI,EAASmD,WAIzCQ,eAAMxE,EAASyE,SAAatE,IAAAA,OAAQuE,IAAAA,QAK5B/L,EAASkC,EAAKlC,OAGH,MAAb8L,IACFA,EAAY9L,EAAOgM,kBAajBC,EAVEC,EAAgB,CACpB7E,QAAAA,EACAyE,UAAAA,EACAC,QAAAA,MAIF/L,EAAOmM,cAAgBnM,EAAOmM,aAAaD,GAIvC1E,EAAQ,KACN4E,EAAiB5E,EAAOtD,GAC5B+H,EAAgBG,EAAeC,EAAsBD,EAAexE,cAIlE0E,EAAmBvF,KAAK4E,IAAIG,MAC5BQ,GAAoBA,EAAiBjB,cACnCY,IAEFK,EAAiBpI,GAAUqI,EAAoBN,GAEjDK,EAAiBhH,OAAO+B,GACjBiF,MAMLE,EAFoB9C,EAAqB5H,EAAcwJ,IAEtBvD,EAAiB+D,EAAW,KAD5CG,GAAiB,gBAEjCR,IAAIK,EAAWU,GAEpBA,EAAalH,OAAO+B,GAGpBrH,EAAOyM,aAAezM,EAAOyM,YAAYP,GASlCM,OC7FIxI,OAAO0I,OCahBC,GAAQ,QACRC,GAAW,WAEXC,GAAsB,WAKPC,mGACnB/E,EAAA,SAAiBP,EAAQC,EAAgB9E,EAASqF,QAC3CT,EAAgBC,EAAQC,EAAgB9E,OAEvC4F,EAAiBxB,KAAKO,EACtBjH,EAAQkI,EAAelI,MACvBH,EAAOqI,EAAerI,KACtBiB,EAAWd,EAAMuM,IACjBG,EAAa1M,EAAM2M,QAdhB,YAiBJC,EAAkBP,GAAO,GAAIrM,EAAMsM,SAEpCzE,EAAW,CACbhI,KAAAA,EACAG,MAAAA,UAEF6H,EAAShE,GAAY6C,MAEhB5C,GAAY+D,EAzBR,SA2BL6E,QAEGG,EAAgB/L,EAAUwB,QAC1BsF,EAAkBD,UAGlBC,EAAkBD,QAClBkF,EAAgB/L,EAAUwB,IAI7B4F,GAAkBA,EAAenI,KACnCoJ,EAAUjB,EAAejI,OAAQiI,EAAenI,IAAK2G,MAOhDmB,KAGTgF,EAAA,SAAgB/L,EAAUwB,MACR,MAAZxB,EAAkB,OAAOA,MAEvBuH,EAAa3B,KAAK4B,WACjB5B,KAAKoG,EAAoBzE,EAAYlC,EAAQrF,GAAWwB,MAGjEwK,EAAA,SAAoB3F,EAAQrG,EAAUwB,EAASqF,WACzCoF,EAAmBrG,KAAK6D,kBAAoB,GAE1CyC,EAAwB,GACrB/L,EAAI,EAAGC,EAAIJ,EAASK,OAAQF,EAAIC,EAAGD,IAAK,KACzC+F,EAAUlG,EAASG,GACnBgM,EAAgB5D,EAAqBrC,IAE3C+F,EADa/C,EAAkB+C,EAAkB/F,EAAS/F,IACjCgM,GACXzC,EAAevJ,MAEvBiM,EAAaD,EAAcvF,EAC/BP,EACAT,KAAK5C,GACLxB,EACAqF,GAEFqF,EAAsB5L,KAAK8L,UAGtBF,KAGTG,EAAA,SAAkBpF,OACZgF,EAAmBrG,KAAK6D,qBAExBwC,EAAkB,KACf,IAAI3E,KAAQ2E,EAAkB,CACbA,EAAiB3E,GACvBN,iBAAiBC,QAE5BwC,kBAAoB,SAI7BzC,iBAAA,SAAiBC,MACXrB,KAAK3C,GAAc,KACjBhE,EAAM2G,KAAKO,EAAiBlH,IAC5BA,GACFmJ,EAAUxC,KAAKO,EAAiBhH,OAAQF,EAAK2G,MAG/C0G,GAAS7B,OAAO7E,KAAK3C,IAEhBgE,IACHlG,EAAKlC,OAAOqI,YAAYtB,KAAK3C,GAAc2C,KAAKW,SAGhDU,GAAuB,QAItBoF,EAAkBpF,QAElB6E,EAAkB,UAClBnF,OAGP4F,EAAA,SAAkBxE,EAAaC,EAAawE,EAAaC,GAIvD3E,EAAUC,OAFL5B,EAAmB6B,EAEYpC,UAEhC8G,EAAY3E,EAAY7I,MACxByN,EAAY3E,EAAY9I,WAEvB0N,EAAmBF,EAAWC,GAGR,MAAvBD,EAAUjB,KACZhM,EAAQiN,EAAUjB,MAA6C,IAA/BiB,EAAUjB,IAAUpL,YAC/C0L,EAAgBY,EAAUlB,IAAWgB,QAErCI,EAAiBF,EAAUlB,IAAWgB,MAQ/CG,EAAA,SAAmBF,EAAWC,OACxBG,EACAC,EACAC,EACEnO,EAASkC,EAAKlC,OACd0I,EAAa3B,KAAK4B,QAEnBsF,KAAWJ,KAGZI,IAAYrB,IACU,MAAtBiB,EAAUI,KAEVH,EAAUtK,eAAeyK,MAKvBA,IAAYtB,GAAO,KAEjByB,EAAYrH,KAAKkG,MAChBiB,KAAaE,GAChBD,EAAeA,GAAgB,IAClBD,GAAa,QAEvBjB,EAAkB,UAClB,GAAIJ,GAAoBwB,KAAKJ,GAAU,KAEtCK,EAAgBT,EAAUI,GAE5BvN,EAAW4N,IACbtO,EAAOuO,oBACL7F,EACAuF,EAAQO,MAAM,GAAGC,cACjBH,QAKJtO,EAAO0O,gBACLhG,EACAuF,EACAJ,EAAUI,QAKXA,KAAWH,EAAW,KACrBa,EAAWb,EAAUG,GACrBW,EAAWX,IAAYtB,GAAQ5F,KAAKkG,EACzB,MAAbY,EAAoBA,EAAUI,QAAWzL,KAIzCyL,IAAYrB,IACZgC,IAAaD,IACD,MAAZA,GAAgC,MAAZC,MAMlBX,IAAYtB,MACVgC,EAEFA,EAAW5H,KAAKkG,EAAkBP,GAAO,GAAIiC,QAExC1B,EAAkB,KAGT,MAAZ2B,EAAkB,KAEfV,KAAaU,EACXD,IAAaA,EAAST,IAAsC,IAAxBS,EAAST,OAChDC,EAAeA,GAAgB,IAClBD,GAAa,QAIzBA,KAAaS,EACZC,EAASV,KAAeS,EAAST,MACnCC,EAAeA,GAAgB,IAClBD,GAAaS,EAAST,SAKvCC,EAAeQ,OAEZ,GAAI9B,GAAoBwB,KAAKJ,GAAU,KAExCY,EAAYZ,EAAQO,MAAM,GAAGC,cAE7B/N,EAAWkO,IACb5O,EAAOuO,oBAAoB7F,EAAYmG,EAAWD,EAAUd,GAG1DpN,EAAWiO,IACb3O,EAAO8O,iBAAiBpG,EAAYmG,EAAWF,EAAUb,QAI3C,MAAZa,EACF3O,EAAO+O,aACLrG,EACAuF,EACAU,GAGF3O,EAAO0O,gBACLhG,EACAuF,EACAJ,EAAUI,IAgBdE,GASFnO,EAAOgP,SAAStG,EAAYyF,MAIhCH,EAAA,SAAiBiB,EAAsBtM,cAEjCuM,EAAenI,KAAK6D,kBACpB5K,EAASkC,EAAKlC,UAEU,MAAxBiP,GAAgD,MAAhBC,OAuChCC,EACAC,EACAC,EArCAC,EAAe,MAES,MAAxBL,MAIG,IAAI3E,EAAQ,EAAG9I,GAHpByN,EAAuBzI,EAAQyI,IAGmBzN,OAAQ8I,EAAQ9I,EAAQ8I,IAAS,KAC7EnB,EAAc8F,EAAqB3E,GACnC7B,EAAO4B,EAAkBiF,EAAcnG,EAAamB,GACpDiF,EAAYL,GAAgBA,EAAazG,GACzCS,EAAcqG,GAAaA,EAAUjI,EACrCqG,EAAc4B,GAAaA,EAAU3H,SAWvC0H,EAAa7G,GAPE,MAAb8G,GAAqBrF,EAAsBhB,EAAaC,IACtDD,IAAgBC,GAAewE,IAAgBhL,GAEjD4M,EAAU7B,EAAkBxE,EAAaC,EAAaxG,EACpDA,GAGiB4M,IAIjBA,IACFA,EAAUC,GAAY,GAGH9F,EAAqBP,QAW5CsG,KACFzP,EAAO0P,kBAEHlP,EAAOyO,IAAyBA,IAAyBA,EAAqBzN,YAIhE,MAAhB0N,MACG,IAAIzG,KAAQyG,EAAc,KACzBK,EAAYL,EAAazG,GACzBkH,EAAgBJ,EAAUC,IAAcF,EAAa7G,GAGpD0G,EAQMQ,GACTJ,EAAUpH,iBAAiBsH,IAR3BJ,EAA8BM,EAI1B/O,EAFJwO,GADAD,EAAiBI,GACoB5G,OAGnCyG,EAAsBA,EAAoB,QAQ9B,MAAhBE,EAAsB,KAEpBM,EAAY,EACZC,EAAiB,KACjBC,EAAkB,GAClBC,GAAqB,EACrBC,EAAc,SAACC,EAAazI,OAG1B0I,EADJD,EAAczJ,EAAQyJ,GAIlBF,IACFG,EAAwBvF,EAAyBwF,QAG9C,IAAI7O,EAAI,EAAGC,EAAI0O,EAAYzO,OAAQF,EAAIC,EAAGD,IACzCuO,EAGF7P,EAAOoQ,YAAYH,EAAY1O,EAAID,EAAI,GAAIuO,GAClCT,EAETpP,EAAOqQ,aAAaJ,EAAY3O,GAAI8N,GAC3Bc,EAETlQ,EAAOoQ,YAAYH,EAAY3O,GAAI4O,GAC1B1I,GAETxH,EAAO4I,YAAYqH,EAAY3O,GAAIkG,QAKpC,IAAIiB,KAAQ6G,EAAc,KACzBgB,EAAYhB,EAAa7G,GACzB8G,EAAYL,GAAgBA,EAAazG,MAGzC8G,IAAce,EAAW,KACvBC,EAAsBhB,EAAU5G,IAEhC4G,EAAU1E,IAAiB+E,GAC7BI,EAAYO,OAET,KAGD/I,EAAST,KAAK4B,IAEd/H,EAAQ4G,KACVuI,GAAqB,EACrBvI,EAAST,KAAKW,SAGhB4I,EAAUvI,EACRP,EACAT,KAAK5C,GACLxB,EACAqN,GAKJM,EAAUzF,EAAe+E,IAMrBhP,EAHJiP,EAAiBS,EAAU3H,MAIzBmH,EAAkBA,EAAgBU,OAAOX,GACzCA,EAAiBA,EAAeA,EAAerO,OAAS,IAExDsO,EAAgBrO,KAAKoO,GAKrBjP,EAAQmG,KAAK3C,WAEVA,GAAa5C,OAAS,EAC3BkL,GAAO3F,KAAK3C,GAAc0L,IAI1BT,GACFF,EAAehH,iBAAiBsH,GAG9BA,GACFzP,EAAO0P,eAAe3I,KAAK3C,SAGxBwG,kBAAoB0E,MAG3BzG,EAAA,eACQX,EAAWnB,KAAK5C,GAChBuE,EAAaxG,EAAKlC,OAAO8B,cAAcoG,EAAShI,KAAMgI,EAAS7H,MAAO0G,aAC5E0G,GAAShC,IAAI/C,EAAYR,GAClBQ,MAnckCtB,GCfvCqJ,mGACJ/C,EAAA,SAAkBxE,EAAaC,GAGzBD,KAFJC,EAAc,GAAKA,UAIZ7B,EAAmB6B,EACxBjH,EAAKlC,OAAO0Q,WAAW3J,KAAK4B,IAAmBQ,OASnDN,EAAA,kBAIS3G,EAAKlC,OAAO2Q,WAAW5J,KAAKO,EAAkBP,UApB7BK,GCIPwJ,0BACPC,EAAYzQ,gCAGjB0Q,GAAwB,IAGxBC,EAAWF,IACXG,QAAU,IAEVC,EAAc,IACdC,OAAS,KAET/K,SAAW,KACXE,UAAY,KACZD,YAAc,KAEdf,GAAgB,IAChBE,GAAiB,IACjB4L,EAAa,OACbC,EAAiB,KAEjBC,MAAQ,GAETR,EAAWS,eACRC,eAAiBpB,EAAKmB,WAAalR,OAGpCoR,EAAWX,EAAWW,gBACxBA,MACGC,sBAAwB,SAAC3D,WAExB4D,GAAgB,EAGXpQ,EAAIkQ,EAAShQ,OAAS,GAAQ,EAALF,EAAQA,OACpCoQ,EAAgBF,EAASlQ,GAAG6O,EAAK9P,MAAOyN,gBAKtC4D,GAAiBvB,EAAKoB,iBAAmBpB,EAAKmB,iDAK5DrM,SAAA,kBACS8B,KAAKmK,UAGdnM,UAAA,mBACWgC,KAAKiK,WAGhBW,YAAA,SAAYhP,cACJiP,EAAWjP,EAAQiP,SACnBC,EAAcD,EAASC,YACzBC,EAAc/K,KAAKqK,EAAeS,OACjCC,EAAa,KAEVC,GAAiBC,EADHJ,EAASI,aACMjL,MACnC+K,EAAc,CACZG,QAASF,EACTG,gBAAiBH,EAAenP,WAG5BuP,EAAiB,SAACC,GAClBA,IAAeN,EAAYI,kBAC7BG,EAAK9M,GAAiB,EACtB8M,EAAK/M,WAITyM,EAAenL,GAAGuL,QACb/L,YAAY3E,KAAKsQ,EAAejL,IAAIwL,KAAKP,EAAgBI,SACzDf,EAAeS,GAAeC,SAE9BA,EAAYI,gBAAkBJ,EAAYG,QAAQrP,SAG3D2P,mBAAA,gBACOhN,GAAiB,KAGxBiN,kBAAA,WACE/P,EAA2BsE,KAAKZ,aAGlCsM,0BAAA,gBACOlN,GAAiB,KAGxBmN,mBAAA,WACEjQ,EAA2BsE,KAAKV,cAGlCsM,qBAAA,WACElQ,EAA2BsE,KAAKX,gBAGlCd,OAAA,gBACOpB,GAAU0O,GAAyB,OACnC7H,SAAS,OAGhBS,OAAA,gBAKOwF,QAAU,OACVC,EAAc,OACd5L,GAAgB,MACjBlE,EAAW4F,KAAKgK,EAAShK,KAAK1G,MAAO0G,KAAKuK,WAAavK,KAAKuK,WAAavK,KAAKpE,eAE3EoE,KAAK1B,OACL4L,IAxHa,GAyHdlK,KAAKkK,GAILvP,EAAoB,QAInBsP,QAAU,OACV3L,GAAgB,EACrBlE,EAAW4F,KAAKgK,EAAShK,KAAK1G,MAAO0G,KAAKuK,WAAavK,KAAKuK,WAAavK,KAAKpE,gBAG5EoE,KAAKxB,SACF4L,EAAahQ,OACboE,GAAiB,GAGjBwB,KAAKoK,MAvI+BrG,GCJ3C+H,GAAkB,GAEtB,SAASC,GAAoBC,UACpBA,EAASC,EAGlB,SAASC,GAAoBF,EAAUG,UAC9BH,EAASC,EAAqBE,EAGvC,SAASC,GAAqBJ,UACrBA,EAASK,EAiBlB,SAASC,GAAUjK,OACb2J,EAAW3J,EAAUlF,MACpB6O,GAIL7Q,EAAKrC,GAAe,MAKhBqT,EAAYJ,GAAoBC,GACpCE,GAAoBF,EAAU,UAE1B7J,EAAc6J,EAASzL,EACvBgM,EAAsBP,EAASnL,SAC/B2L,EAAsBR,EAASxG,GAAqB+G,EACxDP,EAASxG,OAAoB/J,GAEzB2Q,GAAqBJ,IAAaA,EAASH,IAC7CG,EAASrF,EACPxE,EACAA,EACAoK,EACAC,GAIJ9Q,EAA2ByQ,EAAW9J,GAEtClH,EAAKrC,GAAe,GAGtB,SAAS2T,GAAqBC,EAAIC,UACzBA,EAAGxP,GAAU2D,SAAW4L,EAAGvP,GAAU2D,SAG9C,SAAS8L,QACHzR,EAAKrC,SACAqD,EAASyQ,QAGdvK,EACAwK,EAAUf,MACO,EAAjBe,EAAQpS,OAAY,CAEtB+B,IACAsP,GAAkB,GAIG,EAAjBe,EAAQpS,SACVoS,EAAUA,EAAQC,KAAKL,WAGlBpK,EAAYwK,EAAQE,MACzBT,GAAUjK,IAKhB,SAAS2K,GAAe3K,EAAW4K,MAC7BnB,GAAgBoB,QAAQ7K,GAAa,GACvCyJ,GAAgBpR,KAAK2H,GAGnB4K,EAAmB,IAEQ,EAAzBnB,GAAgBrR,cAGpB0B,EAASyQ,SAETA,KAIJ,SAASO,GAAc9K,EAAW4B,EAAc7H,OAC1C4P,EAAW3J,EAAUlF,MAEpB6O,GA1FP,IAAyBA,EAAU5P,EA8F7BA,IA9F6BA,EA+FLA,GA9FR2P,GADGC,EA+FLA,IA9FmCE,GAAoBF,EAAU,KACrEtR,KAAK0B,QAGC4P,EAAU/H,EA6FxBmJ,EAAuBpB,EAAS1O,GAGlC2G,GAhG0BA,EAiGLA,GAhGRmI,GADGJ,EAiGLA,KAhGyDA,EATxDK,EASkE,KACvE3R,KAAKuJ,IAmGT+H,EAASqB,GAAoBD,GAChCJ,GAAe3K,GAAW,KAI5B2J,EAASH,GAAyB,EAE9BuB,GACFJ,GAAe3K,KAKrB,IAAMiL,GAAU,CACdtJ,kBAAS3B,EAAW4B,EAAc7H,GAE3BjB,EAAKrC,GACR0D,IAEF2Q,GAAc9K,EAAW4B,EAAc7H,IAEzC+H,qBAAY9B,EAAWjG,GACrB+Q,GAAc9K,EAAW,KAAMjG,IAEjCmR,aAAc7R,GC1IhB,SAAS8R,GAAiBC,EAAItM,EAAU/E,cAE7BqR,IACP,MAAOC,GACHtR,EACFA,EAASsR,GAETC,GAAYxM,EAAUuM,IAK5B,SAASC,GAAYxM,EAAUyM,OACzBC,QAEG1M,EAAU,KACX6K,EAAW7K,EAAShE,MACpBgE,EAAS2M,kBAAmB,CAC9BD,EAAW1M,QAEN,IAAI6K,IAAYA,EAASpL,QAC9BO,EAAW6K,EAASpL,KAMpBiN,EAAU,KAENE,EAAmBF,EAAS1Q,MAC9B4Q,GACkBA,EAAiB9B,IAAuB8B,EAAiB9B,EAAqB,KACpFvR,KAAK,kBAAMmT,EAASC,kBAAkBF,UAItD3R,EAAU,iBACF2R,GACL,OAgBDI,mGACJhN,EAAA,SAAiBP,EAAQC,EAAgB9E,EAASqF,QAC3CT,EAAgBC,EAAQC,EAAgB9E,OAiBzCuF,EACA8M,EAXAzM,EAAiBxB,KAAKO,EACtBwD,EAAYvC,EAAerI,KAC3BE,EAAMmI,EAAenI,IACrB6U,EAAc1M,EAAelI,MAC7B6U,EAAqBpK,EAAUqK,UAG/BC,EAAgBrO,KAAKsO,EAAiB1S,OAOpCuS,GAAsBA,EAAmB1J,OAE3CtD,EAAW,IAAI4C,EAAUmK,EAAaG,GAC7B1U,EAAWoK,GAEpB5C,EAAW,IAAI0I,GAAkB9F,EAAW1K,GAE5C6J,IAEF,MAAOwK,UACAC,GAAYjN,EAAgBgN,GAKrCvM,EAAS7H,MAAQ4U,EACjB/M,EAASvF,QAAUyS,EACnBlN,EAASuB,KAAO,GAGhBvB,EAAS+C,QAAUA,OAKfpG,IAJJqD,EAAShE,GAAY6C,MAChB5C,GAAY+D,GAGWmJ,WACP7O,IAAjBqC,IAEFqD,EAASmJ,MAAQxM,EAAe,UAG9B8P,EAAQ,KACRW,EAAgB,SAACb,GACnBE,EAAQF,GAGNvM,EAASqK,oBACXgC,GAAiB,WAMbrM,EAASqK,sBAEVrK,EAAUoN,GAGQ,MAAnBN,IAGF9M,EAASmJ,OAFTnP,EAAKtC,MAAQmH,MAESwO,EAAsBN,EAAaG,GAEzDb,GAAiB,WAMbS,EAAkB9M,EAASsD,UAE5BtD,EAAUoN,GAEbpT,EAAKtC,MAAQ,WAGVyE,GAAsBqF,EAAqBsL,QAC3C3Q,GAAoB0D,EACvBhB,KAAKW,QACLQ,EACAnB,KAAKsF,EAAsB1J,GAC3BqF,GAGE2M,GACFD,GAAYxM,EAAUyM,IAGnBpM,EAAerI,KAAKoR,YAAclR,GACrCoJ,EAAUjB,EAAejI,OAAQF,EAAK2G,MAGpCmB,EAASsK,mBACX+B,GAAiB,WAMbrM,EAASsK,qBAEVtK,OAIDgL,EAAYnM,KAAKiM,SACjBE,SACGF,EAAqB,KAC1BvQ,EAA2ByQ,EAAWhL,IAQjCA,KAGTC,iBAAA,SAAiBC,OACXF,EAAWnB,KAAK5C,MAIhB+D,GAAYA,EAASyK,sBACvB4B,GAAiB,WACfrM,EAASyK,wBACRzK,GAG2B,MAA5BnB,KAAK1C,GAA6B,KAChCkE,EAAiBxB,KAAKO,EACtBlH,EAAMmI,EAAenI,KAEpBmI,EAAerI,KAAKoR,YAAclR,GACrCmJ,EAAUhB,EAAejI,OAAQF,EAAK2G,WAGnC1C,GAAoB8D,iBAAiBC,QACrC/D,GAAsB,UAMxB+O,EAAsB,UACtBR,GAAyB,OAEzB9K,OAOPuN,EAAA,SAAiB1S,OACX6S,EAAgB,GAEhBC,EADY1O,KAAKO,EAAiBpH,KACTuV,gBAEzBA,MACG,IAAIC,KAAeD,EACtBD,EAAcE,GAAe/S,EAAQ+S,UAIlCF,KAGTnJ,EAAA,SAAsBsJ,OAChBzN,EAAWnB,KAAK5C,GAEhByR,EAAe1N,EAAS2N,iBAAmB3N,EAAS2N,yBAEpDD,EACKlJ,GAAO,GAAIiJ,EAAgBC,GAG7BD,KAGTJ,EAAA,SAAsBlV,EAAOsC,OACvBuF,EAAWnB,KAAK5C,GAChB2R,EAAQ/O,KAAKqM,MACZ0C,SACI5N,EAASmJ,WAGb+B,EAAsB,aACvB2C,EAAYrJ,GAAO,GAAIxE,EAASmJ,OAC3B/P,EAAI,EAAGA,EAAIwU,EAAMtU,OAAQF,IAAK,KACjC0U,EAAUF,EAAMxU,GACpBoL,GACEqJ,EACArV,EAAWsV,GACTA,EAAQnT,KAAKqF,EAAU6N,EAAW1V,EAAOsC,GACzCqT,UAICD,KAGTrI,EAAA,SACExE,EACAC,EACAmK,EACAC,OAEIrL,EAAWnB,KAAK5C,MAGf+D,OAQD+N,EACArI,EACAE,EAGA/G,KAAKa,WAAa2L,EACpB3F,EAAc1F,EAASvF,SAEvBiL,EAAc7G,KAAKsO,EAAiB9B,GACpC0C,GAAc,GAMhBnI,EAAY3E,EAAY9I,MACpB6I,IAAgBC,IAClB8M,GAAc,GAGZA,GAAe/N,EAASuK,iCAErB2B,GAAmB,EACxBG,GAAiB,WACfrM,EAASuK,0BAA0B3E,EAAWF,IAC7C1F,QACEkM,GAAmB,GAItBrN,KAAKO,EAAiBpH,KAAKoR,YAC7BpJ,EAASqJ,eAAiBrI,EAAY9I,IACtC8H,EAASoJ,WAAanI,EAAY/I,KAElC6I,EAAUC,EAAaC,EAAapC,UAIlCmP,GAAe,EACfrI,EAAY3F,EAAS7H,MACrB8V,EAAYjO,EAASmJ,MAErB0E,EAAYhP,KAAKwO,EAAsBzH,EAAWF,MAGjD7G,KAAK6L,IACJ1K,EAASuJ,sBACXyE,EAAe3B,GAAiB,kBACvBrM,EAASuJ,sBAAsB3D,EAAWiI,EAAWnI,IAC3D1F,GACMA,EAASkD,kBAElB8K,GAAgBtS,EAAaiK,EAAWC,KACrClK,EAAauS,EAAWJ,KAI3BG,EAAc,MACXtD,GAAyB,MAE1BjF,EAAczF,EAASvF,QAIvBuF,EAASkO,qBACX7B,GAAiB,WACfrM,EAASkO,oBAAoBtI,EAAWiI,EAAWnI,IAClD1F,QAIAZ,EAAmB6B,OACnBvB,SAAW2L,EAChBrL,EAAS7H,MAAQyN,EACjB5F,EAASmJ,MAAQ0E,EACjB7N,EAASvF,QAAUiL,OAEdyI,EAA0B9C,GAE3BrL,EAASwK,oBACX6B,GAAiB,WACfrM,EAASwK,mBAAmB7E,EAAWsI,EAAWxI,IACjDzF,aAUAZ,EAAmB6B,OACnBvB,SAAW2L,EAChBrL,EAAS7H,MAAQyN,EACjB5F,EAASmJ,MAAQ0E,EACjB7N,EAASvF,QAAUiL,MAIjBsF,EAAYnM,KAAKiM,EACjBE,SACGF,EAAqB,KAC1BvQ,EAA2ByQ,EAAWhL,QAY1CmO,EAAA,SAA0B1T,OAKpB2T,SAJAC,EAAwBxP,KAAK1C,GAC7BmS,EAAsBD,EAAsBjP,EAE5CY,EAAWnB,KAAK5C,MAGpBjC,EAAKtC,MAAQmH,KAEbwN,GAAiB,WAMb+B,EAAsBpO,EAASsD,UAEhCtD,GAEHhG,EAAKtC,MAAQ,KAETsK,EAAsBsM,EAAqBF,GAAsB,KAC7DG,EAA8BF,EAAsB3O,SACpD8O,EAA8B3P,KAAKsF,EAAsB1J,GAE3D6T,IAAwBF,GAAuBG,IAAgCC,GACjFH,EAAsB7I,EACpB8I,EACAF,EACAG,EACAC,OAWC,KACDC,EAAiBJ,EAAsB5N,IAC3C4N,EAAsBpO,kBAAiB,QAElC9D,GAAsBqF,EAAqB4M,QAC3CjS,GAAoB0D,EACvBhB,KAAKW,QACLQ,EACAnB,KAAKsF,EAAsB1J,GAC3B,SAACiU,EAAepP,GACdmP,EAAiBnQ,EAAQmQ,GACzBC,EAAgBpQ,EAAQoQ,WAMpBC,EALAC,EAA4BlW,EAAQ+V,GAElC3W,EAASkC,EAAKlC,OAIXsB,EAAI,EAAGA,EAAIsV,EAAcpV,OAAQF,IAAK,KACzCoH,EAAakO,EAActV,MAC3BqV,EAAerV,GACjBtB,EAAO+W,aAAarO,EAAYiO,EAAerV,SAC1C,GAAIuV,EACT7W,EAAOoQ,YAAY1H,EAAYmO,QAC1B,GAAIC,GAA6BzE,EAAK1K,EAAkB,KACzDqP,EAAcrM,EAAyB0H,GACvC2E,EACFhX,EAAOoQ,YAAY1H,EAAYsO,EAAaxP,GAE5CxH,EAAO4I,YAAYF,EAAYlB,QAGjCxH,EAAO4I,YAAYF,EAAYlB,GAEjCqP,EAAiBnO,MAId,IAAIpH,EAAIsV,EAAcpV,OAAQF,EAAIqV,EAAenV,OAAQF,IAC5DtB,EAAOqI,YAAYsO,EAAerV,UAO5CqH,EAAA,eACMsO,EAAoBlQ,KAAK1C,MACzB4S,SACKA,EAAkBtO,OAI7BG,EAAA,eACMZ,EAAWnB,KAAK5C,UAGhB+D,EAAS4I,EAA8B,KAEpC5I,MAhcsBd,GC7D3B8P,mGACJnP,EAAA,SAAiBP,EAAQC,EAAgB9E,EAASqF,QAC3CT,EAAgBC,EAAQC,EAAgB9E,OAEzCuF,EAAWnB,KAAK5C,GAAY,IAChC+D,EAAShE,GAAY6C,MAGhBmG,EAAgBnG,KAAKO,EAAkB3E,OAExCwU,EAAWpQ,KAAK4B,OAEhBX,EACFA,EAAkBmP,EAAU3P,YAEvB,IAAIlG,EAAI,EAAGA,EAAI6V,EAAS3V,OAAQF,IACnCY,EAAKlC,OAAO4I,YAAYuO,EAAS7V,GAAIkG,UASlCU,KAGTgF,EAAA,SAAgB/L,EAAUwB,OACpBwU,EAAWpQ,KAAK4B,WAEb5B,KAAKoG,EAAoBpG,KAAKW,QAASvG,EAAUwB,EAAS,SAAC+F,GAChEA,EAAalC,EAAQkC,OAChB,IAAIpH,EAAI,EAAGA,EAAIoH,EAAWlH,OAAQF,IACrC6V,EAAS1V,KAAKiH,EAAWpH,SAK/B6G,iBAAA,SAAiBC,OACXM,EAAa3B,KAAK3C,MAElBsE,IACF+E,GAAS7B,OAAOlD,IAEXN,OACE,IAAI9G,EAAI,EAAGC,EAAImH,EAAWlH,OAAQF,EAAIC,EAAGD,IAC5CY,EAAKlC,OAAOqI,YAAYK,EAAWpH,SAMpCkM,GAAkB,QAElB1F,OAGP4F,EAAA,SAAkBxE,EAAaC,EAAawE,EAAaC,QAElDtG,EAAmB6B,OACnB6E,EAAiBjH,KAAKO,EAAkBsG,MAQ/C/E,EAAA,iBACS,OAtEqBiE,wDjBkBjB,SAAuBpG,OAC9BmL,EAAc,QAAU1K,IACxBiQ,EAAQ,GACRC,EAAiB,IAAI5Q,EAAaC,YAE/BkL,EAASvR,OACViX,OAA6B9U,IAAhBnC,EAAMuC,MAAsBvC,EAAMuC,MAAQ8D,IACnC9B,EAAS0S,GAA5B1U,OAAO2U,OACPtF,EAAWrN,EAAS,kBAAM,IAAI6B,EAAa7D,eAClDqP,EAAQrP,MAAQ0U,KAEG1U,GAAO2U,EAASD,GAEnC9R,EAAU,WACR4R,EAAMtD,QAGRtO,EAAU,WACRyM,EAAQ/K,QACP,CAACtE,IAEJwU,EAAM3V,KAAKwQ,GACJ5R,EAAMc,kBAGN6Q,EAAY9J,OACb+J,EAAUmF,EAAMA,EAAM5V,OAAS,MACjCyQ,EAAS,OAAOA,QACb/J,GAAYA,EAAShE,GAAW,IACjCgE,aAAoB0J,QAGxB1J,EAAWA,EAAShE,GAAUyD,SAEzBO,GAAYA,EAAS+J,SAAWoF,SAGzCzF,EAASI,YAAcA,EACvBJ,EAASC,YAAcA,EA+BhB,CACLD,SAAAA,EACA4F,kBA/BgBnX,cACT4R,EAAWrN,EAAS,kBAAMoN,EAAY7B,UACnBvL,EAASqN,EAAQrP,OAApCA,OAAO2U,UAEV3U,IAAUqP,EAAQrP,OAWtB4C,EAAU,kBACRyM,EAAQrL,GAAG6Q,GACJ,WACLxF,EAAQnL,IAAI2Q,KAEb,QAGGC,EAAWlR,EADAnG,EAAMc,UACY,UAC/BT,EAAWgX,GACNA,EAAS9U,mBAhBT6U,EAASE,GACZ/U,IAAU+U,GACZJ,EAASI,GANXJ,EAAStF,EAAQrP,qCkBvEd,CACLoD,QAAS,2BCFWwF,UACtBA,EAAO8F,YAAa,EACb9F,QCAM,SAActL,EAAM0X,UACjCA,EAAUA,GAAWhU,EAGjB1D,EAAKsR,SACPtR,EAAKsR,SAAS/P,KAAKmW,GAEnB1X,EAAKsR,SAAW,CAACoG,GAGZ1X,YCZM,SAAkBG,UACxBA,EAAMc,0BCGCkG,EAASyE,EAAW+L,EAAS1U,GCK9B,IAAkBnD,EDH3BU,EAAWmX,KACb1U,EAAW0U,EACXA,EAAU,MCCmB7X,GDE/B6X,EAAUA,GAAW,ICFU7X,OAE/BkC,EAAK6H,MAAQhB,EACb7G,EAAKyH,OAASmD,GACd5K,EAAK2H,KAAO4G,GACZvO,EAAK8H,SAAWkN,GAChBhV,EAAK0H,UAAYmL,IAGX7S,EAAKlC,OAASA,GAAUkC,EAAKlC,SAI/B0B,EAAoB,ODNpBoW,EADgBrK,GAAS5B,MAAMxE,EAASyE,EAAW+L,GACjB/O,WAElC3F,GACFA,EAASN,KAAKiV,GAGTA,uBEtBM,gBCgBO,CACpB5V,KAAAA,EACAuL,SAAAA,GACAxN,QAAAA,EACAiB,gBAAAA,yB3BwEK,SAAoByB,UACD4B,IACDoN,YAAYhP,yCA+E9B,SAAgBoV,OACfvT,EAAkBD,IAClBO,EAASN,EAAgBO,YACzBC,EAAQR,EAAgBS,kBAEzBD,EAAMF,KACTE,EAAMF,GAAU,CACdkB,QAAS+R,IAIN/S,EAAMF,gBAGR,SAAqB3B,EAAUuB,UAC7B4B,EAAQ,kBAAMnD,GAAUuB,yBAqB1B,SAAoBsT,EAASC,EAAYC,OACxC1T,EAAkBD,IAClBO,EAASN,EAAgBO,YACzBC,EAAQR,EAAgBS,WACxBE,EAAOH,EAAMF,OAEdK,EAAM,KACHN,EAAenE,EAAWwX,GAAQA,EAAKD,GAAcA,SA6BpDjT,EAAMF,GAAU,CACrBD,EA5Be,SAAAsT,GAEVjW,EAAKrC,GACR0D,QAMIuS,EAHO9Q,EAAMF,GAGA,MAEfR,MAAyBE,EAC3BsR,EAAMsC,EAAU3W,KAAK0W,GACrB3T,EAAgBa,GAAgB,MAC3B,KACCgT,EAAevC,EAAMwC,EAErBlT,GAAamT,EADEzC,EAAM0C,GACKH,EAAcF,MAC1C1U,EAAG2B,EAAYiT,UAGnBvC,EAAMwC,EAAelT,EACrB0Q,EAAMsC,EAAU3W,KAAK0W,GACrB3T,EAAgBc,WAOlB,CACE8S,EAAW,GACXI,EAAgBR,EAChBM,EAAczT,QAKdiR,EAAQ3Q,EAAK,GACfsT,EAAOtT,EAAK,MAEkB,EAA9BX,EAAgByM,MACb,IAAI3P,EAAI,EAAGA,EAAIwU,EAAMsC,EAAU5W,OAAQF,IAC1CmX,EAAOT,EAAQS,EAAM3C,EAAMsC,EAAU9W,SAGvCmX,EAAO3C,EAAMwC,SAGV7U,EAAGgV,EAAMtT,EAAK,MACjBA,EAAK,GAAKsT,EACVjU,EAAgBe,GAAiB,GAGnCuQ,EAAM0C,EAAiBR,EACvBlC,EAAMwC,EAAeG,EACrB3C,EAAMsC,EAAU5W,OAAS,EAElBwD,EAAMF,wBAvHR,SAA6B1E,EAAKmG,EAAQ7B,GAG/CiB,EAAgB,kBACVjF,EAAWN,IACbA,EAAImG,KACG,kBAAMnG,EAAI,QACD,MAAPA,GACTA,EAAI4F,QAAUO,IACP,WACLnG,EAAI4F,QAAU,YAHX,GANUpF,EAAQ8D,GAAUA,EAAO8L,OAAO,CAACpQ,IAAQ,yB4B5JpC,oBAAXsY,OAAwBA,OAAOC,QAAUC,GAC/CC,KAAKD,IAAMA"}
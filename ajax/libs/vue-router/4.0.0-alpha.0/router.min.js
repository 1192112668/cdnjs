"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const base_1=require("./history/base"),matcher_1=require("./matcher"),index_1=require("./types/index"),utils_1=require("./utils"),errors_1=require("./errors");class Router{constructor(t){this.beforeGuards=[],this.afterGuards=[],this.currentRoute=index_1.START_LOCATION_NORMALIZED,this.pendingLocation=index_1.START_LOCATION_NORMALIZED,this.errorHandlers=[],this.history=t.history,this.matcher=new matcher_1.RouterMatcher(t.routes),this.history.listen(async(t,r,e)=>{const i=this.matchLocation(t,this.currentRoute),s={...t,...i};this.pendingLocation=s;try{if(await this.navigate(s,this.currentRoute),this.pendingLocation!==s)return this.triggerError(new errors_1.NavigationCancelled(s,this.currentRoute),!1);this.currentRoute={...t,...i},this.updateReactiveRoute()}catch(t){if(t instanceof errors_1.NavigationGuardRedirect){if(this.pendingLocation!==s)return this.triggerError(new errors_1.NavigationCancelled(s,this.currentRoute),!1);this.triggerError(t,!1),this.push(t.to).catch(()=>{})}else t instanceof errors_1.NavigationAborted?e.direction===base_1.NavigationDirection.back?this.history.forward(!1):this.history.back(!1):this.triggerError(t,!1)}})}matchLocation(t,r,e){const i=this.matcher.resolve(t,r);if("redirect"in i){const{redirect:s}=i,o={...i.normalizedLocation,fullPath:this.history.utils.stringifyURL({path:i.normalizedLocation.path,query:t.query,hash:t.hash}),query:this.history.utils.normalizeQuery(t.query||{}),hash:t.hash,redirectedFrom:e};if("string"==typeof s)return this.matchLocation(this.history.utils.normalizeLocation(s),r,o);if("function"==typeof s){const t=s(o);return"string"==typeof t?this.matchLocation(this.history.utils.normalizeLocation(t),r,o):this.matchLocation({...t,query:this.history.utils.normalizeQuery(t.query||{}),hash:t.hash||""},r,o)}return this.matchLocation({...s,query:this.history.utils.normalizeQuery(s.query||{}),hash:s.hash||""},r,o)}return{...i,...this.history.utils.normalizeLocation({path:i.path,query:t.query,hash:t.hash}),redirectedFrom:e}}async push(t){let r,e;if("string"==typeof t||"path"in t)r=this.history.utils.normalizeLocation(t),e=this.matchLocation(r,this.currentRoute);else{const i=t.query?this.history.utils.normalizeQuery(t.query):{},s=t.hash||"";e=this.matchLocation({...t,query:i,hash:s},this.currentRoute),r=this.history.utils.normalizeLocation({query:i,hash:s,...e})}if(this.currentRoute!==index_1.START_LOCATION_NORMALIZED&&this.currentRoute.fullPath===r.fullPath)return this.currentRoute;const i=e;this.pendingLocation=i;try{await this.navigate(i,this.currentRoute)}catch(t){if(t instanceof errors_1.NavigationGuardRedirect){if(this.pendingLocation!==i)throw new errors_1.NavigationCancelled(i,this.currentRoute);return this.push(t.to)}if(this.pendingLocation!==i)throw new errors_1.NavigationCancelled(i,this.currentRoute);this.triggerError(t)}if(this.pendingLocation!==i)throw new errors_1.NavigationCancelled(i,this.currentRoute);!0===t.replace?this.history.replace(r):this.history.push(r);const s=this.currentRoute;this.currentRoute=i,this.updateReactiveRoute();for(const t of this.afterGuards)t(i,s);return this.currentRoute}replace(t){const r="string"==typeof t?{path:t}:t;return this.push({...r,replace:!0})}async runGuardQueue(t){for(const r of t)await r()}async navigate(t,r){let e;e=await utils_1.extractComponentsGuards(r.matched.filter(r=>t.matched.indexOf(r)<0).reverse(),"beforeRouteLeave",t,r),await this.runGuardQueue(e),e=[];for(const i of this.beforeGuards)e.push(utils_1.guardToPromiseFn(i,t,r));await this.runGuardQueue(e),e=await utils_1.extractComponentsGuards(t.matched.filter(t=>r.matched.indexOf(t)>-1),"beforeRouteUpdate",t,r),await this.runGuardQueue(e),e=[];for(const i of t.matched)if(i.beforeEnter&&r.matched.indexOf(i)<0)if(Array.isArray(i.beforeEnter))for(const s of i.beforeEnter)e.push(utils_1.guardToPromiseFn(s,t,r));else e.push(utils_1.guardToPromiseFn(i.beforeEnter,t,r));await this.runGuardQueue(e),e=await utils_1.extractComponentsGuards(t.matched.filter(t=>r.matched.indexOf(t)<0),"beforeRouteEnter",t,r),await this.runGuardQueue(e)}beforeEach(t){return this.beforeGuards.push(t),()=>{const r=this.beforeGuards.indexOf(t);r>-1&&this.beforeGuards.splice(r,1)}}afterEach(t){return this.afterGuards.push(t),()=>{const r=this.afterGuards.indexOf(t);r>-1&&this.afterGuards.splice(r,1)}}onError(t){this.errorHandlers.push(t)}triggerError(t,r=!0){for(const r of this.errorHandlers)r(t);if(r)throw t}updateReactiveRoute(){if(!this.app)return;const t={...this.currentRoute};Object.defineProperty(t,"matched",{enumerable:!1}),this.app._route=Object.freeze(t)}}exports.Router=Router;
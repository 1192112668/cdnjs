{"version":3,"file":"ef.min.js","sources":["../node_modules/eft-parser/src/escape-parser.js","../node_modules/eft-parser/src/eft-parser.js","../node_modules/ef-core/src/lib/utils/type-of.js","../node_modules/ef-core/src/lib/utils/literals-mix.js","../node_modules/ef-core/src/lib/utils/array-helper.js","../node_modules/ef-core/src/lib/render-queue.js","../node_modules/ef-core/src/lib/utils/polyfills.js","../node_modules/ef-core/src/lib/resolver.js","../node_modules/ef-core/src/lib/utils/isnan.js","../node_modules/ef-core/src/lib/binding.js","../node_modules/ef-core/src/lib/utils/fast-instance-of.js","../node_modules/ef-core/src/lib/utils/buble-fix.js","../node_modules/ef-core/src/lib/utils/debug.js","../node_modules/ef-core/src/lib/utils/is-browser.js","../node_modules/ef-core/src/lib/utils/global-shared.js","../node_modules/ef-core/src/lib/utils/dom-helper.js","../node_modules/ef-core/src/lib/utils/event-helper.js","../node_modules/ef-core/src/lib/element-creator.js","../node_modules/ef-core/src/lib/creator.js","../node_modules/ef-core/src/lib/utils/dom-arr-helper.js","../node_modules/ef-core/src/lib/map-attrs.js","../node_modules/ef-core/src/mount-options.js","../node_modules/ef-core/src/lib/renderer.js","../node_modules/ef-core/src/lib/jsx-create-element.js","../src/ef.js","../node_modules/ef-core/src/ef-core.js","../src/lib/parser.js","../node_modules/ef-core/src/lib/utils/scoped-component.js"],"sourcesContent":["// Set the escape character\nconst char = '&'\nconst doubleChar = char + char\n\n// Initlize RegExp\nconst oct = new RegExp(`\\\\${char}[0-7]{1,3}`, 'g')\nconst ucp = new RegExp(`\\\\${char}u\\\\[.*?\\\\]`, 'g')\nconst uni = new RegExp(`\\\\${char}u.{0,4}`, 'g')\nconst hex = new RegExp(`\\\\${char}x.{0,2}`, 'g')\nconst esc = new RegExp(`\\\\${char}`, 'g')\nconst b = new RegExp(`\\\\${char}b`, 'g')\nconst t = new RegExp(`\\\\${char}t`, 'g')\nconst n = new RegExp(`\\\\${char}n`, 'g')\nconst v = new RegExp(`\\\\${char}v`, 'g')\nconst f = new RegExp(`\\\\${char}f`, 'g')\nconst r = new RegExp(`\\\\${char}r`, 'g')\n\n// Escape octonary sequence\nconst O2C = () => {\n\tthrow new SyntaxError('Octal escape sequences are not allowed in EFML.')\n}\n\n// Escape unicode code point sequence\nconst UC2C = (val) => {\n\tval = val.substr(3, val.length - 4)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\ttry {\n\t\treturn String.fromCodePoint(val)\n\t} catch (err) {\n\t\tthrow new SyntaxError('Undefined Unicode code-point')\n\t}\n}\n\n// Escape unicode sequence\nconst U2C = (val) => {\n\tval = val.substring(2)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\treturn String.fromCharCode(val)\n}\n\n// Escape hexadecimal sequence\nconst X2C = (val) => {\n\tval = `00${val.substring(2)}`\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid hexadecimal escape sequence')\n\treturn String.fromCharCode(val)\n}\n\nconst efEscape = (string) => {\n\t// Split strings\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = []\n\n\t// Escape all known escape characters\n\tfor (let i of splitArr) {\n\t\tconst escapedStr = i\n\t\t\t.replace(oct, O2C)\n\t\t\t.replace(ucp, UC2C)\n\t\t\t.replace(uni, U2C)\n\t\t\t.replace(hex, X2C)\n\t\t\t.replace(b, '\\b')\n\t\t\t.replace(t, '\\t')\n\t\t\t.replace(n, '\\n')\n\t\t\t.replace(v, '\\v')\n\t\t\t.replace(f, '\\f')\n\t\t\t.replace(r, '\\r')\n\t\t\t// Remove all useless escape characters\n\t\t\t.replace(esc, '')\n\t\tescaped.push(escapedStr)\n\t}\n\t// Return escaped string\n\treturn escaped.join(char)\n}\n\nconst checkEscape = string => string[string.length - 1] === char\n\nconst splitWith = (string, char) => {\n\tconst splitArr = string.split(char)\n\tconst escapedSplit = []\n\tlet escaped = false\n\tfor (let i of splitArr) {\n\t\tif (escaped) escapedSplit[escapedSplit.length - 1] += `${char}${i}`\n\t\telse escapedSplit.push(i)\n\t\tescaped = checkEscape(i)\n\t}\n\treturn escapedSplit\n}\n\nconst splitBy = (string, char) => {\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = splitWith(splitArr.shift(), char)\n\tfor (let i of splitArr) {\n\t\tconst escapedSplit = splitWith(i, char)\n\t\tescaped[escaped.length - 1] += `${doubleChar}${escapedSplit.shift()}`\n\t\tescaped.push(...escapedSplit)\n\t}\n\treturn escaped\n}\n\nexport { efEscape, splitBy }\n","import { efEscape, splitBy } from './escape-parser.js'\n\nconst typeSymbols = '>#%@.-+'\nconst reserved = [\n\t'$ctx', '$refs', '$data', '$methods', '$mount', '$umount', '$subscribe', '$unsubscribe', '$update',\n\t'$dispatch', '$emit', '$on', '$off', '$destroy', '__DIRECTMOUNT__'\n]\nconst mustache = /\\{\\{.+?\\}\\}/g\nconst spaceIndent = /^(\\t*)( *).*/\nconst hashref = /#([^}]|}[^}])*$/\n\nconst getErrorMsg = (msg, line = -2) => `Failed to parse eft template: ${msg}. at line ${line + 1}`\n\nconst isEmpty = string => !string.replace(/\\s/, '')\n\nconst checkValidType = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\nconst ESCAPE = (string) => {\n\tif (!string) return [string, false]\n\ttry {\n\t\tconst parsed = JSON.parse(string)\n\t\tif (['number', 'boolean'].indexOf(typeof parsed) === -1) return [efEscape(string), true]\n\t\treturn [parsed, false]\n\t} catch (e) {\n\t\treturn [efEscape(string), true]\n\t}\n}\n\nconst getOffset = (string, parsingInfo) => {\n\tif (parsingInfo.offset !== null) return\n\tparsingInfo.offset = string.match(/\\s*/)[0]\n\tif (parsingInfo.offset) parsingInfo.offsetReg = parsingInfo.offset\n}\n\nconst removeOffset = (string, parsingInfo, i) => {\n\tif (parsingInfo.offsetReg) {\n\t\tlet removed = false\n\t\tstring = string.replace(parsingInfo.offsetReg, () => {\n\t\t\tremoved = true\n\t\t\treturn ''\n\t\t})\n\t\tif (!removed) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got -1`, i))\n\t}\n\treturn string\n}\n\nconst getIndent = (string, parsingInfo) => {\n\tif (parsingInfo.indentReg) return\n\tconst spaces = string.match(spaceIndent)[2]\n\tif (spaces) {\n\t\tparsingInfo.indentReg = new RegExp(spaces, 'g')\n\t}\n}\n\nconst getDepth = (string, parsingInfo, i) => {\n\tlet depth = 0\n\tif (parsingInfo.indentReg) string = string.replace(/^\\s*/, str => str.replace(parsingInfo.indentReg, '\\t'))\n\tconst content = string.replace(/^\\t*/, (str) => {\n\t\tdepth = str.length\n\t\treturn ''\n\t})\n\tif ((/^\\s/).test(content)) throw new SyntaxError(getErrorMsg('Bad indent', i))\n\treturn { depth, content }\n}\n\nconst resolveDepth = (ast, depth) => {\n\tlet currentNode = ast\n\tfor (let i = 0; i < depth; i++) currentNode = currentNode[currentNode.length - 1]\n\treturn currentNode\n}\n\nconst splitDefault = (string) => {\n\tstring = string.slice(2, string.length - 2)\n\tconst [_path, ..._default] = splitBy(string, '=')\n\tconst pathArr = splitBy(_path.trim(), '.').map(efEscape)\n\tconst [defaultVal, escaped] = ESCAPE(_default.join('=').trim())\n\tif (checkValidType(defaultVal) && (escaped || (!escaped && defaultVal !== ''))) return [pathArr, defaultVal]\n\treturn [pathArr]\n}\n\nconst splitLiterals = (string) => {\n\tconst strs = string.split(mustache)\n\tif (strs.length === 1) return ESCAPE(string)[0]\n\tconst tmpl = []\n\tif (strs.length === 2 && !strs[0] && !strs[1]) tmpl.push(0)\n\telse tmpl.push(strs.map(efEscape))\n\tconst mustaches = string.match(mustache)\n\tif (mustaches) tmpl.push(...mustaches.map(splitDefault))\n\treturn tmpl\n}\n\nconst pushStr = (textArr, str) => {\n\tif (str) textArr.push(str)\n}\n\nconst parseText = (string) => {\n\tconst result = splitLiterals(string)\n\tif (checkValidType(result)) return [`${result}`]\n\tconst [strs, ...exprs] = result\n\tconst textArr = []\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tpushStr(textArr, strs[i])\n\t\ttextArr.push(exprs[i])\n\t}\n\tpushStr(textArr, strs[strs.length - 1])\n\treturn textArr\n}\n\nconst dotToSpace = val => val.replace(/\\./g, ' ')\n\nconst parseTag = (string) => {\n\tconst tagInfo = {}\n\tconst [tag, ...content] = splitBy(string.replace(hashref, (val) => {\n\t\ttagInfo.ref = val.slice(1)\n\t\treturn ''\n\t}), '.')\n\ttagInfo.tag = efEscape(tag)\n\ttagInfo.class = splitLiterals(content.join('.'))\n\tif (typeof tagInfo.class === 'string') tagInfo.class = dotToSpace(tagInfo.class).trim()\n\telse if (tagInfo.class[0]) tagInfo.class[0] = tagInfo.class[0].map(dotToSpace)\n\treturn tagInfo\n}\n\nconst parseNodeAttrs = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tname: efEscape(splitted.shift().trim()),\n\t\tvalue: splitLiterals(splitted.join('=').trim())\n\t}\n}\n\nconst parseNodeProps = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tpropPath: splitBy(splitted.shift().trim(), '.').map(efEscape),\n\t\tvalue: splitLiterals(splitted.join('=').trim())\n\t}\n}\n\nconst parseEvent = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tname: splitted.shift().trim(),\n\t\tvalue: splitted.join('=').trim()\n\t}\n}\n\nconst setOption = (options, option) => {\n\tswitch (option) {\n\t\tcase 'stop': {\n\t\t\toptions.s = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'stopImmediate': {\n\t\t\toptions.i = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'prevent': {\n\t\t\toptions.p = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'shift': {\n\t\t\toptions.h = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'alt': {\n\t\t\toptions.a = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'ctrl': {\n\t\t\toptions.c = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'meta': {\n\t\t\toptions.t = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'capture': {\n\t\t\toptions.u = 1\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Abandoned unsupported eft event option '${option}'.`)\n\t\t}\n\t}\n}\n\nconst getOption = (options, keys, option) => {\n\tconst keyCode = parseInt(option, 10)\n\tif (isNaN(keyCode)) return setOption(options, efEscape(option))\n\tkeys.push(keyCode)\n}\n\nconst getEventOptions = (name) => {\n\tconst options = {}\n\tconst keys = []\n\tconst [listener, ...ops] = splitBy(name, '.')\n\toptions.l = efEscape(listener)\n\tfor (let i of ops) getOption(options, keys, i)\n\tif (keys.length > 0) options.k = keys\n\treturn options\n}\n\nconst splitEvents = (string) => {\n\tconst [name, ...value] = splitBy(string, ':')\n\tconst content = value.join(':')\n\tconst escapedName = efEscape(name.trim())\n\tif (content) return [escapedName, splitLiterals(content)]\n\treturn [escapedName]\n}\n\nconst parseLine = ({line, ast, parsingInfo, i}) => {\n\tif (isEmpty(line)) return\n\tgetOffset(line, parsingInfo)\n\n\tconst trimmedLine = removeOffset(line, parsingInfo, i)\n\tgetIndent(trimmedLine, parsingInfo)\n\n\tlet { depth, content } = getDepth(trimmedLine, parsingInfo, i)\n\n\tif (content) {\n\t\tif (depth < 0 || depth - parsingInfo.prevDepth > 1 || (depth - parsingInfo.prevDepth === 1 && ['comment', 'tag'].indexOf(parsingInfo.prevType) === -1) || (parsingInfo.prevType !== 'comment' && depth === 0 && parsingInfo.topExists)) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got ${depth}`, i))\n\t\tconst type = content[0]\n\t\tcontent = content.slice(1)\n\t\tif (!content && typeSymbols.indexOf(type) >= 0) throw new SyntaxError(getErrorMsg('Empty content', i))\n\t\t// Jump back to upper level\n\t\tif (depth < parsingInfo.prevDepth || (depth === parsingInfo.prevDepth && parsingInfo.prevType === 'tag')) parsingInfo.currentNode = resolveDepth(ast, depth)\n\t\tparsingInfo.prevDepth = depth\n\n\t\tswitch (type) {\n\t\t\tcase '>': {\n\t\t\t\tconst info = parseTag(content)\n\t\t\t\tconst newNode = [{\n\t\t\t\t\tt: info.tag\n\t\t\t\t}]\n\t\t\t\tif (info.class) {\n\t\t\t\t\tnewNode[0].a = {}\n\t\t\t\t\tnewNode[0].a.class = info.class\n\t\t\t\t}\n\t\t\t\tif (info.ref) newNode[0].r = info.ref\n\t\t\t\tparsingInfo.currentNode.push(newNode)\n\t\t\t\tparsingInfo.currentNode = newNode\n\t\t\t\tparsingInfo.prevType = 'tag'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '#': {\n\t\t\t\tconst { name, value } = parseNodeAttrs(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].a) parsingInfo.currentNode[0].a = {}\n\t\t\t\tparsingInfo.currentNode[0].a[name] = value\n\t\t\t\tparsingInfo.prevType = 'attr'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '%': {\n\t\t\t\tconst { propPath, value } = parseNodeProps(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].p) parsingInfo.currentNode[0].p = []\n\t\t\t\tparsingInfo.currentNode[0].p.push([propPath, value])\n\t\t\t\tparsingInfo.prevType = 'prop'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '@': {\n\t\t\t\tconst { name, value } = parseEvent(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].e) parsingInfo.currentNode[0].e = []\n\t\t\t\tconst options = getEventOptions(name)\n\t\t\t\tconst [method, _value] = splitEvents(value)\n\t\t\t\toptions.m = method\n\t\t\t\tif (_value) options.v = _value\n\t\t\t\tparsingInfo.currentNode[0].e.push(options)\n\t\t\t\tparsingInfo.prevType = 'event'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '.': {\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '|': {\n\t\t\t\tif (parsingInfo.currentNode.length > 1) content = `\\n${content}`\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'multiline-text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '-': {\n\t\t\t\tif (reserved.indexOf(content) !== -1) throw new SyntaxError(getErrorMsg(`Reserved name '${content}' should not be used`, i))\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 0\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'node'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '+': {\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 1\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'list'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tparsingInfo.prevType = 'comment'\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst parseEft = (template) => {\n\tif (!template) throw new TypeError(getErrorMsg('Template required, but nothing given'))\n\tconst tplType = typeof template\n\tif (tplType !== 'string') throw new TypeError(getErrorMsg(`Expected a string, but got a(n) ${tplType}`))\n\tconst lines = template.split(/\\r?\\n/)\n\tconst ast = [{t: 0}]\n\tconst parsingInfo = {\n\t\tindentReg: null,\n\t\tprevDepth: 0,\n\t\toffset: null,\n\t\toffsetReg: null,\n\t\tprevType: 'comment',\n\t\tcurrentNode: ast,\n\t\ttopExists: false,\n\t}\n\tfor (let i = 0; i < lines.length; i++) parseLine({line: lines[i], ast, parsingInfo, i})\n\n\tif (ast.length <= 1) throw new SyntaxError(getErrorMsg('Nothing to be parsed', lines.length - 1))\n\tif (ast.length === 2 && Array.isArray(ast[1]) && Object.hasOwnProperty.call(ast[1][0], 't')) return ast[1]\n\treturn ast\n}\n\nexport default parseEft\n","const typeOf = (obj) => {\n\tif (Array.isArray(obj)) return 'array'\n\treturn typeof obj\n}\n\nexport default typeOf\n","const mixStr = (strs, ...exprs) => {\n\tlet string = ''\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tif (typeof exprs[i] === 'undefined') string += strs[i]\n\t\telse string += (strs[i] + exprs[i])\n\t}\n\treturn string + strs[strs.length - 1]\n}\n\nconst getVal = ({dataNode, _key}) => {\n\tconst data = dataNode[_key]\n\tif (typeof data === 'undefined') return ''\n\treturn data\n}\n\nconst mixVal = (strs, ...exprs) => {\n\tif (!strs) return getVal(exprs[0])\n\tconst template = [strs]\n\ttemplate.push(...exprs.map(getVal))\n\treturn mixStr(...template)\n}\n\nexport {mixStr, mixVal}\n","const proto = Array.prototype\n\nconst ARR = {\n\tcopy(arr) {\n\t\treturn proto.slice.call(arr, 0)\n\t},\n\tempty(arr) {\n\t\tarr.length = 0\n\t\treturn arr\n\t},\n\tequals(left, right) {\n\t\tif (!Array.isArray(right)) return false\n\t\tif (left === right) return true\n\t\tif (left.length !== right.length) return false\n\t\tfor (let i = 0, l = left.length; i < l; i++) {\n\t\t\tif (left[i] !== right[i]) return false\n\t\t}\n\t\treturn true\n\t},\n\tpop(arr) {\n\t\treturn proto.pop.call(arr)\n\t},\n\tpush(arr, ...items) {\n\t\treturn proto.push.apply(arr, items)\n\t},\n\tremove(arr, item) {\n\t\tconst index = proto.indexOf.call(arr, item)\n\t\tif (index > -1) {\n\t\t\tproto.splice.call(arr, index, 1)\n\t\t\treturn item\n\t\t}\n\t},\n\treverse(arr) {\n\t\treturn proto.reverse.call(arr)\n\t},\n\trightUnique(arr) {\n\t\tconst newArr = []\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tfor (let j = i + 1; j < arr.length; j++) if (arr[i] === arr[j]) j = i += 1\n\t\t\tnewArr.push(arr[i])\n\t\t}\n\t\treturn newArr\n\t},\n\tshift(arr) {\n\t\treturn proto.shift.call(arr)\n\t},\n\tslice(arr, index, length) {\n\t\treturn proto.slice.call(arr, index, length)\n\t},\n\tsort(arr, fn) {\n\t\treturn proto.sort.call(arr, fn)\n\t},\n\tsplice(arr, ...args) {\n\t\treturn proto.splice.apply(arr, args)\n\t},\n\tunshift(arr, ...items) {\n\t\treturn proto.unshift.apply(arr, items)\n\t}\n}\n\nif (typeof Set !== 'undefined' && Array.from) ARR.unique = arr => Array.from(new Set(arr))\nelse ARR.unique = ARR.rightUnique\n\nexport default ARR\n","import ARR from './utils/array-helper.js'\n\nconst modificationQueue = []\nconst domQueue = []\nconst userQueue = []\nlet count = 0\n\nconst queue = handlers => modificationQueue.push(...handlers)\nconst queueDom = handler => domQueue.push(handler)\nconst onNextRender = handler => userQueue.push(handler)\n\n/**\n * @returns {boolean} - Is render paused\n */\nconst isPaused = () => count > 0\n\n/**\n * Add 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @returns {number} - Render count down\n */\nconst inform = () => {\n\tcount += 1\n\treturn count\n}\n\nconst execModifications = () => {\n\tif (modificationQueue.length === 0) return\n\tconst renderQueue = ARR.unique(modificationQueue)\n\tARR.empty(modificationQueue)\n\tfor (let i of renderQueue) i()\n}\n\nconst execDomModifications = () => {\n\tif (domQueue.length === 0) return\n\tconst domRenderQueue = ARR.rightUnique(domQueue)\n\tARR.empty(domQueue)\n\tfor (let i of domRenderQueue) i()\n}\n\nconst execUserQueue = () => {\n\tif (userQueue.length === 0) return\n\tconst userFnQueue = ARR.unique(userQueue)\n\tARR.empty(userQueue)\n\tfor (let i of userFnQueue) i()\n}\n\n/**\n * Minus 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @param {boolean} immediate - Render immediately, will force countdown become 0\n * @returns {number} - Render count down\n */\nconst exec = (immediate) => {\n\tif (!immediate && (count -= 1) > 0) return count\n\tcount = 0\n\n\tif (modificationQueue.length > 0) execModifications()\n\n\tif (domQueue.length > 0) execDomModifications()\n\n\t// Execute user queue after DOM update\n\tif (userQueue.length > 0) setTimeout(execUserQueue, 0)\n\n\treturn count\n}\n\n/**\n * Run callback in a safe way, without worrying about unhandled errors may break rendering.\n * @param {Function} cb - Callback function to be executed safly\n * @returns {(void|Error)} - Error that happens when executing callback\n */\nconst bundle = (cb) => {\n\tinform()\n\ttry {\n\t\t// eslint-disable-next-line callback-return\n\t\texec(cb(inform, exec))\n\t} catch (e) {\n\t\texec()\n\t\treturn e\n\t}\n}\n\nexport { queue, queueDom, onNextRender, inform, exec, bundle, isPaused }\n","// Enough for ef's usage, so no need for a full polyfill\nconst legacyAssign = (ee, er) => {\n\tfor (let i in er) ee[i] = er[i]\n\treturn ee\n}\n\nconst assign = Object.assign || legacyAssign\n\nexport {assign, legacyAssign}\n","import {inform, exec} from './render-queue.js'\nimport {assign} from './utils/polyfills.js'\n\nconst resolveAllPath = ({_path, handlers, subscribers, innerData}) => {\n\tfor (let i of _path) {\n\t\tif (!handlers[i]) handlers[i] = {}\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tif (!innerData[i]) innerData[i] = {}\n\t\thandlers = handlers[i]\n\t\tsubscribers = subscribers[i]\n\t\tinnerData = innerData[i]\n\t}\n\treturn {\n\t\thandlerNode: handlers,\n\t\tsubscriberNode: subscribers,\n\t\tdataNode: innerData\n\t}\n}\n\n// Workaround for the third bug of buble:\n// https://github.com/bublejs/buble/issues/106\nconst defineNode = (key, obj) => {\n\tconst node = {}\n\tObject.defineProperty(obj, key, {\n\t\tget() {\n\t\t\treturn node\n\t\t},\n\t\tset(data) {\n\t\t\tinform()\n\t\t\tassign(node, data)\n\t\t\texec()\n\t\t},\n\t\tconfigurable: false,\n\t\tenumerable: true\n\t})\n\treturn node\n}\n\nconst resolveReactivePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (obj[i]) obj = obj[i]\n\t\telse obj = defineNode(i, obj)\n\t}\n\treturn obj\n}\n\nconst resolvePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (!obj[i]) obj[i] = {}\n\t\tobj = obj[i]\n\t}\n\treturn obj\n}\n\nconst resolve = ({_path, _key, data, handlers, subscribers, innerData}) => {\n\tconst parentNode = resolveReactivePath(_path, data)\n\tconst {handlerNode, subscriberNode, dataNode} = resolveAllPath({_path, handlers, subscribers, innerData})\n\tif (!handlerNode[_key]) handlerNode[_key] = []\n\tif (!subscriberNode[_key]) subscriberNode[_key] = []\n\t/* eslint no-undefined: \"off\" */\n\tif (!Object.prototype.hasOwnProperty.call(dataNode, _key)) dataNode[_key] = undefined\n\treturn {parentNode, handlerNode: handlerNode[_key], subscriberNode: subscriberNode[_key], dataNode}\n}\n\nconst resolveSubscriber = (_path, subscribers) => {\n\tconst pathArr = _path.split('.')\n\tconst key = pathArr.pop()\n\tfor (let i of pathArr) {\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tsubscribers = subscribers[i]\n\t}\n\treturn subscribers[key]\n}\n\nexport {resolveReactivePath, resolvePath, resolve, resolveSubscriber}\n","/* eslint-disable no-self-compare */\nconst isnan = obj => obj !== obj\n\nexport default isnan\n","import {resolve} from './resolver.js'\nimport {inform, exec, queue} from './render-queue.js'\nimport ARR from './utils/array-helper.js'\nimport isnan from './utils/isnan.js'\nimport dbg from './utils/debug.js'\n\nconst initDataNode = ({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key}) => {\n\tlet subscriberExecuting = false\n\tObject.defineProperty(parentNode, _key, {\n\t\tget() {\n\t\t\treturn dataNode[_key]\n\t\t},\n\t\tset(value) {\n\t\t\tif (subscriberExecuting) return\n\t\t\t// Comparing NaN is like eating a cake and suddenly encounter a grain of sand\n\t\t\tif (dataNode[_key] === value || (isnan(dataNode[_key]) && isnan(value))) return\n\t\t\tdataNode[_key] = value\n\t\t\tinform()\n\t\t\tqueue(handlerNode)\n\t\t\texec()\n\t\t\tif (subscriberNode.length > 0) {\n\t\t\t\tsubscriberExecuting = true\n\t\t\t\tinform()\n\t\t\t\ttry {\n\t\t\t\t\tfor (const subscriber of subscriberNode) subscriber({state: ctx.state, value})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdbg.error('Error caught when executing subscribers:\\n', e)\n\t\t\t\t}\n\t\t\t\texec()\n\t\t\t\tsubscriberExecuting = false\n\t\t\t}\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst initBinding = ({bind, ctx, handlers, subscribers, innerData}) => {\n\tconst _path = ARR.copy(bind[0])\n\tconst _key = _path.pop()\n\tconst {parentNode, handlerNode, subscriberNode, dataNode} = resolve({\n\t\t_path,\n\t\t_key,\n\t\tdata: ctx.data,\n\t\thandlers,\n\t\tsubscribers,\n\t\tinnerData\n\t})\n\n\t// Initlize data binding node if not exist\n\tif (!Object.prototype.hasOwnProperty.call(parentNode, _key)) initDataNode({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key})\n\t// Update default value\n\t// bind[1] is the default value for this node\n\tif (bind.length > 1) parentNode[_key] = bind[1]\n\n\treturn {dataNode, parentNode, handlerNode, subscriberNode, _key}\n}\n\nexport default initBinding\n","const isInstance = (er, ee) => er.constructor === ee\n\nexport default isInstance\n","import ARR from './array-helper.js'\n\n// https://github.com/bublejs/buble/issues/197\nconst enumerableFalse = (classObj, keys) => {\n\tfor (let i of keys) Object.defineProperty(classObj.prototype, i, {enumerable: false})\n\treturn classObj\n}\n\n// https://github.com/bublejs/buble/issues/131\nconst prepareArgs = (self, node) => {\n\tconst args = ARR.copy(self)\n\tARR.unshift(args, node)\n\treturn args\n}\n\nexport {enumerableFalse, prepareArgs}\n","// Wrap console functions for `[EF]` perfix\nconst strTpl = '[EF] %s'\nconst dbg = {\n\tlog: console.log.bind(console, strTpl),\n\tinfo: console.info.bind(console, strTpl),\n\twarn: console.warn.bind(console, strTpl),\n\terror: console.error.bind(console, strTpl)\n}\n\nexport default dbg\n","import dbg from './debug.js'\n\nconst isBrowser = typeof document !== 'undefined' && typeof Node !== 'undefined'\n\nif (process.env.NODE_ENV !== 'production') {\n\tif (isBrowser) dbg.info('Running in browser mode.')\n\telse dbg.info('Running in non-browser mode, please be sure to set a DOM simulation using `setDOMImpl`.')\n}\n\nexport default isBrowser\n","const shared = {}\n\nexport default shared\n","// import ARR from './array-helper.js'\nimport isInstance from './fast-instance-of.js'\nimport {assign} from './polyfills.js'\nimport {prepareArgs} from './buble-fix.js'\nimport dbg from './debug.js'\nimport isBrowser from './is-browser.js'\nimport {inform, exec} from '../render-queue.js'\n\nimport shared from './global-shared.js'\n\n// Will require a weakmap polyfill for IE10 and below\nconst mountingPointStore = new WeakMap()\n\nconst DOM = {}\n\nconst EFFragment = class extends Array {\n\tappendTo(node) {\n\t\tDOM.append.apply(null, prepareArgs(this, node))\n\t}\n\t// insertBeforeTo(node) {\n\t// \tconst args = ARR.copy(this)\n\t// \tARR.unshift(args, node)\n\t// \tDOM.before.apply(null, prepareArgs(this, node))\n\t// }\n\t// insertAfterTo(node) {\n\t// \tconst args = ARR.copy(this)\n\t// \tARR.unshift(args, node)\n\t// \tDOM.after.apply(null, prepareArgs(this, node))\n\t// }\n\tremove() {\n\t\tfor (let i of this) DOM.remove(i)\n\t}\n}\n\nDOM.before = (node, ...nodes) => {\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse DOM.Node.prototype.appendChild.call(tempFragment, i)\n\t}\n\tDOM.Node.prototype.insertBefore.call(node.parentNode, tempFragment, node)\n\texec()\n}\n\nDOM.after = (node, ...nodes) => {\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse DOM.Node.prototype.appendChild.call(tempFragment, i)\n\t}\n\tif (node.nextSibling) DOM.Node.prototype.insertBefore.call(node.parentNode, tempFragment, node.nextSibling)\n\telse DOM.Node.prototype.appendChild.call(node.parentNode, tempFragment)\n\texec()\n}\n\nconst handleMountingPoint = (mountingPoint, tempFragment) => {\n\tconst {node} = mountingPoint\n\tif (!node) return\n\tif (Array.isArray(node) && node.clear) {\n\t\tfor (let j of node) {\n\t\t\tconst {element, placeholder} = j.$ctx.nodeInfo\n\t\t\tDOM.append(tempFragment, element, placeholder)\n\t\t}\n\t} else {\n\t\tconst {element, placeholder} = node.$ctx.nodeInfo\n\t\tDOM.append(tempFragment, element, placeholder)\n\t}\n}\n\nDOM.append = (node, ...nodes) => {\n\t// Handle fragment\n\tif (isInstance(node, EFFragment)) return node.push(...nodes)\n\t// Handle EFComponent\n\tif (node instanceof shared.EFBaseComponent) {\n\t\tif (!(Array.isArray(node.children) && node.children.clear)) {\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn(node, 'has no `children` list mount point! Child nodes are all ignored!')\n\t\t\treturn\n\t\t}\n\n\t\tinform()\n\t\tfor (let i of nodes) {\n\t\t\ti = new shared.toEFComponent(i)\n\t\t\tnode.children.push(i)\n\t\t}\n\t\texec()\n\n\t\treturn\n\t}\n\n\tif ([1,9,11].indexOf(node.nodeType) === -1) return\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tfor (let i of nodes) {\n\t\tif (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse if (i instanceof DOM.Node) {\n\t\t\tDOM.Node.prototype.appendChild.call(tempFragment, i)\n\t\t\tconst mountingPoint = mountingPointStore.get(i)\n\t\t\tif (mountingPoint) handleMountingPoint(mountingPoint, tempFragment)\n\t\t} else if (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t}\n\t}\n\tDOM.Node.prototype.appendChild.call(node, tempFragment)\n}\n\nDOM.remove = (node) => {\n\tif (isInstance(node, EFFragment)) node.remove()\n\telse if (node instanceof shared.EFBaseComponent) node.$umount()\n\telse DOM.Node.prototype.removeChild.call(node.parentNode, node)\n}\n\n// addClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.add(...classes)\n// },\n\n// removeClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.remove(...classes)\n// },\n\n// toggleClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tconst classArr = node.className.split(' ')\n// \tfor (let i of classes) {\n// \t\tconst classIndex = classArr.indexOf(i)\n// \t\tif (classIndex > -1) {\n// \t\t\tclassArr.splice(classIndex, 1)\n// \t\t} else {\n// \t\t\tclassArr.push(i)\n// \t\t}\n// \t}\n// \tnode.className = classArr.join(' ').trim()\n// },\n\n// replaceWith(node, newNode) {\n// \tconst parent = node.parentNode\n// \tif (parent) DOM.Node.prototype.replaceChild.call(parent, newNode, node)\n// },\n\n// swap(node, newNode) {\n// \tconst nodeParent = node.parentNode\n// \tconst newNodeParent = newNode.parentNode\n// \tconst nodeSibling = node.nextSibling\n// \tconst newNodeSibling = newNode.nextSibling\n// \tif (nodeParent && newNodeParent) {\n// \t\tDOM.Node.prototype.insertBefore.call(nodeParent, newNode, nodeSibling)\n// \t\tDOM.Node.prototype.insertBefore.call(newNodeParent, node, newNodeSibling)\n// \t}\n// },\n\n// prepend(node, ...nodes) {\n// \tif ([1,9,11].indexOf(node.nodeType) === -1) {\n// \t\treturn\n// \t}\n// \tconst tempFragment = DOM.document.createDocumentFragment()\n// \tnodes.reverse()\n// \tfor (let i of nodes) {\n// \t\tDOM.Node.prototype.appendChild.call(tempFragment, i)\n// \t}\n// \tif (node.firstChild) {\n// \t\tDOM.Node.prototype.insertBefore.call(node, tempFragment, node.firstChild)\n// \t} else {\n// \t\tDOM.Node.prototype.appendChild.call(node, tempFragment)\n// \t}\n// },\n\n// appendTo(node, newNode) {\n// \tDOM.Node.prototype.appendChild.call(newNode, node)\n// },\n\n// prependTo(node, newNode) {\n// \tif (newNode.firstChild) {\n// \t\tDOM.Node.prototype.insertBefore.call(newNode, node, node.firstChild)\n// \t} else {\n// \t\tDOM.Node.prototype.appendChild.call(newNode, node)\n// \t}\n// },\n\n// empty(node) {\n// \tnode.innerHTML = ''\n// },\n\nconst setDOMImpl = sim => assign(DOM, sim)\n\nif (isBrowser) setDOMImpl({Node, document})\n\nexport {DOM, EFFragment, mountingPointStore, setDOMImpl}\n","import {DOM} from './dom-helper.js'\n\n/**\n * @typedef {{bubbles: boolean, cancelable: boolean}} EFEventOptions\n */\n\n/* Get new events that works in all target browsers\n * though a little bit old-fashioned\n */\nconst getEvent = (name, {bubbles, cancelable} = {\n\tbubbles: false,\n\tcancelable: false\n}) => {\n\tconst event = DOM.document.createEvent('CustomEvent')\n\tevent.initEvent(name, bubbles, cancelable)\n\treturn event\n}\n\nexport default getEvent\n","import initBinding from './binding.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {resolvePath} from './resolver.js'\nimport ARR from './utils/array-helper.js'\nimport {DOM, EFFragment} from './utils/dom-helper.js'\nimport getEvent from './utils/event-helper.js'\nimport {mixVal} from './utils/literals-mix.js'\nimport dbg from './utils/debug.js'\n\nconst typeValid = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\n// SVG/MathML tags w/ xlink attributes require specific namespace to work properly\nconst svgNS = 'http://www.w3.org/2000/svg'\nconst mathNS = 'http://www.w3.org/1998/Math/MathML'\nconst xlinkNS = 'http://www.w3.org/1999/xlink'\nconst createByTag = ({tagName, tagContent, attrs, svg}) => {\n\tconst tagType = typeof tagContent\n\n\tif (tagType === 'string') {\n\t\t// Then SVG\n\t\tif (svg) return DOM.document.createElementNS(svgNS, tagContent)\n\t\t// Then MathML\n\t\tif (tagContent.toLowerCase() === 'math') return DOM.document.createElementNS(mathNS, tagContent)\n\t\t// Then custom basic elements\n\t\tif (tagName === tagContent && attrs && attrs.is && typeof attrs.is === 'string') return DOM.document.createElement(tagContent, {is: attrs.is})\n\t\t// Then basic HTMLElements\n\t\treturn DOM.document.createElement(tagContent)\n\t}\n\n\t// Then custom component or class based custom component\n\tif (tagType === 'function') return new tagContent()\n\n\t// Then overriden basic element\n\treturn DOM.document.createElement(tagContent.tag || tagName, {is: tagContent.is})\n}\n\nconst getElement = ({tagName, tagContent, attrs, ref, refs, svg}) => {\n\tconst element = createByTag({tagName, tagContent, attrs, svg})\n\tif (ref) Object.defineProperty(refs, ref, {\n\t\tvalue: element,\n\t\tenumerable: true\n\t})\n\treturn element\n}\n\nconst regTmpl = ({val, ctx, handlers, subscribers, innerData, handler}) => {\n\tif (Array.isArray(val)) {\n\t\tconst [strs, ...exprs] = val\n\t\tconst tmpl = [strs]\n\n\t\tconst _handler = () => handler(mixVal(...tmpl))\n\n\t\ttmpl.push(...exprs.map((item) => {\n\t\t\tconst {dataNode, handlerNode, _key} = initBinding({bind: item, ctx, handlers, subscribers, innerData})\n\t\t\thandlerNode.push(_handler)\n\t\t\treturn {dataNode, _key}\n\t\t}))\n\n\t\treturn _handler\n\t}\n\treturn () => val\n}\n\nconst addValListener = ({ctx, handlers, subscribers, innerData, element, key, expr, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\tconst dispatch = custom && '$dispatch' || 'dispatchEvent'\n\tconst {parentNode, _key} = initBinding({bind: expr, ctx, handlers, subscribers, innerData})\n\tconst _update = () => {\n\t\tinform()\n\t\tif (custom) parentNode[_key] = element.$data.value\n\t\telse parentNode[_key] = element.value\n\t\texec()\n\t}\n\tif (key === 'value') {\n\t\t// Listen to input, keyup and change events in order to work in most browsers.\n\t\telement[addListener]('input', _update, true)\n\t\telement[addListener]('keyup', _update, true)\n\t\telement[addListener]('change', _update, true)\n\t\t// // Remove keyup and change listener if browser supports input event correctly\n\t\t// const removeListener = () => {\n\t\t// \telement.removeEventListener('input', removeListener, true)\n\t\t// \telement.removeEventListener('keyup', _update, true)\n\t\t// \telement.removeEventListener('change', _update, true)\n\t\t// }\n\t\t// element[addListener]('input', removeListener, true)\n\t} else {\n\t\telement[addListener]('change', () => {\n\t\t\t// Trigger change to the element it-self\n\t\t\telement[dispatch](getEvent('ef-change-event'), {bubbles: true, canceoable: false})\n\t\t\tif (element.tagName === 'INPUT' && element.type === 'radio' && element.name !== '') {\n\t\t\t\t// Trigger change to the the same named radios\n\t\t\t\tconst radios = DOM.document.querySelectorAll(`input[name=${element.name}][type=radio]`)\n\t\t\t\tif (radios) {\n\t\t\t\t\tconst selected = ARR.copy(radios)\n\t\t\t\t\tARR.remove(selected, element)\n\n\t\t\t\t\t/* Event triggering could cause unwanted render triggers\n\t\t\t\t\t * no better ways came up at the moment\n\t\t\t\t\t */\n\t\t\t\t\tfor (let i of selected) i.dispatchEvent(getEvent('ef-change-event'))\n\t\t\t\t}\n\t\t\t}\n\t\t}, true)\n\t\t// Use custom event to avoid loops and conflicts\n\t\telement[addListener]('ef-change-event', () => {\n\t\t\tinform()\n\t\t\tif (custom) parentNode[_key] = element.$data.checked\n\t\t\telse parentNode[_key] = element.checked\n\t\t\texec()\n\t\t})\n\t}\n}\n\nconst getAttrHandler = (element, key, custom) => {\n\t// Pass directly to custom component\n\tif (custom) return (val) => {\n\t\telement[key] = val\n\t}\n\n\t// Beautify class name\n\tif (key === 'class') return (val) => {\n\t\tval = `${val}`.replace(/\\s+/g, ' ').trim()\n\t\t// Remove attribute when value is empty\n\t\tif (!val) return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n\n\t// Handle xlink namespace\n\tif (key.indexOf('xlink:') === 0) return (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttributeNS(xlinkNS, key)\n\t\telement.setAttributeNS(xlinkNS, key, val)\n\t}\n\n\treturn (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n}\n\nconst addAttr = ({element, attr, key, ctx, handlers, subscribers, innerData, custom}) => {\n\tif (typeValid(attr)) {\n\t\tif (custom) {\n\t\t\tif (attr === '') element[key] = true\n\t\t\telse element[key] = attr\n\t\t\treturn\n\t\t}\n\t\t// Handle xlink namespace\n\t\tif (key.indexOf('xlink:') === 0) return element.setAttributeNS(xlinkNS, key, attr)\n\t\treturn element.setAttribute(key, attr)\n\t}\n\n\tconst handler = getAttrHandler(element, key, custom)\n\tqueue([regTmpl({val: attr, ctx, handlers, subscribers, innerData, handler})])\n}\n\nconst addProp = ({element, propPath, value, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst keyPath = ARR.copy(propPath)\n\tconst lastKey = keyPath.pop()\n\tif (custom) keyPath.unshift('$data')\n\tconst lastNode = resolvePath(keyPath, element)\n\tif (typeValid(value)) lastNode[lastKey] = value\n\telse {\n\t\tconst handler = (val) => {\n\t\t\tlastNode[lastKey] = val\n\t\t}\n\t\tconst _handler = regTmpl({val: value, ctx, handlers, subscribers, innerData, handler})\n\t\tif (propPath.length === 1 && ((lastKey === 'value' ||\n\t\t\tlastKey === 'checked')) &&\n\t\t\t!value[0]) addValListener({ctx, handlers, subscribers, innerData, element, key: lastKey, expr: value[1], custom})\n\t\tqueue([_handler])\n\t}\n}\n\n\nconst rawHandler = val => val\n\nconst addEvent = ({element, event, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\n\t/*\n\t *  l: listener                 : string\n\t *  m: method                   : string\n\t *  s: stopPropagation          : number/undefined\n\t *  i: stopImmediatePropagation : number/undefined\n\t *  p: preventDefault           : number/undefined\n\t *  h: shiftKey                 : number/undefined\n\t *  a: altKey                   : number/undefined\n\t *  c: ctrlKey                  : number/undefined\n\t *  t: metaKey                  : number/undefined\n\t *  u: capture                  : number/undefined\n\t *  k: keyCodes                 : array/undefined\n\t *  v: value                    : string/array/undefined\n\t */\n\tconst {l, m, s, i, p, h, a, c, t, u, k, v} = event\n\tconst _handler = regTmpl({val: v, ctx, handlers, subscribers, innerData, handler: rawHandler})\n\n\telement[addListener](l, (e) => {\n\t\tif (!!h !== !!e.shiftKey ||\n\t\t\t!!a !== !!e.altKey ||\n\t\t\t!!c !== !!e.ctrlKey ||\n\t\t\t!!t !== !!e.metaKey ||\n\t\t\t(k && k.indexOf(e.which) === -1)) return\n\t\tif (s) e.stopPropagation()\n\t\tif (i) e.stopImmediatePropagation()\n\t\tif (p) e.preventDefault()\n\t\tif (ctx.methods[m]) ctx.methods[m]({e, value: _handler(), state: ctx.state})\n\t\telse if (process.env.NODE_ENV !== 'production') dbg.warn(`Method named '${m}' not found! Value been passed is:`, _handler())\n\t}, !!u)\n}\n\nconst createElement = ({info, ctx, innerData, refs, handlers, subscribers, svg, fragment, custom}) => {\n\tif (fragment) return new EFFragment()\n\n\t/*\n\t *  t: tag       : class | string | int, 0 means fragment\n\t *  a: attr      : object\n\t *  p: prop      : object\n\t *  e: event     : array\n\t *  r: reference : string\n\t */\n\tconst {t, a, p, e, r} = info\n\tconst tagName = t\n\tconst tagContent = ctx.scope[t] || t\n\tconst element = getElement({tagName, tagContent, attrs: a, ref: r, refs, svg})\n\tif (a) for (let key in a) addAttr({element, custom, attr: a[key], key, ctx, handlers, subscribers, innerData})\n\tif (p) for (let [propPath, value] of p) addProp({element, custom, value, propPath, ctx, handlers, subscribers, innerData})\n\tif (e) for (let event of e) addEvent({element, custom, event, ctx, handlers, subscribers, innerData})\n\n\treturn element\n}\n\nexport default createElement\n","import createElement from './element-creator.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {DOM, mountingPointStore} from './utils/dom-helper.js'\nimport defineArr from './utils/dom-arr-helper.js'\nimport ARR from './utils/array-helper.js'\nimport typeOf from './utils/type-of.js'\nimport initBinding from './binding.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst nullComponent = Object.create(null)\n\nconst checkDestroyed = (state) => {\n\tif (!state.$ctx) throw new Error('[EF] This component has been destroyed!')\n}\n\nconst bindTextNode = ({node, ctx, handlers, subscribers, innerData, element}) => {\n\t// Data binding text node\n\tconst textNode = DOM.document.createTextNode('')\n\tconst { dataNode, handlerNode, _key } = initBinding({bind: node, ctx, handlers, subscribers, innerData})\n\tconst handler = () => {\n\t\tconst value = dataNode[_key]\n\t\tif (typeof value === 'undefined') {\n\t\t\ttextNode.textContent = ''\n\t\t\treturn\n\t\t}\n\t\ttextNode.textContent = value\n\t}\n\thandlerNode.push(handler)\n\tqueue([handler])\n\n\t// Append element to the component\n\tDOM.append(element, textNode)\n}\n\nconst updateMountingNode = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst child = children[key]\n\tconst {anchor, node} = child\n\tif (node === value) return\n\n\tvalue = shared.toEFComponent(value)\n\n\tinform()\n\t// Update component\n\tif (node) {\n\t\tif (value === nullComponent) value = null\n\t\telse node.$umount()\n\t}\n\t// Update stored value\n\tchild.node = value\n\tif (value) value.$mount({target: anchor, parent: ctx.state, option: mountOptions.BEFORE, key})\n\texec()\n}\n\nconst updateMountingList = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst {anchor, node} = children[key]\n\tif (ARR.equals(node, value)) return\n\tif (value) value = ARR.copy(value)\n\telse value = []\n\tconst fragment = DOM.document.createDocumentFragment()\n\t// Update components\n\tinform()\n\tif (node) {\n\t\tnode.clear()\n\t\tfor (let item of value) {\n\t\t\titem = shared.toEFComponent(item)\n\n\t\t\tif (item.$ctx.nodeInfo.parent) item.$umount()\n\t\t\tDOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t\t}\n\t} else for (let item of value) DOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t// Update stored value\n\tnode.length = 0\n\tARR.push(node, ...value)\n\t// Append to current component\n\tDOM.after(anchor, fragment)\n\texec()\n}\n\nconst mountingPointUpdaters = [\n\tupdateMountingNode,\n\tupdateMountingList\n]\n\nconst applyMountingPoint = (type, key, tpl) => {\n\tObject.defineProperty(tpl.prototype, key, {\n\t\tget() {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\treturn this.$ctx.children[key].node\n\t\t},\n\t\tset(value) {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\tconst ctx = this.$ctx\n\t\t\tmountingPointUpdaters[type]({ctx, key, value})\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst bindMountingNode = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {anchor}\n\tif (isFragment) {\n\t\tDOM.append(ctx.safeZone, anchor)\n\t\tmountingPointStore.set(anchor, children[key])\n\t}\n}\n\nconst bindMountingList = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {\n\t\tnode: defineArr([], {ctx, key, anchor}),\n\t\tanchor\n\t}\n\tif (isFragment) {\n\t\tDOM.append(ctx.safeZone, anchor)\n\t\tmountingPointStore.set(anchor, children[key])\n\t}\n}\n\n// Walk through the AST to perform proper actions\nconst resolveAST = ({node, nodeType, element, ctx, innerData, refs, handlers, subscribers, svg, create}) => {\n\tif (node instanceof DOM.Node) {\n\t\tDOM.append(element, node)\n\t\treturn\n\t}\n\tswitch (nodeType) {\n\t\t// Static text node\n\t\tcase 'string': {\n\t\t\tDOM.append(element, DOM.document.createTextNode(node))\n\t\t\tbreak\n\t\t}\n\t\t// Child element or a dynamic text node\n\t\tcase 'array': {\n\t\t\t// Recursive call for child element\n\t\t\tif (typeOf(node[0]) === 'object') DOM.append(element, create({node, ctx, innerData, refs, handlers, subscribers, svg}))\n\t\t\t// Dynamic text node\n\t\t\telse bindTextNode({node, ctx, handlers, subscribers, innerData, element})\n\t\t\tbreak\n\t\t}\n\t\t// Mounting points\n\t\tcase 'object': {\n\t\t\tconst anchor = DOM.document.createTextNode('')\n\t\t\t// Single node mounting point\n\t\t\tif (node.t === 0) bindMountingNode({ctx, key: node.n, anchor})\n\t\t\t// Multi node mounting point\n\t\t\telse bindMountingList({ctx, key: node.n, anchor})\n\t\t\t// Append anchor\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, DOM.document.createComment(`EF MOUNTING POINT '${node.n}' START`))\n\t\t\tDOM.append(element, anchor)\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, DOM.document.createComment(`EF MOUNTING POINT '${node.n}' END`))\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t}\n}\n\n// Create elements based on description from AST\nconst create = ({node, ctx, innerData, refs, handlers, subscribers, svg}) => {\n\tconst [info, ...childNodes] = node\n\tconst fragment = info.t === 0\n\tconst custom = Object.isPrototypeOf.call(shared.EFBaseComponent, ctx.scope[info.t] || info.t)\n\t// Enter SVG mode\n\tif (!fragment && !svg && !custom && info.t.toLowerCase() === 'svg') svg = true\n\t// First create an element according to the description\n\tconst element = createElement({info, ctx, innerData, refs, handlers, subscribers, svg, fragment, custom})\n\tif (fragment && process.env.NODE_ENV !== 'production') element.push(DOM.document.createComment('EF FRAGMENT START'))\n\n\t// Leave SVG mode if tag is `foreignObject`\n\tif (svg && info.t.toLowerCase() === 'foreignobject') svg = false\n\n\t// Append child nodes\n\tfor (let node of childNodes) {\n\t\tif (node instanceof shared.EFBaseComponent) node.$mount({target: element})\n\t\telse resolveAST({node, nodeType: typeOf(node), element, ctx, innerData, refs, handlers, subscribers, svg, create})\n\t}\n\tif (fragment && process.env.NODE_ENV !== 'production') element.push(DOM.document.createComment('EF FRAGMENT END'))\n\n\treturn element\n}\n\nexport {create, nullComponent, checkDestroyed, applyMountingPoint}\n","import {DOM} from './dom-helper.js'\nimport ARR from './array-helper.js'\nimport {inform, exec} from '../render-queue.js'\nimport shared from './global-shared.js'\n\nconst DOMARR = {\n\tempty() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$destroy()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tclear() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$umount()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tpop() {\n\t\tif (this.length === 0) return\n\t\tconst poped = ARR.pop(this)\n\t\tpoped.$umount()\n\t\treturn poped\n\t},\n\tpush({ctx, key, anchor}, ...items) {\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tif (this.length === 0) DOM.after(anchor, ...elements)\n\t\telse DOM.after(this[this.length - 1].$ctx.nodeInfo.placeholder, ...elements)\n\t\texec()\n\t\treturn ARR.push(this, ...items)\n\t},\n\tremove(item) {\n\t\tif (this.indexOf(item) === -1) return\n\t\titem.$umount()\n\t\treturn item\n\t},\n\treverse({ctx, key, anchor}) {\n\t\tif (this.length === 0) return this\n\t\tconst tempArr = ARR.copy(this)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i = tempArr.length - 1; i >= 0; i--) {\n\t\t\ttempArr[i].$umount()\n\t\t\tARR.push(elements, tempArr[i].$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...ARR.reverse(tempArr))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tshift() {\n\t\tif (this.length === 0) return\n\t\tconst shifted = ARR.shift(this)\n\t\tshifted.$umount()\n\t\treturn shifted\n\t},\n\tsort({ctx, key, anchor}, fn) {\n\t\tif (this.length === 0) return this\n\t\tconst sorted = ARR.copy(ARR.sort(this, fn))\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of sorted) {\n\t\t\ti.$umount()\n\t\t\tARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...sorted)\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tsplice(...args) {\n\t\tif (this.length === 0) return this\n\t\tconst spliced = ARR.splice(ARR.copy(this), ...args)\n\t\tinform()\n\t\tfor (let i of spliced) i.$umount()\n\t\texec()\n\t\treturn spliced\n\t},\n\tunshift({ctx, key, anchor}, ...items) {\n\t\tif (this.length === 0) return this.push(...items).length\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn ARR.unshift(this, ...items)\n\t}\n}\n\nconst defineArr = (arr, info) => {\n\tObject.defineProperties(arr, {\n\t\tempty: {value: DOMARR.empty},\n\t\tclear: {value: DOMARR.clear},\n\t\tpop: {value: DOMARR.pop},\n\t\tpush: {value: DOMARR.push.bind(arr, info)},\n\t\tremove: {value: DOMARR.remove},\n\t\treverse: {value: DOMARR.reverse.bind(arr, info)},\n\t\tshift: {value: DOMARR.shift},\n\t\tsort: {value: DOMARR.sort.bind(arr, info)},\n\t\tsplice: {value: DOMARR.splice},\n\t\tunshift: {value: DOMARR.unshift.bind(arr, info)}\n\t})\n\treturn arr\n}\n\nexport default defineArr\n","const getGetter = ({base, key}, {checkTrue, get, set}) => {\n\tif (get) {\n\t\tif (!set) throw new Error('[EF] Setter must be defined when getter exists')\n\t\treturn get\n\t}\n\n\tif (checkTrue) return function() {\n\t\treturn checkTrue(base(this)[key], this)\n\t}\n\n\treturn function() {\n\t\treturn base(this)[key]\n\t}\n}\n\nconst getSetter = ({base, key}, {checkTrue, trueVal, falseVal, get, set}) => {\n\tif (set) {\n\t\tif (!get) throw new Error('[EF] Getter must be defined when setter exists')\n\t\treturn set\n\t}\n\n\tif (checkTrue) return function(val) {\n\t\tconst baseNode = base(this)\n\t\tconst _trueVal = trueVal\n\t\tconst _falseVal = falseVal\n\n\t\tif (typeof trueVal !== 'function') trueVal = () => _trueVal\n\t\tif (typeof falseVal !== 'function') falseVal = () => _falseVal\n\n\t\tif (val) baseNode[key] = trueVal(this)\n\t\telse baseNode[key] = falseVal(this)\n\t}\n\n\treturn function(val) {\n\t\tbase(this)[key] = val\n\t}\n}\n\nconst defaultRoot = state => state.$data\nconst getBase = (root) => {\n\tif (!root) return defaultRoot\n\tif (typeof root === 'function') return root\n\tif (typeof root === 'string') root = root.split('.')\n\treturn (base) => {\n\t\tfor (let key of root) base = base[key]\n\t\treturn base\n\t}\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n/**\n * Definition of an attribute mapping\n * @typedef {Object} AttrDef\n * @property {string=} key - key to be accessed on base, default to `attr`\n * @property {Function=} base - a function that returns the base of the key, default returns $data\n * @property {bool=} checkTrue - a function returns true or false based on input value\n * @property {*=} trueVal - value when true, only used when checkTrue is set\n * @property {*=} falseVal - value when false, only used when checkTrue is set\n * @property {Function=} get - getter, will ignore all other settings except set\n * @property {Function=} set - setter, will ignore all other settings except get\n */\n\n/**\n * Data to attribute mapping helper\n * @template {EFBaseClass} T\n * @param {T} tpl - Component class to be mapped\n * @param {Object.<string,AttrDef>} attrMap - Attributes to be mapped\n * @returns {T} - Mapped component class\n */\nconst mapAttrs = (tpl, attrMap) => {\n\tfor (let attr in attrMap) {\n\t\tconst options = attrMap[attr]\n\n\t\tconst base = getBase(options.base)\n\t\tconst key = options.key || attr\n\n\t\tconst basicProperty = {base, key}\n\n\t\tconst get = getGetter(basicProperty, options)\n\t\tconst set = getSetter(basicProperty, options)\n\n\t\tObject.defineProperty(tpl.prototype, attr, {\n\t\t\tget,\n\t\t\tset,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false\n\t\t})\n\t}\n\n\treturn tpl\n}\n\nexport default mapAttrs\n","/**\n * @typedef {string} EFMountOption\n * @typedef {{BEFORE: EFMountOption, AFTER: EFMountOption, APPEND: EFMountOption, REPLACE: EFMountOption}} EFMountConfig\n */\n\n/**\n * @type {EFMountConfig}\n */\nconst mountOptions = {\n\tBEFORE: 'before',\n\tAFTER: 'after',\n\tAPPEND: 'append',\n\tREPLACE: 'replace'\n}\n\nexport default mountOptions\n","import {create, nullComponent, checkDestroyed} from './creator.js'\nimport initBinding from './binding.js'\nimport {queueDom, inform, exec} from './render-queue.js'\nimport {resolveSubscriber} from './resolver.js'\nimport mapAttrs from './map-attrs.js'\nimport {DOM, EFFragment, mountingPointStore} from './utils/dom-helper.js'\nimport ARR from './utils/array-helper.js'\nimport {assign, legacyAssign} from './utils/polyfills.js'\nimport isInstance from './utils/fast-instance-of.js'\nimport typeOf from './utils/type-of.js'\nimport {enumerableFalse} from './utils/buble-fix.js'\nimport dbg from './utils/debug.js'\nimport getEvent from './utils/event-helper.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst unsubscribe = (pathStr, fn, subscribers) => {\n\tconst subscriberNode = resolveSubscriber(pathStr, subscribers)\n\tARR.remove(subscriberNode, fn)\n}\n\n/**\n * @typedef {Array} EFAST\n * @typedef {Object.<string,EFBaseComponent>} EFTemplateScope\n */\n\n/**\n * @typedef {Object} EFSubscriberHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been subscribed\n */\n\n/**\n * @event Event\n */\n\n/**\n * @typedef {Object} EFEventHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been passed to the event handler\n * @property {Event} event - Event object that has been triggered\n */\n\n/**\n * @typedef {Function} EFSubscriberHandlerMethod\n * @param {EFSubscriberHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * @typedef {Function} EFEventHandlerMethod\n * @param {EFEventHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * The very basic ef component\n * @class EFBaseComponent\n * @param {EFAST} ast - ast for the component\n * @param {EFTemplateScope} scope - scope which contains custom components\n * @private {Object} $ctx - Inner component data, DO NOT TOUCH\n * @property {Object} $data - Data on component\n * @property {Object.<string,EFEventHandlerMethod>} $methods - Methods on component\n * @property {Object.<string,(EFBaseComponent|Node)>} $refs - References on component\n */\nconst EFBaseComponent = class {\n\n\t/**\n\t * Create an EFBaseComponent with ef AST\n\t * @param {EFAST} ast - ast for the component\n\t * @param {EFTemplateScope=} scope - scope which contains custom components\n\t */\n\tconstructor(ast, scope = {}) {\n\t\tconst children = {}\n\t\tconst refs = {}\n\t\tconst data = {}\n\t\tconst innerData = {}\n\t\tconst methods = {}\n\t\tconst handlers = {}\n\t\tconst subscribers = {}\n\t\tconst nodeInfo = {\n\t\t\tplaceholder: null,\n\t\t\treplace: [],\n\t\t\tparent: null,\n\t\t\tkey: null\n\t\t}\n\n\t\t/* Detatched components will be put in the safe zone.\n\t\t * Split safe zone to each component in order to make\n\t\t * the component memory recycleable when lost reference\n\t\t */\n\t\tconst safeZone = DOM.document.createDocumentFragment()\n\n\t\tif (process.env.NODE_ENV === 'production') nodeInfo.placeholder = DOM.document.createTextNode('')\n\t\telse nodeInfo.placeholder = DOM.document.createComment('EF COMPONENT PLACEHOLDER')\n\n\t\tconst mount = () => {\n\t\t\tif (nodeInfo.replace.length > 0) {\n\t\t\t\tfor (let i of nodeInfo.replace) DOM.remove(i)\n\t\t\t\tARR.empty(nodeInfo.replace)\n\t\t\t}\n\t\t\tDOM.before(nodeInfo.placeholder, nodeInfo.element)\n\t\t}\n\n\t\tconst ctx = {\n\t\t\tscope, mount, refs, data, innerData, methods,\n\t\t\thandlers, subscribers, nodeInfo, safeZone,\n\t\t\tchildren, state: this, isFragment: ast[0].t === 0\n\t\t}\n\n\t\tObject.defineProperty(this, '$ctx', {\n\t\t\tvalue: ctx,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true\n\t\t})\n\n\t\tinform()\n\n\t\tnodeInfo.element = create({node: ast, ctx, innerData, refs, handlers, subscribers, svg: false})\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\texec()\n\t}\n\n\tget $data() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.data\n\t}\n\n\tset $data(newData) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tassign(this.$ctx.data, newData)\n\t\texec()\n\t}\n\n\tget $methods() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.methods\n\t}\n\n\n\tset $methods(newMethods) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.methods = newMethods\n\t}\n\n\tget $refs() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.refs\n\t}\n\n\t/**\n\t * @typedef {import('../mount-options.js').EFMountConfig} EFMountConfig\n\t */\n\n\t/**\n\t * Mount component to a specitic position\n\t * @param {EFMountConfig} config - Mount contigurations\n\t * @returns {number} - Render count down\n\t */\n\t$mount({target, option, parent, key}) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, mount } = this.$ctx\n\t\tif (typeof target === 'string') target = document.querySelector(target)\n\n\t\tinform()\n\t\tif (nodeInfo.parent) {\n\t\t\tthis.$umount()\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn('Component detached from previous mounting point.')\n\t\t}\n\n\t\tif (!parent) parent = target\n\t\tif (!key) key = '__DIRECTMOUNT__'\n\t\tnodeInfo.parent = parent\n\t\tnodeInfo.key = key\n\t\tqueueDom(mount)\n\n\t\tif (!target) {\n\t\t\texec()\n\t\t\treturn nodeInfo.placeholder\n\t\t}\n\n\t\tswitch (option) {\n\t\t\tcase mountOptions.BEFORE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.AFTER: {\n\t\t\t\tDOM.after(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.REPLACE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tnodeInfo.replace.push(target)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.APPEND:\n\t\t\tdefault: {\n\t\t\t\t// Parent is EFFragment should only happen when using jsx\n\t\t\t\tif (isInstance(parent, EFFragment)) DOM.append(target, nodeInfo.element)\n\t\t\t\telse DOM.append(target, nodeInfo.placeholder)\n\t\t\t}\n\t\t}\n\t\treturn exec()\n\t}\n\n\t/**\n\t * @returns {number} - Render count down\n\t */\n\t$umount() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, safeZone, mount } = this.$ctx\n\t\tconst { parent, key } = nodeInfo\n\t\tnodeInfo.parent = null\n\t\tnodeInfo.key = null\n\n\t\tinform()\n\t\tif (parent) {\n\t\t\tif (key !== '__DIRECTMOUNT__') {\n\t\t\t\tif (parent[key]) {\n\t\t\t\t\tif (Array.isArray(parent[key])) {\n\t\t\t\t\t\t// Remove self from parent list mounting point\n\t\t\t\t\t\tARR.remove(parent[key], this)\n\t\t\t\t\t} else parent[key] = nullComponent\n\t\t\t\t}\n\t\t\t// Else Remove elements from fragment parent\n\t\t\t} else if (isInstance(parent, EFFragment)) ARR.remove(parent.$ctx.nodeInfo.element, nodeInfo.element)\n\t\t}\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\treturn exec()\n\t}\n\n\t/**\n\t * Subscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be added\n\t * @returns {void}\n\t */\n\t$subscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst ctx = this.$ctx\n\t\tconst { handlers, subscribers, innerData } = ctx\n\t\tconst _path = pathStr.split('.')\n\t\tconst { dataNode, subscriberNode, _key } = initBinding({bind: [_path], ctx, handlers, subscribers, innerData})\n\t\tinform()\n\t\t// Execute the subscriber function immediately\n\t\ttry {\n\t\t\tsubscriber({state: this, value: dataNode[_key]})\n\t\t\t// Put the subscriber inside the subscriberNode\n\t\t\tsubscriberNode.push(subscriber)\n\t\t} catch (e) {\n\t\t\tdbg.error('Error caught when registering subscriber:\\n', e)\n\t\t}\n\t\texec()\n\t}\n\n\t/**\n\t * Unsubscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be removed\n\t * @returns {void}\n\t */\n\t$unsubscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { subscribers } = this.$ctx\n\t\tunsubscribe(pathStr, subscriber, subscribers)\n\t}\n\n\t/**\n\t * Update the component's state with a new state\n\t * @param {Object} newState - New state to be set on this component\n\t * @returns {void}\n\t */\n\t$update(newState) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tlegacyAssign(this, newState)\n\t\texec()\n\t}\n\n\t/**\n\t * Fire a custom event using an Event object on this component\n\t * @param {Event} event - Event object to be dispatched on this component\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$dispatch(event) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.dispatchEvent(event)\n\t}\n\n\t/**\n\t * @typedef {import('./utils/event-helper.js').EFEventOptions} EFEventOptions\n\t */\n\n\t/**\n\t * Fire a custom event using event name on this component\n\t * @param {string} eventName - Name of the custom event\n\t * @param {EFEventOptions} options - Event Options\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$emit(eventName, options) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$dispatch(getEvent(eventName, options))\n\t}\n\n\t/**\n\t * Add custom event listener on this component\n\t * @param {...*} args - Same as Node.addEventListener\n\t * @returns {*} - Same as the return of Node.addEventListener\n\t */\n\t$on(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.addEventListener(...args)\n\t}\n\n\t/**\n\t * Remove custom event listener on this component\n\t * @param {...*} args - Same as Node.removeEventListener\n\t * @returns {*} - Same as the return of Node.removeEventListener\n\t */\n\t$off(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.removeEventListener(...args)\n\t}\n\n\t/**\n\t * Destroy this component\n\t * @returns {number} - Render count down\n\t */\n\t$destroy() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, isFragment, children } = this.$ctx\n\t\tinform()\n\t\tthis.$umount()\n\t\tif (isFragment) for (let i in children) mountingPointStore.delete(children[i].anchor)\n\t\t// Detatch all mounted components\n\t\tfor (let i in this) {\n\t\t\tif (typeOf(this[i]) === 'array') this[i].clear()\n\t\t\telse this[i] = null\n\t\t}\n\t\t// Remove context\n\t\tdelete this.$ctx\n\t\t// Push DOM removement operation to query\n\t\tqueueDom(() => {\n\t\t\tDOM.remove(nodeInfo.element)\n\t\t\tDOM.remove(nodeInfo.placeholder)\n\t\t})\n\t\t// Render\n\t\treturn exec()\n\t}\n}\n\n/**\n * @typedef {typeof EFBaseComponent} EFBaseClass\n */\n\nconst fragmentAST = [{t: 0}]\n\n/**\n * ef component node wrapper\n * Better using this than Fragments if wrapping only HTML elements.\n * @class EFNodeWrapper\n * @extends EFBaseComponent\n * @param {...Node} nodes - Nodes to be wrapped\n * @property {Array<Node>} - Nodes that are wrapped\n */\nconst EFNodeWrapper = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given nodes into an ef component\n\t * @param  {...Node} nodes - Nodes to be wrapped\n\t */\n\tconstructor(...nodes) {\n\t\tsuper(fragmentAST)\n\t\t// Use parens to bypass ESLint's semicolon check\n\t\t// Semi is needed for preventing Buble's bug\n\t\t;(this).$ctx.nodeInfo.element.push(...nodes)\n\t\tthis.$ctx.elements = nodes\n\t}\n\n\tget $el() {\n\t\treturn this.$ctx.elements\n\t}\n}\n\n/**\n * Component fragment wrapper\n * @class Fragment\n * @extends EFBaseComponent\n * @param {...*} children - Things to be wrapped into an ef component\n */\nconst Fragment = class extends EFBaseComponent {\n\tconstructor(...children) {\n\t\tsuper([{t: 0}, ...children])\n\t}\n}\n\nconst textFragmentAst = [{t: 0},[['text']]]\n\n/**\n * ef component text wrapper\n * @class EFTextFragment\n * @extends EFBaseComponent\n * @param {string} text - String to be wrapped\n * @property {string} text - Text on the fragment component\n */\nconst EFTextFragment = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given text into an ef component\n\t * @param {string} text - String to be wrapped\n\t */\n\tconstructor(text) {\n\t\tinform()\n\t\tsuper(textFragmentAst)\n\t\tthis.text = text\n\t\texec()\n\t}\n}\nmapAttrs(EFTextFragment, {text: {}})\n\nenumerableFalse(EFBaseComponent, ['$mount', '$umount', '$subscribe', '$unsubscribe', '$update', '$dispatch', '$emit', '$on', '$off', '$destroy'])\nenumerableFalse(EFNodeWrapper, ['$el'])\n\n/**\n * Transform almost anyting into ef component\n * @template {value} T\n * @param {T} value - Things to be transformed into ef component\n * @returns {(EFNodeWrapper|EFTextFragment|T)} - Wrapped component or value it self if not supports converting\n */\nconst toEFComponent = (value) => {\n\tif (value === null || typeof value === 'undefined' || value instanceof EFBaseComponent) return value\n\n\tif (value !== nullComponent) {\n\t\tif (value instanceof Node) return new EFNodeWrapper(value)\n\t\telse if (typeof value === 'string') return new EFTextFragment(value)\n\t\telse return new EFTextFragment(JSON.stringify(value))\n\t}\n}\n\nshared.EFBaseComponent = EFBaseComponent\nshared.toEFComponent = toEFComponent\n\nexport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent}\n","import {EFBaseComponent, Fragment, toEFComponent} from './renderer.js'\nimport {assign} from './utils/polyfills.js'\n\nconst flatten = (prev, item) => {\n\tif (Array.isArray(item)) prev.push(...item.map(toEFComponent))\n\telse prev.push(toEFComponent(item))\n\n\treturn prev\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseComponent} EFBaseComponent\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create ef component from JSX\n * @template {EFBaseClass} T\n * @param {(string|T)} tag - JSX tag\n * @param {Object.<string,*>} attrs - JSX attributes\n * @param  {...*} children - JSX children\n * @returns {(EFBaseComponent|T extends {new (...args: any): infer R} ? R : never)} ef component created from JSX\n */\nconst createElement = (tag, attrs, ...children) => {\n\t// Create special component for fragment\n\tif (tag === Fragment) return new Fragment(...children)\n\n\t// Create an instance if tag is an ef class\n\tif (Object.isPrototypeOf.call(EFBaseComponent, tag)) {\n\t\tif (children.length <= 0) return new tag(attrs)\n\t\treturn new tag(assign({children: children.reduce(flatten, [])}, attrs || {}))\n\t}\n\n\t// Else return the generated basic component\n\t// Transform all label only attributes to ef-supported style\n\tconst transformedAttrs = assign({}, attrs)\n\tfor (let i in transformedAttrs) {\n\t\tif (transformedAttrs[i] === true) transformedAttrs[i] = ''\n\t}\n\n\treturn new EFBaseComponent([\n\t\t{\n\t\t\tt: tag,\n\t\t\ta: transformedAttrs\n\t\t},\n\t\t...children\n\t])\n}\n\nexport default createElement\n","// Import everything\nimport parse from './lib/parser.js'\nimport typeOf from 'ef-core/src/lib/utils/type-of.js'\nimport { mixStr } from 'ef-core/src/lib/utils/literals-mix.js'\nimport parseEft from 'eft-parser'\nimport { version } from '../package.json'\n// Import core components\nimport {\n\tcreate as createComponent,\n\tcreateElement,\n\tmapAttrs,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tsetDOMImpl,\n\tmountOptions\n} from 'ef-core'\n\n// Set parser\nlet parser = parseEft\n\n/**\n * @typedef {import('ef-core/src/ef-core.js').EFMountOption} EFMountOption\n * @typedef {import('ef-core/src/ef-core.js').EFMountConfig} EFMountConfig\n * @typedef {import('ef-core/src/ef-core.js').EFAST} EFAST\n * @typedef {import('ef-core/src/ef-core.js').EFBaseClass} EFBaseClass\n * @typedef {import('ef-core/src/ef-core.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('ef-core/src/ef-core.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('ef-core/src/ef-core.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('ef-core/src/ef-core.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('ef-core/src/ef-core.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('ef-core/src/ef-core.js').Fragment} Fragment\n * @typedef {import('ef-core/src/ef-core.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('ef-core/src/ef-core.js').EFTextFragment} EFTextFragment\n * @typedef {import('ef-core/src/ef-core.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Return a brand new class for the new component\n * @param {string|EFAST} value - Template or AST for the component\n */\nconst create = (value) => {\n\tconst valType = typeOf(value)\n\tif (valType === 'string') value = parse(value, parser)\n\telse if (valType !== 'array') throw new TypeError('Cannot create new component without proper template or AST!')\n\n\treturn createComponent(value)\n}\n\n/**\n * Change parser\n * @param {Function} newParser - Parser you want to change with\n * @returns {void}\n */\nconst setParser = (newParser) => {\n\tparser = newParser\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Tagged template to quickly create an inline ef component class\n * @param {...*} args - String literal\n */\nconst t = (...args) => create(mixStr(...args))\n\nexport {\n\tt,\n\tcreate,\n\tcreateElement,\n\tmapAttrs,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tsetParser,\n\tparseEft,\n\tmountOptions,\n\tsetDOMImpl,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') console.info(`[EF] ef.js v${version} initialized!`)\n","// Import everything\nimport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent} from './lib/renderer.js'\nimport {applyMountingPoint} from './lib/creator.js'\nimport mountOptions from './mount-options.js'\nimport createElement from './lib/jsx-create-element.js'\nimport mapAttrs from './lib/map-attrs.js'\nimport {onNextRender, inform, exec, bundle, isPaused} from './lib/render-queue.js'\nimport dbg from './lib/utils/debug.js'\nimport typeOf from './lib/utils/type-of.js'\nimport scoped from './lib/utils/scoped-component.js'\nimport {setDOMImpl} from './lib/utils/dom-helper.js'\nimport {version} from '../package.json'\n\n// Apply mounting point properties for classes\nconst applyMountingPoints = (node, tpl) => {\n\tconst nodeType = typeOf(node)\n\tswitch (nodeType) {\n\t\tcase 'array': {\n\t\t\tconst [info, ...childNodes] = node\n\t\t\tif (typeOf(info) === 'object') for (let i of childNodes) applyMountingPoints(i, tpl)\n\t\t\tbreak\n\t\t}\n\t\tcase 'object': {\n\t\t\tif (node.t > 1) throw new TypeError(`[EF] Not a standard ef.js AST: Unknown mounting point type '${node.t}'`)\n\t\t\tapplyMountingPoint(node.t, node.n, tpl)\n\t\t\tbreak\n\t\t}\n\t\tcase 'string': {\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new TypeError(`[EF] Not a standard ef.js AST: Unknown node type '${nodeType}'`)\n\t\t}\n\t}\n}\n\n/**\n * @typedef {import('./mount-options.js').EFMountOption} EFMountOption\n * @typedef {import('./mount-options.js').EFMountConfig} EFMountConfig\n * @typedef {import('./lib/renderer.js').EFAST} EFAST\n * @typedef {import('./lib/renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('./lib/renderer.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('./lib/renderer.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('./lib/renderer.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('./lib/renderer.js').Fragment} Fragment\n * @typedef {import('./lib/renderer.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('./lib/renderer.js').EFTextFragment} EFTextFragment\n * @typedef {import('./lib/utils/event-helper.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create a brand new component class for the new component\n * @param {EFAST} ast - AST for the component\n */\nconst create = (ast) => {\n\n\t/**\n\t * The very basic component which users can use\n\t * @class EFComponent\n\t * @param {Object=} initState - Initial state for the component to create with\n\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t */\n\tconst EFComponent = class extends EFBaseComponent {\n\n\t\t/**\n\t\t * Create an EFComponent with initial state\n\t\t * @param {Object=} initState - Initial state for the component to create with\n\t\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t\t */\n\t\tconstructor(initState, scope) {\n\t\t\tinform()\n\t\t\tsuper(ast, scope)\n\t\t\tif (initState) this.$update(initState)\n\t\t\texec()\n\t\t}\n\t}\n\tapplyMountingPoints(ast, EFComponent)\n\n\t// Workaround for a bug of buble\n\t// https://github.com/bublejs/buble/issues/197\n\tObject.defineProperty(EFComponent.prototype, 'constructor', {enumerable: false})\n\treturn EFComponent\n}\n\nexport {\n\tcreate,\n\tmapAttrs,\n\tcreateElement,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\ttoEFComponent,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tmountOptions,\n\tsetDOMImpl,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') dbg.info(`ef-core v${version} initialized!`)\n","import eftParser from 'eft-parser'\n\nconst parse = (template, parser) => {\n\tif (!parser) parser = eftParser\n\treturn parser(template)\n}\n\nexport default parse\n","import {assign} from './polyfills.js'\n\n/**\n * @typedef {import('../renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('../renderer.js').EFTemplateScope} EFTemplateScope\n */\n\n/**\n * Attach a default scope to the component class\n * @template {component} T\n * @param {EFBaseClass} component - Component class to be scoped\n * @param {EFTemplateScope} initScope - Scope to be bond on the component class\n * @returns {T} - Scoped component class\n */\nconst scoped = (component, initScope) => class extends component {\n\tconstructor(state, scope = {}) {\n\t\tconst _scope = assign({}, initScope)\n\t\tsuper(state, assign(_scope, scope))\n\t}\n}\n\nexport default scoped\n"],"names":["O2C","SyntaxError","UC2C","val","substr","length","parseInt","String","fromCodePoint","err","U2C","substring","fromCharCode","X2C","efEscape","string","const","escaped","split","doubleChar","let","escapedStr","replace","oct","ucp","uni","hex","b","t","n","v","f","r","esc","push","join","char","splitWith","escapedSplit","i","splitBy","splitArr","shift","getErrorMsg","msg","line","checkValidType","obj","indexOf","ESCAPE","parsed","JSON","parse","e","splitDefault","slice","pathArr","_path","trim","map","_default","defaultVal","splitLiterals","strs","mustache","tmpl","mustaches","match","pushStr","textArr","str","parseText","result","exprs","dotToSpace","getOption","options","keys","option","keyCode","isNaN","s","p","h","a","c","u","console","warn","setOption","parseLine","parsingInfo","offset","offsetReg","trimmedLine","removed","prevDepth","removeOffset","indentReg","spaces","spaceIndent","RegExp","getIndent","content","escapedName","splitted","tagInfo","depth","test","getDepth","prevType","topExists","type","currentNode","ast","resolveDepth","info","hashref","ref","tag","class","newNode","name","value","propPath","l","listener","ops","k","getEventOptions","m","method","_value","reserved","parseEft","template","TypeError","tplType","lines","Array","isArray","Object","hasOwnProperty","call","typeOf","mixStr","getVal","data","proto","prototype","ARR","copy","arr","empty","equals","left","right","pop","apply","items","remove","item","index","splice","reverse","rightUnique","newArr","j","sort","fn","args","unshift","Set","from","unique","queue","handlers","modificationQueue","queueDom","handler","domQueue","inform","count","execUserQueue","userQueue","userFnQueue","exec","immediate","renderQueue","execModifications","domRenderQueue","execDomModifications","setTimeout","legacyAssign","ee","er","defineNode","key","node","defineProperty","get","set","assign","configurable","enumerable","resolve","parentNode","resolveReactivePath","subscribers","innerData","handlerNode","subscriberNode","dataNode","resolveAllPath","_key","undefined","isnan","initBinding","subscriberExecuting","bind","ctx","subscriber","state","dbg","error","isInstance","constructor","enumerableFalse","classObj","strTpl","log","isBrowser","document","Node","shared","mountingPointStore","WeakMap","DOM","EFFragment","appendTo","self","append","this","before","tempFragment","createDocumentFragment","nodes","EFBaseComponent","$mount","target","appendChild","insertBefore","after","nextSibling","handleMountingPoint","mountingPoint","clear","$ctx","nodeInfo","element","placeholder","children","toEFComponent","nodeType","$umount","removeChild","setDOMImpl","sim","getEvent","bubbles","cancelable","event","createEvent","initEvent","typeValid","getElement","tagType","tagName","tagContent","attrs","svg","createElementNS","toLowerCase","is","createElement","refs","regTmpl","_handler","addAttr","attr","custom","setAttributeNS","xlinkNS","setAttribute","removeAttribute","removeAttributeNS","addProp","keyPath","lastKey","addListener","dispatch","lastNode","resolvePath","expr","_update","canceoable","radios","querySelectorAll","selected","dispatchEvent","$data","checked","rawHandler","addEvent","shiftKey","altKey","ctrlKey","metaKey","which","stopPropagation","stopImmediatePropagation","preventDefault","methods","bindTextNode","textNode","textContent","createTextNode","bindMountingList","anchor","defineProperties","DOMARR","isFragment","safeZone","resolveAST","create","getGetter","Error","checkTrue","base","getSetter","baseNode","_trueVal","trueVal","_falseVal","falseVal","defaultRoot","getBase","root","mapAttrs","tpl","attrMap","basicProperty","$destroy","poped","elements","parent","tempArr","shifted","sorted","spliced","mountOptions","BEFORE","AFTER","APPEND","REPLACE","nullComponent","mountingPointUpdaters","child","fragment","isPrototypeOf","scope","childNodes","mount","prototypeAccessors","newData","$methods","newMethods","$refs","querySelector","$subscribe","pathStr","$unsubscribe","resolveSubscriber","$update","newState","$dispatch","$emit","eventName","$on","addEventListener","$off","removeEventListener","delete","fragmentAST","EFNodeWrapper","super","prototypeAccessors$1","$el","Fragment","textFragmentAst","EFTextFragment","text","stringify","flatten","prev","EFComponent","valType","parser","eftParser","applyMountingPoints","initState","cb","reduce","transformedAttrs","component","initScope","_scope","newParser"],"mappings":"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"}
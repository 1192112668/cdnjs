{"version":3,"file":"ef.min.js","sources":["../node_modules/eft-parser/src/escape-parser.js","../node_modules/eft-parser/src/eft-parser.js","../node_modules/ef-core/src/lib/utils/type-of.js","../node_modules/ef-core/src/lib/utils/literals-mix.js","../node_modules/ef-core/src/lib/utils/array-helper.js","../node_modules/ef-core/src/lib/render-queue.js","../node_modules/ef-core/src/lib/utils/polyfills.js","../node_modules/ef-core/src/lib/resolver.js","../node_modules/ef-core/src/lib/utils/isnan.js","../node_modules/ef-core/src/lib/binding.js","../node_modules/ef-core/src/lib/utils/fast-instance-of.js","../node_modules/ef-core/src/lib/utils/buble-fix.js","../node_modules/ef-core/src/lib/utils/dom-helper.js","../node_modules/ef-core/src/lib/utils/debug.js","../node_modules/ef-core/src/lib/utils/is-browser.js","../node_modules/ef-core/src/lib/utils/global-shared.js","../node_modules/ef-core/src/lib/utils/event-helper.js","../node_modules/ef-core/src/lib/element-creator.js","../node_modules/ef-core/src/lib/creator.js","../node_modules/ef-core/src/lib/utils/dom-arr-helper.js","../node_modules/ef-core/src/lib/map-attrs.js","../node_modules/ef-core/src/mount-options.js","../node_modules/ef-core/src/lib/renderer.js","../node_modules/ef-core/src/lib/jsx-create-element.js","../src/ef.js","../node_modules/ef-core/src/ef-core.js","../src/lib/parser.js","../node_modules/ef-core/src/lib/utils/scoped-component.js"],"sourcesContent":["// Set the escape character\nconst char = '&'\nconst doubleChar = char + char\n\n// Initlize RegExp\nconst oct = new RegExp(`\\\\${char}[0-7]{1,3}`, 'g')\nconst ucp = new RegExp(`\\\\${char}u\\\\[.*?\\\\]`, 'g')\nconst uni = new RegExp(`\\\\${char}u.{0,4}`, 'g')\nconst hex = new RegExp(`\\\\${char}x.{0,2}`, 'g')\nconst esc = new RegExp(`\\\\${char}`, 'g')\nconst b = new RegExp(`\\\\${char}b`, 'g')\nconst t = new RegExp(`\\\\${char}t`, 'g')\nconst n = new RegExp(`\\\\${char}n`, 'g')\nconst v = new RegExp(`\\\\${char}v`, 'g')\nconst f = new RegExp(`\\\\${char}f`, 'g')\nconst r = new RegExp(`\\\\${char}r`, 'g')\n\n// Escape octonary sequence\nconst O2C = () => {\n\tthrow new SyntaxError('Octal escape sequences are not allowed in EFML.')\n}\n\n// Escape unicode code point sequence\nconst UC2C = (val) => {\n\tval = val.substr(3, val.length - 4)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\ttry {\n\t\treturn String.fromCodePoint(val)\n\t} catch (err) {\n\t\tthrow new SyntaxError('Undefined Unicode code-point')\n\t}\n}\n\n// Escape unicode sequence\nconst U2C = (val) => {\n\tval = val.substring(2)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\treturn String.fromCharCode(val)\n}\n\n// Escape hexadecimal sequence\nconst X2C = (val) => {\n\tval = `00${val.substring(2)}`\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid hexadecimal escape sequence')\n\treturn String.fromCharCode(val)\n}\n\nconst efEscape = (string) => {\n\t// Split strings\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = []\n\n\t// Escape all known escape characters\n\tfor (let i of splitArr) {\n\t\tconst escapedStr = i\n\t\t\t.replace(oct, O2C)\n\t\t\t.replace(ucp, UC2C)\n\t\t\t.replace(uni, U2C)\n\t\t\t.replace(hex, X2C)\n\t\t\t.replace(b, '\\b')\n\t\t\t.replace(t, '\\t')\n\t\t\t.replace(n, '\\n')\n\t\t\t.replace(v, '\\v')\n\t\t\t.replace(f, '\\f')\n\t\t\t.replace(r, '\\r')\n\t\t\t// Remove all useless escape characters\n\t\t\t.replace(esc, '')\n\t\tescaped.push(escapedStr)\n\t}\n\t// Return escaped string\n\treturn escaped.join(char)\n}\n\nconst checkEscape = string => string[string.length - 1] === char\n\nconst splitWith = (string, char) => {\n\tconst splitArr = string.split(char)\n\tconst escapedSplit = []\n\tlet escaped = false\n\tfor (let i of splitArr) {\n\t\tif (escaped) escapedSplit[escapedSplit.length - 1] += `${char}${i}`\n\t\telse escapedSplit.push(i)\n\t\tescaped = checkEscape(i)\n\t}\n\treturn escapedSplit\n}\n\nconst splitBy = (string, char) => {\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = splitWith(splitArr.shift(), char)\n\tfor (let i of splitArr) {\n\t\tconst escapedSplit = splitWith(i, char)\n\t\tescaped[escaped.length - 1] += `${doubleChar}${escapedSplit.shift()}`\n\t\tescaped.push(...escapedSplit)\n\t}\n\treturn escaped\n}\n\nexport { efEscape, splitBy }\n","import { efEscape, splitBy } from './escape-parser.js'\n\nconst typeSymbols = '>#%@.-+'\nconst reserved = [\n\t'$ctx', '$refs', '$data', '$methods', '$mount', '$umount', '$subscribe', '$unsubscribe', '$update',\n\t'$dispatch', '$emit', '$on', '$off', '$destroy', '__DIRECTMOUNT__'\n]\nconst mustache = /\\{\\{.+?\\}\\}/g\nconst spaceIndent = /^(\\t*)( *).*/\nconst hashref = /#([^}]|}[^}])*$/\n\nconst getErrorMsg = (msg, line = -2) => `Failed to parse eft template: ${msg}. at line ${line + 1}`\n\nconst isEmpty = string => !string.replace(/\\s/, '')\n\nconst checkValidType = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\nconst ESCAPE = (string) => {\n\tif (!string) return [string, false]\n\ttry {\n\t\tconst parsed = JSON.parse(string)\n\t\tif (['number', 'boolean'].indexOf(typeof parsed) === -1) return [efEscape(string), true]\n\t\treturn [parsed, false]\n\t} catch (e) {\n\t\treturn [efEscape(string), true]\n\t}\n}\n\nconst getOffset = (string, parsingInfo) => {\n\tif (parsingInfo.offset !== null) return\n\tparsingInfo.offset = string.match(/\\s*/)[0]\n\tif (parsingInfo.offset) parsingInfo.offsetReg = parsingInfo.offset\n}\n\nconst removeOffset = (string, parsingInfo, i) => {\n\tif (parsingInfo.offsetReg) {\n\t\tlet removed = false\n\t\tstring = string.replace(parsingInfo.offsetReg, () => {\n\t\t\tremoved = true\n\t\t\treturn ''\n\t\t})\n\t\tif (!removed) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got -1`, i))\n\t}\n\treturn string\n}\n\nconst getIndent = (string, parsingInfo) => {\n\tif (parsingInfo.indentReg) return\n\tconst spaces = string.match(spaceIndent)[2]\n\tif (spaces) {\n\t\tparsingInfo.indentReg = new RegExp(spaces, 'g')\n\t}\n}\n\nconst getDepth = (string, parsingInfo, i) => {\n\tlet depth = 0\n\tif (parsingInfo.indentReg) string = string.replace(/^\\s*/, str => str.replace(parsingInfo.indentReg, '\\t'))\n\tconst content = string.replace(/^\\t*/, (str) => {\n\t\tdepth = str.length\n\t\treturn ''\n\t})\n\tif ((/^\\s/).test(content)) throw new SyntaxError(getErrorMsg('Bad indent', i))\n\treturn { depth, content }\n}\n\nconst resolveDepth = (ast, depth) => {\n\tlet currentNode = ast\n\tfor (let i = 0; i < depth; i++) currentNode = currentNode[currentNode.length - 1]\n\treturn currentNode\n}\n\nconst splitDefault = (string) => {\n\tstring = string.slice(2, string.length - 2)\n\tconst [_path, ..._default] = splitBy(string, '=')\n\tconst pathArr = splitBy(_path.trim(), '.').map(efEscape)\n\tconst [defaultVal, escaped] = ESCAPE(_default.join('=').trim())\n\tif (checkValidType(defaultVal) && (escaped || (!escaped && defaultVal !== ''))) return [pathArr, defaultVal]\n\treturn [pathArr]\n}\n\nconst splitLiterals = (string) => {\n\tconst strs = string.split(mustache)\n\tif (strs.length === 1) return ESCAPE(string)[0]\n\tconst tmpl = []\n\tif (strs.length === 2 && !strs[0] && !strs[1]) tmpl.push(0)\n\telse tmpl.push(strs.map(efEscape))\n\tconst mustaches = string.match(mustache)\n\tif (mustaches) tmpl.push(...mustaches.map(splitDefault))\n\treturn tmpl\n}\n\nconst pushStr = (textArr, str) => {\n\tif (str) textArr.push(str)\n}\n\nconst parseText = (string) => {\n\tconst result = splitLiterals(string)\n\tif (checkValidType(result)) return [`${result}`]\n\tconst [strs, ...exprs] = result\n\tconst textArr = []\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tpushStr(textArr, strs[i])\n\t\ttextArr.push(exprs[i])\n\t}\n\tpushStr(textArr, strs[strs.length - 1])\n\treturn textArr\n}\n\nconst dotToSpace = val => val.replace(/\\./g, ' ')\n\nconst parseTag = (string) => {\n\tconst tagInfo = {}\n\tconst [tag, ...content] = splitBy(string.replace(hashref, (val) => {\n\t\ttagInfo.ref = val.slice(1)\n\t\treturn ''\n\t}), '.')\n\ttagInfo.tag = efEscape(tag)\n\ttagInfo.class = splitLiterals(content.join('.'))\n\tif (typeof tagInfo.class === 'string') tagInfo.class = dotToSpace(tagInfo.class).trim()\n\telse if (tagInfo.class[0]) tagInfo.class[0] = tagInfo.class[0].map(dotToSpace)\n\treturn tagInfo\n}\n\nconst parseNodeAttrs = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tname: efEscape(splitted.shift().trim()),\n\t\tvalue: splitLiterals(splitted.join('=').trim())\n\t}\n}\n\nconst parseNodeProps = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tpropPath: splitBy(splitted.shift().trim(), '.').map(efEscape),\n\t\tvalue: splitLiterals(splitted.join('=').trim())\n\t}\n}\n\nconst parseEvent = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tname: splitted.shift().trim(),\n\t\tvalue: splitted.join('=').trim()\n\t}\n}\n\nconst setOption = (options, option) => {\n\tswitch (option) {\n\t\tcase 'stop': {\n\t\t\toptions.s = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'stopImmediate': {\n\t\t\toptions.i = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'prevent': {\n\t\t\toptions.p = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'shift': {\n\t\t\toptions.h = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'alt': {\n\t\t\toptions.a = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'ctrl': {\n\t\t\toptions.c = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'meta': {\n\t\t\toptions.t = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'capture': {\n\t\t\toptions.u = 1\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Abandoned unsupported eft event option '${option}'.`)\n\t\t}\n\t}\n}\n\nconst getOption = (options, keys, option) => {\n\tconst keyCode = parseInt(option, 10)\n\tif (isNaN(keyCode)) return setOption(options, efEscape(option))\n\tkeys.push(keyCode)\n}\n\nconst getEventOptions = (name) => {\n\tconst options = {}\n\tconst keys = []\n\tconst [listener, ...ops] = splitBy(name, '.')\n\toptions.l = efEscape(listener)\n\tfor (let i of ops) getOption(options, keys, i)\n\tif (keys.length > 0) options.k = keys\n\treturn options\n}\n\nconst splitEvents = (string) => {\n\tconst [name, ...value] = splitBy(string, ':')\n\tconst content = value.join(':')\n\tconst escapedName = efEscape(name.trim())\n\tif (content) return [escapedName, splitLiterals(content)]\n\treturn [escapedName]\n}\n\nconst parseLine = ({line, ast, parsingInfo, i}) => {\n\tif (isEmpty(line)) return\n\tgetOffset(line, parsingInfo)\n\n\tconst trimmedLine = removeOffset(line, parsingInfo, i)\n\tgetIndent(trimmedLine, parsingInfo)\n\n\tlet { depth, content } = getDepth(trimmedLine, parsingInfo, i)\n\n\tif (content) {\n\t\tif (depth < 0 || depth - parsingInfo.prevDepth > 1 || (depth - parsingInfo.prevDepth === 1 && ['comment', 'tag'].indexOf(parsingInfo.prevType) === -1) || (parsingInfo.prevType !== 'comment' && depth === 0 && parsingInfo.topExists)) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got ${depth}`, i))\n\t\tconst type = content[0]\n\t\tcontent = content.slice(1)\n\t\tif (!content && typeSymbols.indexOf(type) >= 0) throw new SyntaxError(getErrorMsg('Empty content', i))\n\t\t// Jump back to upper level\n\t\tif (depth < parsingInfo.prevDepth || (depth === parsingInfo.prevDepth && parsingInfo.prevType === 'tag')) parsingInfo.currentNode = resolveDepth(ast, depth)\n\t\tparsingInfo.prevDepth = depth\n\n\t\tswitch (type) {\n\t\t\tcase '>': {\n\t\t\t\tconst info = parseTag(content)\n\t\t\t\tconst newNode = [{\n\t\t\t\t\tt: info.tag\n\t\t\t\t}]\n\t\t\t\tif (info.class) {\n\t\t\t\t\tnewNode[0].a = {}\n\t\t\t\t\tnewNode[0].a.class = info.class\n\t\t\t\t}\n\t\t\t\tif (info.ref) newNode[0].r = info.ref\n\t\t\t\tparsingInfo.currentNode.push(newNode)\n\t\t\t\tparsingInfo.currentNode = newNode\n\t\t\t\tparsingInfo.prevType = 'tag'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '#': {\n\t\t\t\tconst { name, value } = parseNodeAttrs(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].a) parsingInfo.currentNode[0].a = {}\n\t\t\t\tparsingInfo.currentNode[0].a[name] = value\n\t\t\t\tparsingInfo.prevType = 'attr'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '%': {\n\t\t\t\tconst { propPath, value } = parseNodeProps(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].p) parsingInfo.currentNode[0].p = []\n\t\t\t\tparsingInfo.currentNode[0].p.push([propPath, value])\n\t\t\t\tparsingInfo.prevType = 'prop'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '@': {\n\t\t\t\tconst { name, value } = parseEvent(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].e) parsingInfo.currentNode[0].e = []\n\t\t\t\tconst options = getEventOptions(name)\n\t\t\t\tconst [method, _value] = splitEvents(value)\n\t\t\t\toptions.m = method\n\t\t\t\tif (_value) options.v = _value\n\t\t\t\tparsingInfo.currentNode[0].e.push(options)\n\t\t\t\tparsingInfo.prevType = 'event'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '.': {\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '|': {\n\t\t\t\tif (parsingInfo.currentNode.length > 1) content = `\\n${content}`\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'multiline-text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '-': {\n\t\t\t\tif (reserved.indexOf(content) !== -1) throw new SyntaxError(getErrorMsg(`Reserved name '${content}' should not be used`, i))\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 0\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'node'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '+': {\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 1\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'list'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tparsingInfo.prevType = 'comment'\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst parseEft = (template) => {\n\tif (!template) throw new TypeError(getErrorMsg('Template required, but nothing given'))\n\tconst tplType = typeof template\n\tif (tplType !== 'string') throw new TypeError(getErrorMsg(`Expected a string, but got a(n) ${tplType}`))\n\tconst lines = template.split(/\\r?\\n/)\n\tconst ast = [{t: 0}]\n\tconst parsingInfo = {\n\t\tindentReg: null,\n\t\tprevDepth: 0,\n\t\toffset: null,\n\t\toffsetReg: null,\n\t\tprevType: 'comment',\n\t\tcurrentNode: ast,\n\t\ttopExists: false,\n\t}\n\tfor (let i = 0; i < lines.length; i++) parseLine({line: lines[i], ast, parsingInfo, i})\n\n\tif (ast.length <= 1) throw new SyntaxError(getErrorMsg('Nothing to be parsed', lines.length - 1))\n\tif (ast.length === 2 && Array.isArray(ast[1]) && Object.hasOwnProperty.call(ast[1][0], 't')) return ast[1]\n\treturn ast\n}\n\nexport default parseEft\n","const typeOf = (obj) => {\n\tif (Array.isArray(obj)) return 'array'\n\treturn typeof obj\n}\n\nexport default typeOf\n","const mixStr = (strs, ...exprs) => {\n\tlet string = ''\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tif (typeof exprs[i] === 'undefined') string += strs[i]\n\t\telse string += (strs[i] + exprs[i])\n\t}\n\treturn string + strs[strs.length - 1]\n}\n\nconst getVal = ({dataNode, _key}) => {\n\tconst data = dataNode[_key]\n\tif (typeof data === 'undefined') return ''\n\treturn data\n}\n\nconst mixVal = (strs, ...exprs) => {\n\tif (!strs) return getVal(exprs[0])\n\tconst template = [strs]\n\ttemplate.push(...exprs.map(getVal))\n\treturn mixStr(...template)\n}\n\nexport {mixStr, mixVal}\n","const proto = Array.prototype\n\nconst ARR = {\n\tcopy(arr) {\n\t\treturn proto.slice.call(arr, 0)\n\t},\n\tempty(arr) {\n\t\tarr.length = 0\n\t\treturn arr\n\t},\n\tequals(left, right) {\n\t\tif (!Array.isArray(right)) return false\n\t\tif (left === right) return true\n\t\tif (left.length !== right.length) return false\n\t\tfor (let i = 0, l = left.length; i < l; i++) {\n\t\t\tif (left[i] !== right[i]) return false\n\t\t}\n\t\treturn true\n\t},\n\tpop(arr) {\n\t\treturn proto.pop.call(arr)\n\t},\n\tpush(arr, ...items) {\n\t\treturn proto.push.apply(arr, items)\n\t},\n\tremove(arr, item) {\n\t\tconst index = proto.indexOf.call(arr, item)\n\t\tif (index > -1) {\n\t\t\tproto.splice.call(arr, index, 1)\n\t\t\treturn item\n\t\t}\n\t},\n\treverse(arr) {\n\t\treturn proto.reverse.call(arr)\n\t},\n\trightUnique(arr) {\n\t\tconst newArr = []\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tfor (let j = i + 1; j < arr.length; j++) if (arr[i] === arr[j]) j = i += 1\n\t\t\tnewArr.push(arr[i])\n\t\t}\n\t\treturn newArr\n\t},\n\tshift(arr) {\n\t\treturn proto.shift.call(arr)\n\t},\n\tslice(arr, index, length) {\n\t\treturn proto.slice.call(arr, index, length)\n\t},\n\tsort(arr, fn) {\n\t\treturn proto.sort.call(arr, fn)\n\t},\n\tsplice(arr, ...args) {\n\t\treturn proto.splice.apply(arr, args)\n\t},\n\tunshift(arr, ...items) {\n\t\treturn proto.unshift.apply(arr, items)\n\t}\n}\n\nif (typeof Set !== 'undefined' && Array.from) ARR.unique = arr => Array.from(new Set(arr))\nelse ARR.unique = ARR.rightUnique\n\nexport default ARR\n","import ARR from './utils/array-helper.js'\n\nconst modificationQueue = []\nconst domQueue = []\nconst userQueue = []\nlet count = 0\n\nconst queue = handlers => modificationQueue.push(...handlers)\nconst queueDom = handler => domQueue.push(handler)\nconst onNextRender = handler => userQueue.push(handler)\n\n/**\n * @returns {boolean} - Is render paused\n */\nconst isPaused = () => count > 0\n\n/**\n * Add 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @returns {number} - Render count down\n */\nconst inform = () => {\n\tcount += 1\n\treturn count\n}\n\nconst execModifications = () => {\n\tif (modificationQueue.length === 0) return\n\tconst renderQueue = ARR.unique(modificationQueue)\n\tARR.empty(modificationQueue)\n\tfor (let i of renderQueue) i()\n}\n\nconst execDomModifications = () => {\n\tif (domQueue.length === 0) return\n\tconst domRenderQueue = ARR.rightUnique(domQueue)\n\tARR.empty(domQueue)\n\tfor (let i of domRenderQueue) i()\n}\n\nconst execUserQueue = () => {\n\tif (userQueue.length === 0) return\n\tconst userFnQueue = ARR.unique(userQueue)\n\tARR.empty(userQueue)\n\tfor (let i of userFnQueue) i()\n}\n\n/**\n * Minus 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @param {boolean} immediate - Render immediately, will force countdown become 0\n * @returns {number} - Render count down\n */\nconst exec = (immediate) => {\n\tif (!immediate && (count -= 1) > 0) return count\n\tcount = 0\n\n\tif (modificationQueue.length > 0) execModifications()\n\n\tif (domQueue.length > 0) execDomModifications()\n\n\t// Execute user queue after DOM update\n\tif (userQueue.length > 0) setTimeout(execUserQueue, 0)\n\n\treturn count\n}\n\n/**\n * Run callback in a safe way, without worrying about unhandled errors may break rendering.\n * @param {Function} cb - Callback function to be executed safly\n * @returns {(void|Error)} - Error that happens when executing callback\n */\nconst bundle = (cb) => {\n\tinform()\n\ttry {\n\t\t// eslint-disable-next-line callback-return\n\t\texec(cb(inform, exec))\n\t} catch (e) {\n\t\texec()\n\t\treturn e\n\t}\n}\n\nexport { queue, queueDom, onNextRender, inform, exec, bundle, isPaused }\n","// Enough for ef's usage, so no need for a full polyfill\nconst legacyAssign = (ee, er) => {\n\tfor (let i in er) ee[i] = er[i]\n\treturn ee\n}\n\nconst assign = Object.assign || legacyAssign\n\nexport {assign, legacyAssign}\n","import {inform, exec} from './render-queue.js'\nimport {assign} from './utils/polyfills.js'\n\nconst resolveAllPath = ({_path, handlers, subscribers, innerData}) => {\n\tfor (let i of _path) {\n\t\tif (!handlers[i]) handlers[i] = {}\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tif (!innerData[i]) innerData[i] = {}\n\t\thandlers = handlers[i]\n\t\tsubscribers = subscribers[i]\n\t\tinnerData = innerData[i]\n\t}\n\treturn {\n\t\thandlerNode: handlers,\n\t\tsubscriberNode: subscribers,\n\t\tdataNode: innerData\n\t}\n}\n\n// Workaround for the third bug of buble:\n// https://github.com/bublejs/buble/issues/106\nconst defineNode = (key, obj) => {\n\tconst node = {}\n\tObject.defineProperty(obj, key, {\n\t\tget() {\n\t\t\treturn node\n\t\t},\n\t\tset(data) {\n\t\t\tinform()\n\t\t\tassign(node, data)\n\t\t\texec()\n\t\t},\n\t\tconfigurable: false,\n\t\tenumerable: true\n\t})\n\treturn node\n}\n\nconst resolveReactivePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (obj[i]) obj = obj[i]\n\t\telse obj = defineNode(i, obj)\n\t}\n\treturn obj\n}\n\nconst resolvePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (!obj[i]) obj[i] = {}\n\t\tobj = obj[i]\n\t}\n\treturn obj\n}\n\nconst resolve = ({_path, _key, data, handlers, subscribers, innerData}) => {\n\tconst parentNode = resolveReactivePath(_path, data)\n\tconst {handlerNode, subscriberNode, dataNode} = resolveAllPath({_path, handlers, subscribers, innerData})\n\tif (!handlerNode[_key]) handlerNode[_key] = []\n\tif (!subscriberNode[_key]) subscriberNode[_key] = []\n\t/* eslint no-undefined: \"off\" */\n\tif (!Object.prototype.hasOwnProperty.call(dataNode, _key)) dataNode[_key] = undefined\n\treturn {parentNode, handlerNode: handlerNode[_key], subscriberNode: subscriberNode[_key], dataNode}\n}\n\nconst resolveSubscriber = (_path, subscribers) => {\n\tconst pathArr = _path.split('.')\n\tconst key = pathArr.pop()\n\tfor (let i of pathArr) {\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tsubscribers = subscribers[i]\n\t}\n\treturn subscribers[key]\n}\n\nexport {resolveReactivePath, resolvePath, resolve, resolveSubscriber}\n","/* eslint-disable no-self-compare */\nconst isnan = obj => obj !== obj\n\nexport default isnan\n","import {resolve} from './resolver.js'\nimport {inform, exec, queue} from './render-queue.js'\nimport ARR from './utils/array-helper.js'\nimport isnan from './utils/isnan.js'\nimport dbg from './utils/debug.js'\n\nconst initDataNode = ({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key}) => {\n\tlet subscriberExecuting = false\n\tObject.defineProperty(parentNode, _key, {\n\t\tget() {\n\t\t\treturn dataNode[_key]\n\t\t},\n\t\tset(value) {\n\t\t\tif (subscriberExecuting) return\n\t\t\t// Comparing NaN is like eating a cake and suddenly encounter a grain of sand\n\t\t\tif (dataNode[_key] === value || (isnan(dataNode[_key]) && isnan(value))) return\n\t\t\tdataNode[_key] = value\n\t\t\tinform()\n\t\t\tqueue(handlerNode)\n\t\t\texec()\n\t\t\tif (subscriberNode.length > 0) {\n\t\t\t\tsubscriberExecuting = true\n\t\t\t\tinform()\n\t\t\t\ttry {\n\t\t\t\t\tfor (const subscriber of subscriberNode) subscriber({state: ctx.state, value})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdbg.error('Error caught when executing subscribers:\\n', e)\n\t\t\t\t}\n\t\t\t\texec()\n\t\t\t\tsubscriberExecuting = false\n\t\t\t}\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst initBinding = ({bind, ctx, handlers, subscribers, innerData}) => {\n\tconst _path = ARR.copy(bind[0])\n\tconst _key = _path.pop()\n\tconst {parentNode, handlerNode, subscriberNode, dataNode} = resolve({\n\t\t_path,\n\t\t_key,\n\t\tdata: ctx.data,\n\t\thandlers,\n\t\tsubscribers,\n\t\tinnerData\n\t})\n\n\t// Initlize data binding node if not exist\n\tif (!Object.prototype.hasOwnProperty.call(parentNode, _key)) initDataNode({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key})\n\t// Update default value\n\t// bind[1] is the default value for this node\n\tif (bind.length > 1) parentNode[_key] = bind[1]\n\n\treturn {dataNode, parentNode, handlerNode, subscriberNode, _key}\n}\n\nexport default initBinding\n","const isInstance = (er, ee) => er.constructor === ee\n\nexport default isInstance\n","import ARR from './array-helper.js'\n\n// https://github.com/bublejs/buble/issues/197\nconst enumerableFalse = (classObj, keys) => {\n\tfor (let i of keys) Object.defineProperty(classObj.prototype, i, {enumerable: false})\n\treturn classObj\n}\n\n// https://github.com/bublejs/buble/issues/131\nconst prepareArgs = (self, node) => {\n\tconst args = ARR.copy(self)\n\tARR.unshift(args, node)\n\treturn args\n}\n\nexport {enumerableFalse, prepareArgs}\n","// import ARR from './array-helper.js'\nimport isInstance from './fast-instance-of.js'\nimport {assign} from './polyfills.js'\nimport {prepareArgs} from './buble-fix.js'\nimport dbg from './debug.js'\nimport isBrowser from './is-browser.js'\nimport ARR from './array-helper.js'\nimport {inform, exec} from '../render-queue.js'\n\nimport shared from './global-shared.js'\n\n// Will require a weakmap polyfill for IE10 and below\nconst mountingPointStore = new WeakMap()\n\nconst DOM = {}\n\nconst EFFragment = class {\n\tconstructor() {\n\t\tthis.$children = []\n\t\tthis.$safeZone = DOM.document.createDocumentFragment()\n\t}\n\n\tappend(...args) {\n\t\tDOM.append.apply(null, prepareArgs(args, this.$safeZone))\n\t\treturn this.$children.push(...args)\n\t}\n\n\tappendTo(node) {\n\t\tDOM.append.apply(null, prepareArgs(this.$children, node))\n\t}\n\n\tremoveChild(node) {\n\t\tDOM.remove(node)\n\t\tARR.remove(this.$children, node)\n\t}\n\n\tremove() {\n\t\tfor (let i of this.$children) DOM.append(this.$safeZone, i)\n\t}\n}\n\nconst appendNode = (node, tempFragment) => {\n\tconst {element, placeholder} = node.$ctx.nodeInfo\n\tDOM.append(tempFragment, element, placeholder)\n}\n\nconst handleMountingPoint = (element, tempFragment) => {\n\tif (element.nodeType !== 3) return\n\n\tconst mountingPoint = mountingPointStore.get(element)\n\tif (!mountingPoint) return\n\n\tconst {node} = mountingPoint\n\tif (!node) return\n\tif (Array.isArray(node)) {\n\t\tfor (let i of node) appendNode(i, tempFragment)\n\t} else appendNode(node, tempFragment)\n}\n\nDOM.before = (node, ...nodes) => {\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse {\n\t\t\tDOM.Node.prototype.appendChild.call(tempFragment, i)\n\t\t\thandleMountingPoint(i, tempFragment)\n\t\t}\n\t}\n\tDOM.Node.prototype.insertBefore.call(node.parentNode, tempFragment, node)\n\texec()\n}\n\nDOM.after = (node, ...nodes) => {\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse DOM.Node.prototype.appendChild.call(tempFragment, i)\n\t}\n\tif (node.nextSibling) DOM.Node.prototype.insertBefore.call(node.parentNode, tempFragment, node.nextSibling)\n\telse DOM.Node.prototype.appendChild.call(node.parentNode, tempFragment)\n\texec()\n}\n\nDOM.append = (node, ...nodes) => {\n\t// Handle fragment\n\tif (isInstance(node, EFFragment)) return node.append(...nodes)\n\t// Handle EFComponent\n\tif (node instanceof shared.EFBaseComponent) {\n\t\tif (!(Array.isArray(node.children))) {\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn(node, 'has no `children` list mount point! Child nodes are all ignored!')\n\t\t\treturn\n\t\t}\n\n\t\tinform()\n\t\tfor (let i of nodes) {\n\t\t\ti = new shared.toEFComponent(i)\n\t\t\tnode.children.push(i)\n\t\t}\n\t\texec()\n\n\t\treturn\n\t}\n\n\tif ([1,9,11].indexOf(node.nodeType) === -1) return\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tfor (let i of nodes) {\n\t\tif (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse if (i instanceof DOM.Node) {\n\t\t\tDOM.Node.prototype.appendChild.call(tempFragment, i)\n\t\t\thandleMountingPoint(i, tempFragment)\n\t\t} else if (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t}\n\t}\n\tDOM.Node.prototype.appendChild.call(node, tempFragment)\n}\n\nDOM.remove = (node) => {\n\tif (isInstance(node, EFFragment)) node.remove()\n\telse if (node instanceof shared.EFBaseComponent) node.$umount()\n\telse DOM.Node.prototype.removeChild.call(node.parentNode, node)\n}\n\n// addClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.add(...classes)\n// },\n\n// removeClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.remove(...classes)\n// },\n\n// toggleClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tconst classArr = node.className.split(' ')\n// \tfor (let i of classes) {\n// \t\tconst classIndex = classArr.indexOf(i)\n// \t\tif (classIndex > -1) {\n// \t\t\tclassArr.splice(classIndex, 1)\n// \t\t} else {\n// \t\t\tclassArr.push(i)\n// \t\t}\n// \t}\n// \tnode.className = classArr.join(' ').trim()\n// },\n\n// replaceWith(node, newNode) {\n// \tconst parent = node.parentNode\n// \tif (parent) DOM.Node.prototype.replaceChild.call(parent, newNode, node)\n// },\n\n// swap(node, newNode) {\n// \tconst nodeParent = node.parentNode\n// \tconst newNodeParent = newNode.parentNode\n// \tconst nodeSibling = node.nextSibling\n// \tconst newNodeSibling = newNode.nextSibling\n// \tif (nodeParent && newNodeParent) {\n// \t\tDOM.Node.prototype.insertBefore.call(nodeParent, newNode, nodeSibling)\n// \t\tDOM.Node.prototype.insertBefore.call(newNodeParent, node, newNodeSibling)\n// \t}\n// },\n\n// prepend(node, ...nodes) {\n// \tif ([1,9,11].indexOf(node.nodeType) === -1) {\n// \t\treturn\n// \t}\n// \tconst tempFragment = DOM.document.createDocumentFragment()\n// \tnodes.reverse()\n// \tfor (let i of nodes) {\n// \t\tDOM.Node.prototype.appendChild.call(tempFragment, i)\n// \t}\n// \tif (node.firstChild) {\n// \t\tDOM.Node.prototype.insertBefore.call(node, tempFragment, node.firstChild)\n// \t} else {\n// \t\tDOM.Node.prototype.appendChild.call(node, tempFragment)\n// \t}\n// },\n\n// appendTo(node, newNode) {\n// \tDOM.Node.prototype.appendChild.call(newNode, node)\n// },\n\n// prependTo(node, newNode) {\n// \tif (newNode.firstChild) {\n// \t\tDOM.Node.prototype.insertBefore.call(newNode, node, node.firstChild)\n// \t} else {\n// \t\tDOM.Node.prototype.appendChild.call(newNode, node)\n// \t}\n// },\n\n// empty(node) {\n// \tnode.innerHTML = ''\n// },\n\nconst setDOMImpl = sim => assign(DOM, sim)\n\nif (isBrowser) setDOMImpl({Node, document})\n\nexport {DOM, EFFragment, mountingPointStore, setDOMImpl}\n","// Wrap console functions for `[EF]` perfix\nconst strTpl = '[EF] %s'\nconst dbg = {\n\tlog: console.log.bind(console, strTpl),\n\tinfo: console.info.bind(console, strTpl),\n\twarn: console.warn.bind(console, strTpl),\n\terror: console.error.bind(console, strTpl)\n}\n\nexport default dbg\n","import dbg from './debug.js'\n\nconst isBrowser = typeof document !== 'undefined' && typeof Node !== 'undefined'\n\nif (process.env.NODE_ENV !== 'production') {\n\tif (isBrowser) dbg.info('Running in browser mode.')\n\telse dbg.info('Running in non-browser mode, please be sure to set a DOM simulation using `setDOMImpl`.')\n}\n\nexport default isBrowser\n","const shared = {}\n\nexport default shared\n","import {DOM} from './dom-helper.js'\n\n/**\n * @typedef {{bubbles: boolean, cancelable: boolean}} EFEventOptions\n */\n\n/* Get new events that works in all target browsers\n * though a little bit old-fashioned\n */\nconst getEvent = (name, {bubbles, cancelable} = {\n\tbubbles: false,\n\tcancelable: false\n}) => {\n\tconst event = DOM.document.createEvent('CustomEvent')\n\tevent.initEvent(name, bubbles, cancelable)\n\treturn event\n}\n\nexport default getEvent\n","import initBinding from './binding.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {resolvePath} from './resolver.js'\nimport ARR from './utils/array-helper.js'\nimport {DOM, EFFragment} from './utils/dom-helper.js'\nimport getEvent from './utils/event-helper.js'\nimport {mixVal} from './utils/literals-mix.js'\nimport dbg from './utils/debug.js'\n\nconst typeValid = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\n// SVG/MathML tags w/ xlink attributes require specific namespace to work properly\nconst svgNS = 'http://www.w3.org/2000/svg'\nconst mathNS = 'http://www.w3.org/1998/Math/MathML'\nconst xlinkNS = 'http://www.w3.org/1999/xlink'\nconst createByTag = ({tagName, tagContent, attrs, svg}) => {\n\tconst tagType = typeof tagContent\n\n\tif (tagType === 'string') {\n\t\t// Then SVG\n\t\tif (svg) return DOM.document.createElementNS(svgNS, tagContent)\n\t\t// Then MathML\n\t\tif (tagContent.toLowerCase() === 'math') return DOM.document.createElementNS(mathNS, tagContent)\n\t\t// Then custom basic elements\n\t\tif (tagName === tagContent && attrs && attrs.is && typeof attrs.is === 'string') return DOM.document.createElement(tagContent, {is: attrs.is})\n\t\t// Then basic HTMLElements\n\t\treturn DOM.document.createElement(tagContent)\n\t}\n\n\t// Then custom component or class based custom component\n\tif (tagType === 'function') return new tagContent()\n\n\t// Then overriden basic element\n\treturn DOM.document.createElement(tagContent.tag || tagName, {is: tagContent.is})\n}\n\nconst getElement = ({tagName, tagContent, attrs, ref, refs, svg}) => {\n\tconst element = createByTag({tagName, tagContent, attrs, svg})\n\tif (ref) Object.defineProperty(refs, ref, {\n\t\tvalue: element,\n\t\tenumerable: true\n\t})\n\treturn element\n}\n\nconst regTmpl = ({val, ctx, handlers, subscribers, innerData, handler}) => {\n\tif (Array.isArray(val)) {\n\t\tconst [strs, ...exprs] = val\n\t\tconst tmpl = [strs]\n\n\t\tconst _handler = () => handler(mixVal(...tmpl))\n\n\t\ttmpl.push(...exprs.map((item) => {\n\t\t\tconst {dataNode, handlerNode, _key} = initBinding({bind: item, ctx, handlers, subscribers, innerData})\n\t\t\thandlerNode.push(_handler)\n\t\t\treturn {dataNode, _key}\n\t\t}))\n\n\t\treturn _handler\n\t}\n\treturn () => val\n}\n\nconst addValListener = ({ctx, handlers, subscribers, innerData, element, key, expr, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\tconst dispatch = custom && '$dispatch' || 'dispatchEvent'\n\tconst {parentNode, _key} = initBinding({bind: expr, ctx, handlers, subscribers, innerData})\n\tconst _update = () => {\n\t\tinform()\n\t\tif (custom) parentNode[_key] = element.$data.value\n\t\telse parentNode[_key] = element.value\n\t\texec()\n\t}\n\tif (key === 'value') {\n\t\t// Listen to input, keyup and change events in order to work in most browsers.\n\t\telement[addListener]('input', _update, true)\n\t\telement[addListener]('keyup', _update, true)\n\t\telement[addListener]('change', _update, true)\n\t\t// // Remove keyup and change listener if browser supports input event correctly\n\t\t// const removeListener = () => {\n\t\t// \telement.removeEventListener('input', removeListener, true)\n\t\t// \telement.removeEventListener('keyup', _update, true)\n\t\t// \telement.removeEventListener('change', _update, true)\n\t\t// }\n\t\t// element[addListener]('input', removeListener, true)\n\t} else {\n\t\telement[addListener]('change', () => {\n\t\t\t// Trigger change to the element it-self\n\t\t\telement[dispatch](getEvent('ef-change-event'), {bubbles: true, canceoable: false})\n\t\t\tif (element.tagName === 'INPUT' && element.type === 'radio' && element.name !== '') {\n\t\t\t\t// Trigger change to the the same named radios\n\t\t\t\tconst radios = DOM.document.querySelectorAll(`input[name=${element.name}][type=radio]`)\n\t\t\t\tif (radios) {\n\t\t\t\t\tconst selected = ARR.copy(radios)\n\t\t\t\t\tARR.remove(selected, element)\n\n\t\t\t\t\t/* Event triggering could cause unwanted render triggers\n\t\t\t\t\t * no better ways came up at the moment\n\t\t\t\t\t */\n\t\t\t\t\tfor (let i of selected) i.dispatchEvent(getEvent('ef-change-event'))\n\t\t\t\t}\n\t\t\t}\n\t\t}, true)\n\t\t// Use custom event to avoid loops and conflicts\n\t\telement[addListener]('ef-change-event', () => {\n\t\t\tinform()\n\t\t\tif (custom) parentNode[_key] = element.$data.checked\n\t\t\telse parentNode[_key] = element.checked\n\t\t\texec()\n\t\t})\n\t}\n}\n\nconst getAttrHandler = (element, key, custom) => {\n\t// Pass directly to custom component\n\tif (custom) return (val) => {\n\t\telement[key] = val\n\t}\n\n\t// Beautify class name\n\tif (key === 'class') return (val) => {\n\t\tval = `${val}`.replace(/\\s+/g, ' ').trim()\n\t\t// Remove attribute when value is empty\n\t\tif (!val) return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n\n\t// Handle xlink namespace\n\tif (key.indexOf('xlink:') === 0) return (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttributeNS(xlinkNS, key)\n\t\telement.setAttributeNS(xlinkNS, key, val)\n\t}\n\n\treturn (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n}\n\nconst addAttr = ({element, attr, key, ctx, handlers, subscribers, innerData, custom}) => {\n\tif (typeValid(attr)) {\n\t\tif (custom) {\n\t\t\tif (attr === '') element[key] = true\n\t\t\telse element[key] = attr\n\t\t\treturn\n\t\t}\n\t\t// Handle xlink namespace\n\t\tif (key.indexOf('xlink:') === 0) return element.setAttributeNS(xlinkNS, key, attr)\n\t\treturn element.setAttribute(key, attr)\n\t}\n\n\tconst handler = getAttrHandler(element, key, custom)\n\tqueue([regTmpl({val: attr, ctx, handlers, subscribers, innerData, handler})])\n}\n\nconst addProp = ({element, propPath, value, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst keyPath = ARR.copy(propPath)\n\tconst lastKey = keyPath.pop()\n\tif (custom) keyPath.unshift('$data')\n\tconst lastNode = resolvePath(keyPath, element)\n\tif (typeValid(value)) lastNode[lastKey] = value\n\telse {\n\t\tconst handler = (val) => {\n\t\t\tlastNode[lastKey] = val\n\t\t}\n\t\tconst _handler = regTmpl({val: value, ctx, handlers, subscribers, innerData, handler})\n\t\tif (propPath.length === 1 && ((lastKey === 'value' ||\n\t\t\tlastKey === 'checked')) &&\n\t\t\t!value[0]) addValListener({ctx, handlers, subscribers, innerData, element, key: lastKey, expr: value[1], custom})\n\t\tqueue([_handler])\n\t}\n}\n\n\nconst rawHandler = val => val\n\nconst addEvent = ({element, event, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\n\t/*\n\t *  l: listener                 : string\n\t *  m: method                   : string\n\t *  s: stopPropagation          : number/undefined\n\t *  i: stopImmediatePropagation : number/undefined\n\t *  p: preventDefault           : number/undefined\n\t *  h: shiftKey                 : number/undefined\n\t *  a: altKey                   : number/undefined\n\t *  c: ctrlKey                  : number/undefined\n\t *  t: metaKey                  : number/undefined\n\t *  u: capture                  : number/undefined\n\t *  k: keyCodes                 : array/undefined\n\t *  v: value                    : string/array/undefined\n\t */\n\tconst {l, m, s, i, p, h, a, c, t, u, k, v} = event\n\tconst _handler = regTmpl({val: v, ctx, handlers, subscribers, innerData, handler: rawHandler})\n\n\telement[addListener](l, (e) => {\n\t\tif (!!h !== !!e.shiftKey ||\n\t\t\t!!a !== !!e.altKey ||\n\t\t\t!!c !== !!e.ctrlKey ||\n\t\t\t!!t !== !!e.metaKey ||\n\t\t\t(k && k.indexOf(e.which) === -1)) return\n\t\tif (s) e.stopPropagation()\n\t\tif (i) e.stopImmediatePropagation()\n\t\tif (p) e.preventDefault()\n\t\tif (ctx.methods[m]) ctx.methods[m]({e, value: _handler(), state: ctx.state})\n\t\telse if (process.env.NODE_ENV !== 'production') dbg.warn(`Method named '${m}' not found! Value been passed is:`, _handler())\n\t}, !!u)\n}\n\nconst createElement = ({info, ctx, innerData, refs, handlers, subscribers, svg, fragment, custom}) => {\n\tif (fragment) return new EFFragment()\n\n\t/*\n\t *  t: tag       : class | string | int, 0 means fragment\n\t *  a: attr      : object\n\t *  p: prop      : object\n\t *  e: event     : array\n\t *  r: reference : string\n\t */\n\tconst {t, a, p, e, r} = info\n\tconst tagName = t\n\tconst tagContent = ctx.scope[t] || t\n\tconst element = getElement({tagName, tagContent, attrs: a, ref: r, refs, svg})\n\tif (a) for (let key in a) addAttr({element, custom, attr: a[key], key, ctx, handlers, subscribers, innerData})\n\tif (p) for (let [propPath, value] of p) addProp({element, custom, value, propPath, ctx, handlers, subscribers, innerData})\n\tif (e) for (let event of e) addEvent({element, custom, event, ctx, handlers, subscribers, innerData})\n\n\treturn element\n}\n\nexport default createElement\n","import createElement from './element-creator.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {DOM, mountingPointStore} from './utils/dom-helper.js'\nimport defineArr from './utils/dom-arr-helper.js'\nimport ARR from './utils/array-helper.js'\nimport typeOf from './utils/type-of.js'\nimport initBinding from './binding.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst nullComponent = Object.create(null)\n\nconst checkDestroyed = (state) => {\n\tif (!state.$ctx) throw new Error('[EF] This component has been destroyed!')\n}\n\nconst bindTextNode = ({node, ctx, handlers, subscribers, innerData, element}) => {\n\t// Data binding text node\n\tconst textNode = DOM.document.createTextNode('')\n\tconst { dataNode, handlerNode, _key } = initBinding({bind: node, ctx, handlers, subscribers, innerData})\n\tconst handler = () => {\n\t\tconst value = dataNode[_key]\n\t\tif (typeof value === 'undefined') {\n\t\t\ttextNode.textContent = ''\n\t\t\treturn\n\t\t}\n\t\ttextNode.textContent = value\n\t}\n\thandlerNode.push(handler)\n\tqueue([handler])\n\n\t// Append element to the component\n\tDOM.append(element, textNode)\n}\n\nconst updateMountingNode = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst child = children[key]\n\tconst {anchor, node} = child\n\tif (node === value) return\n\n\tvalue = shared.toEFComponent(value)\n\n\tinform()\n\t// Update component\n\tif (node) {\n\t\tif (value === nullComponent) value = null\n\t\telse node.$umount()\n\t}\n\t// Update stored value\n\tchild.node = value\n\tif (value) value.$mount({target: anchor, parent: ctx.state, option: mountOptions.BEFORE, key})\n\texec()\n}\n\nconst updateMountingList = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst {anchor, node} = children[key]\n\tif (ARR.equals(node, value)) return\n\tif (value) value = ARR.copy(value)\n\telse value = []\n\tconst fragment = DOM.document.createDocumentFragment()\n\t// Update components\n\tinform()\n\tif (node) {\n\t\tnode.clear()\n\t\tfor (let item of value) {\n\t\t\titem = shared.toEFComponent(item)\n\n\t\t\tif (item.$ctx.nodeInfo.parent) item.$umount()\n\t\t\tDOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t\t}\n\t} else for (let item of value) DOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t// Update stored value\n\tnode.length = 0\n\tARR.push(node, ...value)\n\t// Append to current component\n\tDOM.after(anchor, fragment)\n\texec()\n}\n\nconst mountingPointUpdaters = [\n\tupdateMountingNode,\n\tupdateMountingList\n]\n\nconst applyMountingPoint = (type, key, tpl) => {\n\tObject.defineProperty(tpl.prototype, key, {\n\t\tget() {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\treturn this.$ctx.children[key].node\n\t\t},\n\t\tset(value) {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\tconst ctx = this.$ctx\n\t\t\tmountingPointUpdaters[type]({ctx, key, value})\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst bindMountingNode = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {anchor}\n\tmountingPointStore.set(anchor, children[key])\n\tif (isFragment) DOM.append(ctx.safeZone, anchor)\n}\n\nconst bindMountingList = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {\n\t\tnode: defineArr([], {ctx, key, anchor}),\n\t\tanchor\n\t}\n\tmountingPointStore.set(anchor, children[key])\n\tif (isFragment) DOM.append(ctx.safeZone, anchor)\n}\n\n// Walk through the AST to perform proper actions\nconst resolveAST = ({node, nodeType, element, ctx, innerData, refs, handlers, subscribers, svg, create}) => {\n\tif (node instanceof DOM.Node) {\n\t\tDOM.append(element, node)\n\t\treturn\n\t}\n\tswitch (nodeType) {\n\t\t// Static text node\n\t\tcase 'string': {\n\t\t\tDOM.append(element, DOM.document.createTextNode(node))\n\t\t\tbreak\n\t\t}\n\t\t// Child element or a dynamic text node\n\t\tcase 'array': {\n\t\t\t// Recursive call for child element\n\t\t\tif (typeOf(node[0]) === 'object') DOM.append(element, create({node, ctx, innerData, refs, handlers, subscribers, svg}))\n\t\t\t// Dynamic text node\n\t\t\telse bindTextNode({node, ctx, handlers, subscribers, innerData, element})\n\t\t\tbreak\n\t\t}\n\t\t// Mounting points\n\t\tcase 'object': {\n\t\t\tconst anchor = DOM.document.createTextNode('')\n\t\t\t// Single node mounting point\n\t\t\tif (node.t === 0) bindMountingNode({ctx, key: node.n, anchor})\n\t\t\t// Multi node mounting point\n\t\t\telse bindMountingList({ctx, key: node.n, anchor})\n\t\t\t// Append anchor\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, DOM.document.createComment(`EF MOUNTING POINT '${node.n}' START`))\n\t\t\tDOM.append(element, anchor)\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, DOM.document.createComment(`EF MOUNTING POINT '${node.n}' END`))\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t}\n}\n\n// Create elements based on description from AST\nconst create = ({node, ctx, innerData, refs, handlers, subscribers, svg}) => {\n\tconst [info, ...childNodes] = node\n\tconst fragment = info.t === 0\n\tconst custom = Object.isPrototypeOf.call(shared.EFBaseComponent, ctx.scope[info.t] || info.t)\n\t// Enter SVG mode\n\tif (!fragment && !svg && !custom && info.t.toLowerCase() === 'svg') svg = true\n\t// First create an element according to the description\n\tconst element = createElement({info, ctx, innerData, refs, handlers, subscribers, svg, fragment, custom})\n\tif (fragment && process.env.NODE_ENV !== 'production') element.append(DOM.document.createComment('EF FRAGMENT START'))\n\n\t// Leave SVG mode if tag is `foreignObject`\n\tif (svg && info.t.toLowerCase() === 'foreignobject') svg = false\n\n\t// Append child nodes\n\tfor (let node of childNodes) {\n\t\tif (node instanceof shared.EFBaseComponent) node.$mount({target: element})\n\t\telse resolveAST({node, nodeType: typeOf(node), element, ctx, innerData, refs, handlers, subscribers, svg, create})\n\t}\n\tif (fragment && process.env.NODE_ENV !== 'production') element.append(DOM.document.createComment('EF FRAGMENT END'))\n\n\treturn element\n}\n\nexport {create, nullComponent, checkDestroyed, applyMountingPoint}\n","import {DOM} from './dom-helper.js'\nimport ARR from './array-helper.js'\nimport {inform, exec} from '../render-queue.js'\nimport shared from './global-shared.js'\n\nconst DOMARR = {\n\tempty() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$destroy()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tclear() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$umount()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tpop() {\n\t\tif (this.length === 0) return\n\t\tconst poped = ARR.pop(this)\n\t\tpoped.$umount()\n\t\treturn poped\n\t},\n\tpush({ctx, key, anchor}, ...items) {\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tif (this.length === 0) DOM.after(anchor, ...elements)\n\t\telse DOM.after(this[this.length - 1].$ctx.nodeInfo.placeholder, ...elements)\n\t\texec()\n\t\treturn ARR.push(this, ...items)\n\t},\n\tremove(item) {\n\t\tif (this.indexOf(item) === -1) return\n\t\titem.$umount()\n\t\treturn item\n\t},\n\treverse({ctx, key, anchor}) {\n\t\tif (this.length === 0) return this\n\t\tconst tempArr = ARR.copy(this)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i = tempArr.length - 1; i >= 0; i--) {\n\t\t\ttempArr[i].$umount()\n\t\t\tARR.push(elements, tempArr[i].$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...ARR.reverse(tempArr))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tshift() {\n\t\tif (this.length === 0) return\n\t\tconst shifted = ARR.shift(this)\n\t\tshifted.$umount()\n\t\treturn shifted\n\t},\n\tsort({ctx, key, anchor}, fn) {\n\t\tif (this.length === 0) return this\n\t\tconst sorted = ARR.copy(ARR.sort(this, fn))\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of sorted) {\n\t\t\ti.$umount()\n\t\t\tARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...sorted)\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tsplice(...args) {\n\t\tif (this.length === 0) return this\n\t\tconst spliced = ARR.splice(ARR.copy(this), ...args)\n\t\tinform()\n\t\tfor (let i of spliced) i.$umount()\n\t\texec()\n\t\treturn spliced\n\t},\n\tunshift({ctx, key, anchor}, ...items) {\n\t\tif (this.length === 0) return this.push(...items).length\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn ARR.unshift(this, ...items)\n\t}\n}\n\nconst defineArr = (arr, info) => {\n\tObject.defineProperties(arr, {\n\t\tempty: {value: DOMARR.empty},\n\t\tclear: {value: DOMARR.clear},\n\t\tpop: {value: DOMARR.pop},\n\t\tpush: {value: DOMARR.push.bind(arr, info)},\n\t\tremove: {value: DOMARR.remove},\n\t\treverse: {value: DOMARR.reverse.bind(arr, info)},\n\t\tshift: {value: DOMARR.shift},\n\t\tsort: {value: DOMARR.sort.bind(arr, info)},\n\t\tsplice: {value: DOMARR.splice},\n\t\tunshift: {value: DOMARR.unshift.bind(arr, info)}\n\t})\n\treturn arr\n}\n\nexport default defineArr\n","const getGetter = ({base, key}, {checkTrue, get, set}) => {\n\tif (get) {\n\t\tif (!set) throw new Error('[EF] Setter must be defined when getter exists')\n\t\treturn get\n\t}\n\n\tif (checkTrue) return function() {\n\t\treturn checkTrue(base(this)[key], this)\n\t}\n\n\treturn function() {\n\t\treturn base(this)[key]\n\t}\n}\n\nconst getSetter = ({base, key}, {checkTrue, trueVal, falseVal, get, set}) => {\n\tif (set) {\n\t\tif (!get) throw new Error('[EF] Getter must be defined when setter exists')\n\t\treturn set\n\t}\n\n\tif (checkTrue) return function(val) {\n\t\tconst baseNode = base(this)\n\t\tconst _trueVal = trueVal\n\t\tconst _falseVal = falseVal\n\n\t\tif (typeof trueVal !== 'function') trueVal = () => _trueVal\n\t\tif (typeof falseVal !== 'function') falseVal = () => _falseVal\n\n\t\tif (val) baseNode[key] = trueVal(this)\n\t\telse baseNode[key] = falseVal(this)\n\t}\n\n\treturn function(val) {\n\t\tbase(this)[key] = val\n\t}\n}\n\nconst defaultRoot = state => state.$data\nconst getBase = (root) => {\n\tif (!root) return defaultRoot\n\tif (typeof root === 'function') return root\n\tif (typeof root === 'string') root = root.split('.')\n\treturn (base) => {\n\t\tfor (let key of root) base = base[key]\n\t\treturn base\n\t}\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n/**\n * Definition of an attribute mapping\n * @typedef {Object} AttrDef\n * @property {string=} key - key to be accessed on base, default to `attr`\n * @property {Function=} base - a function that returns the base of the key, default returns $data\n * @property {bool=} checkTrue - a function returns true or false based on input value\n * @property {*=} trueVal - value when true, only used when checkTrue is set\n * @property {*=} falseVal - value when false, only used when checkTrue is set\n * @property {Function=} get - getter, will ignore all other settings except set\n * @property {Function=} set - setter, will ignore all other settings except get\n */\n\n/**\n * Data to attribute mapping helper\n * @template {EFBaseClass} T\n * @param {T} tpl - Component class to be mapped\n * @param {Object.<string,AttrDef>} attrMap - Attributes to be mapped\n * @returns {T} - Mapped component class\n */\nconst mapAttrs = (tpl, attrMap) => {\n\tfor (let attr in attrMap) {\n\t\tconst options = attrMap[attr]\n\n\t\tconst base = getBase(options.base)\n\t\tconst key = options.key || attr\n\n\t\tconst basicProperty = {base, key}\n\n\t\tconst get = getGetter(basicProperty, options)\n\t\tconst set = getSetter(basicProperty, options)\n\n\t\tObject.defineProperty(tpl.prototype, attr, {\n\t\t\tget,\n\t\t\tset,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false\n\t\t})\n\t}\n\n\treturn tpl\n}\n\nexport default mapAttrs\n","/**\n * @typedef {string} EFMountOption\n * @typedef {{BEFORE: EFMountOption, AFTER: EFMountOption, APPEND: EFMountOption, REPLACE: EFMountOption}} EFMountConfig\n */\n\n/**\n * @type {EFMountConfig}\n */\nconst mountOptions = {\n\tBEFORE: 'before',\n\tAFTER: 'after',\n\tAPPEND: 'append',\n\tREPLACE: 'replace'\n}\n\nexport default mountOptions\n","import {create, nullComponent, checkDestroyed} from './creator.js'\nimport initBinding from './binding.js'\nimport {queueDom, inform, exec} from './render-queue.js'\nimport {resolveSubscriber} from './resolver.js'\nimport mapAttrs from './map-attrs.js'\nimport {DOM, EFFragment, mountingPointStore} from './utils/dom-helper.js'\nimport ARR from './utils/array-helper.js'\nimport {assign, legacyAssign} from './utils/polyfills.js'\nimport isInstance from './utils/fast-instance-of.js'\nimport typeOf from './utils/type-of.js'\nimport {enumerableFalse} from './utils/buble-fix.js'\nimport dbg from './utils/debug.js'\nimport getEvent from './utils/event-helper.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst unsubscribe = (pathStr, fn, subscribers) => {\n\tconst subscriberNode = resolveSubscriber(pathStr, subscribers)\n\tARR.remove(subscriberNode, fn)\n}\n\n/**\n * @typedef {Array} EFAST\n * @typedef {Object.<string,EFBaseComponent>} EFTemplateScope\n */\n\n/**\n * @typedef {Object} EFSubscriberHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been subscribed\n */\n\n/**\n * @event Event\n */\n\n/**\n * @typedef {Object} EFEventHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been passed to the event handler\n * @property {Event} event - Event object that has been triggered\n */\n\n/**\n * @typedef {Function} EFSubscriberHandlerMethod\n * @param {EFSubscriberHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * @typedef {Function} EFEventHandlerMethod\n * @param {EFEventHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * The very basic ef component\n * @class EFBaseComponent\n * @param {EFAST} ast - ast for the component\n * @param {EFTemplateScope} scope - scope which contains custom components\n * @private {Object} $ctx - Inner component data, DO NOT TOUCH\n * @property {Object} $data - Data on component\n * @property {Object.<string,EFEventHandlerMethod>} $methods - Methods on component\n * @property {Object.<string,(EFBaseComponent|Node)>} $refs - References on component\n */\nconst EFBaseComponent = class {\n\n\t/**\n\t * Create an EFBaseComponent with ef AST\n\t * @param {EFAST} ast - ast for the component\n\t * @param {EFTemplateScope=} scope - scope which contains custom components\n\t */\n\tconstructor(ast, scope = {}) {\n\t\tconst children = {}\n\t\tconst refs = {}\n\t\tconst data = {}\n\t\tconst innerData = {}\n\t\tconst methods = {}\n\t\tconst handlers = {}\n\t\tconst subscribers = {}\n\t\tconst nodeInfo = {\n\t\t\tplaceholder: null,\n\t\t\treplace: [],\n\t\t\tparent: null,\n\t\t\tkey: null\n\t\t}\n\n\t\t/* Detatched components will be put in the safe zone.\n\t\t * Split safe zone to each component in order to make\n\t\t * the component memory recycleable when lost reference\n\t\t */\n\t\tconst safeZone = DOM.document.createDocumentFragment()\n\n\t\tif (process.env.NODE_ENV === 'production') nodeInfo.placeholder = DOM.document.createTextNode('')\n\t\telse nodeInfo.placeholder = DOM.document.createComment('EF COMPONENT PLACEHOLDER')\n\n\t\tconst mount = () => {\n\t\t\tif (nodeInfo.replace.length > 0) {\n\t\t\t\tfor (let i of nodeInfo.replace) DOM.remove(i)\n\t\t\t\tARR.empty(nodeInfo.replace)\n\t\t\t}\n\t\t\tDOM.before(nodeInfo.placeholder, nodeInfo.element)\n\t\t}\n\n\t\tconst ctx = {\n\t\t\tscope, mount, refs, data, innerData, methods,\n\t\t\thandlers, subscribers, nodeInfo, safeZone,\n\t\t\tchildren, state: this, isFragment: ast[0].t === 0\n\t\t}\n\n\t\tObject.defineProperty(this, '$ctx', {\n\t\t\tvalue: ctx,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true\n\t\t})\n\n\t\tinform()\n\n\t\tnodeInfo.element = create({node: ast, ctx, innerData, refs, handlers, subscribers, svg: false})\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\texec()\n\t}\n\n\tget $data() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.data\n\t}\n\n\tset $data(newData) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tassign(this.$ctx.data, newData)\n\t\texec()\n\t}\n\n\tget $methods() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.methods\n\t}\n\n\n\tset $methods(newMethods) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.methods = newMethods\n\t}\n\n\tget $refs() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.refs\n\t}\n\n\t/**\n\t * @typedef {import('../mount-options.js').EFMountConfig} EFMountConfig\n\t */\n\n\t/**\n\t * Mount component to a specitic position\n\t * @param {EFMountConfig} config - Mount contigurations\n\t * @returns {number} - Render count down\n\t */\n\t$mount({target, option, parent, key}) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, mount } = this.$ctx\n\t\tif (typeof target === 'string') target = document.querySelector(target)\n\n\t\tinform()\n\t\tif (nodeInfo.parent) {\n\t\t\tthis.$umount()\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn('Component detached from previous mounting point.')\n\t\t}\n\n\t\tif (!parent) parent = target\n\t\tif (!key) key = '__DIRECTMOUNT__'\n\t\tnodeInfo.parent = parent\n\t\tnodeInfo.key = key\n\t\tqueueDom(mount)\n\n\t\tif (!target) {\n\t\t\texec()\n\t\t\treturn nodeInfo.placeholder\n\t\t}\n\n\t\tswitch (option) {\n\t\t\tcase mountOptions.BEFORE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.AFTER: {\n\t\t\t\tDOM.after(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.REPLACE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tnodeInfo.replace.push(target)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.APPEND:\n\t\t\tdefault: {\n\t\t\t\t// Parent is EFFragment should only happen when using jsx\n\t\t\t\tif (isInstance(parent, EFFragment)) DOM.append(target, nodeInfo.element)\n\t\t\t\telse DOM.append(target, nodeInfo.placeholder)\n\t\t\t}\n\t\t}\n\t\treturn exec()\n\t}\n\n\t/**\n\t * @returns {number} - Render count down\n\t */\n\t$umount() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, safeZone, mount } = this.$ctx\n\t\tconst { parent, key } = nodeInfo\n\t\tnodeInfo.parent = null\n\t\tnodeInfo.key = null\n\n\t\tinform()\n\t\tif (parent) {\n\t\t\tif (key !== '__DIRECTMOUNT__') {\n\t\t\t\tif (parent[key]) {\n\t\t\t\t\tif (Array.isArray(parent[key])) {\n\t\t\t\t\t\t// Remove self from parent list mounting point\n\t\t\t\t\t\tARR.remove(parent[key], this)\n\t\t\t\t\t} else parent[key] = nullComponent\n\t\t\t\t}\n\t\t\t// Else Remove elements from fragment parent\n\t\t\t} else if (isInstance(parent, EFFragment)) parent.$ctx.nodeInfo.element.removeChild(nodeInfo.element)\n\t\t}\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\treturn exec()\n\t}\n\n\t/**\n\t * Subscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be added\n\t * @returns {void}\n\t */\n\t$subscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst ctx = this.$ctx\n\t\tconst { handlers, subscribers, innerData } = ctx\n\t\tconst _path = pathStr.split('.')\n\t\tconst { dataNode, subscriberNode, _key } = initBinding({bind: [_path], ctx, handlers, subscribers, innerData})\n\t\tinform()\n\t\t// Execute the subscriber function immediately\n\t\ttry {\n\t\t\tsubscriber({state: this, value: dataNode[_key]})\n\t\t\t// Put the subscriber inside the subscriberNode\n\t\t\tsubscriberNode.push(subscriber)\n\t\t} catch (e) {\n\t\t\tdbg.error('Error caught when registering subscriber:\\n', e)\n\t\t}\n\t\texec()\n\t}\n\n\t/**\n\t * Unsubscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be removed\n\t * @returns {void}\n\t */\n\t$unsubscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { subscribers } = this.$ctx\n\t\tunsubscribe(pathStr, subscriber, subscribers)\n\t}\n\n\t/**\n\t * Update the component's state with a new state\n\t * @param {Object} newState - New state to be set on this component\n\t * @returns {void}\n\t */\n\t$update(newState) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tlegacyAssign(this, newState)\n\t\texec()\n\t}\n\n\t/**\n\t * Fire a custom event using an Event object on this component\n\t * @param {Event} event - Event object to be dispatched on this component\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$dispatch(event) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.dispatchEvent(event)\n\t}\n\n\t/**\n\t * @typedef {import('./utils/event-helper.js').EFEventOptions} EFEventOptions\n\t */\n\n\t/**\n\t * Fire a custom event using event name on this component\n\t * @param {string} eventName - Name of the custom event\n\t * @param {EFEventOptions} options - Event Options\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$emit(eventName, options) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$dispatch(getEvent(eventName, options))\n\t}\n\n\t/**\n\t * Add custom event listener on this component\n\t * @param {...*} args - Same as Node.addEventListener\n\t * @returns {*} - Same as the return of Node.addEventListener\n\t */\n\t$on(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.addEventListener(...args)\n\t}\n\n\t/**\n\t * Remove custom event listener on this component\n\t * @param {...*} args - Same as Node.removeEventListener\n\t * @returns {*} - Same as the return of Node.removeEventListener\n\t */\n\t$off(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.removeEventListener(...args)\n\t}\n\n\t/**\n\t * Destroy this component\n\t * @returns {number} - Render count down\n\t */\n\t$destroy() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, children } = this.$ctx\n\t\tinform()\n\t\tthis.$umount()\n\t\tfor (let i in children) mountingPointStore.delete(children[i].anchor)\n\t\t// Detatch all mounted components\n\t\tfor (let i in this) {\n\t\t\tif (typeOf(this[i]) === 'array') this[i].clear()\n\t\t\telse this[i] = null\n\t\t}\n\t\t// Remove context\n\t\tdelete this.$ctx\n\t\t// Push DOM removement operation to query\n\t\tqueueDom(() => {\n\t\t\tDOM.remove(nodeInfo.element)\n\t\t\tDOM.remove(nodeInfo.placeholder)\n\t\t})\n\t\t// Render\n\t\treturn exec()\n\t}\n}\n\n/**\n * @typedef {typeof EFBaseComponent} EFBaseClass\n */\n\nconst fragmentAST = [{t: 0}]\n\n/**\n * ef component node wrapper\n * Better using this than Fragments if wrapping only HTML elements.\n * @class EFNodeWrapper\n * @extends EFBaseComponent\n * @param {...Node} nodes - Nodes to be wrapped\n * @property {Array<Node>} - Nodes that are wrapped\n */\nconst EFNodeWrapper = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given nodes into an ef component\n\t * @param  {...Node} nodes - Nodes to be wrapped\n\t */\n\tconstructor(...nodes) {\n\t\tsuper(fragmentAST)\n\n\t\tconst element = this.$ctx.nodeInfo.element\n\t\tconst childrenArr = element.$children\n\t\telement.append(...nodes)\n\n\t\tif (process.env.NODE_ENV !== 'production') element.append(ARR.remove(childrenArr, childrenArr[1]))\n\n\t\tthis.$ctx.elements = nodes\n\t}\n\n\tget $el() {\n\t\treturn this.$ctx.elements\n\t}\n}\n\n/**\n * Component fragment wrapper\n * @class Fragment\n * @extends EFBaseComponent\n * @param {...*} children - Things to be wrapped into an ef component\n */\nconst Fragment = class extends EFBaseComponent {\n\tconstructor(...children) {\n\t\tsuper([{t: 0}, ...children])\n\t}\n}\n\nconst textFragmentAst = [{t: 0},[['text']]]\n\n/**\n * ef component text wrapper\n * @class EFTextFragment\n * @extends EFBaseComponent\n * @param {string} text - String to be wrapped\n * @property {string} text - Text on the fragment component\n */\nconst EFTextFragment = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given text into an ef component\n\t * @param {string} text - String to be wrapped\n\t */\n\tconstructor(text) {\n\t\tinform()\n\t\tsuper(textFragmentAst)\n\t\tthis.text = text\n\t\texec()\n\t}\n}\nmapAttrs(EFTextFragment, {text: {}})\n\nenumerableFalse(EFBaseComponent, ['$mount', '$umount', '$subscribe', '$unsubscribe', '$update', '$dispatch', '$emit', '$on', '$off', '$destroy'])\nenumerableFalse(EFNodeWrapper, ['$el'])\n\n/**\n * Transform almost anyting into ef component\n * @template {value} T\n * @param {T} value - Things to be transformed into ef component\n * @returns {(EFNodeWrapper|EFTextFragment|T)} - Wrapped component or value it self if not supports converting\n */\nconst toEFComponent = (value) => {\n\tif (value === null || typeof value === 'undefined' || value instanceof EFBaseComponent) return value\n\n\tif (value !== nullComponent) {\n\t\tif (value instanceof Node) return new EFNodeWrapper(value)\n\t\telse if (typeof value === 'string') return new EFTextFragment(value)\n\t\telse return new EFTextFragment(JSON.stringify(value))\n\t}\n}\n\nshared.EFBaseComponent = EFBaseComponent\nshared.toEFComponent = toEFComponent\n\nexport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent}\n","import {EFBaseComponent, Fragment, toEFComponent} from './renderer.js'\nimport {assign} from './utils/polyfills.js'\n\nconst flatten = (prev, item) => {\n\tif (Array.isArray(item)) prev.push(...item.map(toEFComponent))\n\telse prev.push(toEFComponent(item))\n\n\treturn prev\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseComponent} EFBaseComponent\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create ef component from JSX\n * @template {EFBaseClass} T\n * @param {(string|T)} tag - JSX tag\n * @param {Object.<string,*>} attrs - JSX attributes\n * @param  {...*} children - JSX children\n * @returns {(EFBaseComponent|T extends {new (...args: any): infer R} ? R : never)} ef component created from JSX\n */\nconst createElement = (tag, attrs, ...children) => {\n\t// Create special component for fragment\n\tif (tag === Fragment) return new Fragment(...children)\n\n\t// Create an instance if tag is an ef class\n\tif (Object.isPrototypeOf.call(EFBaseComponent, tag)) {\n\t\tif (children.length <= 0) return new tag(attrs)\n\t\treturn new tag(assign({children: children.reduce(flatten, [])}, attrs || {}))\n\t}\n\n\t// Else return the generated basic component\n\t// Transform all label only attributes to ef-supported style\n\tconst transformedAttrs = assign({}, attrs)\n\tfor (let i in transformedAttrs) {\n\t\tif (transformedAttrs[i] === true) transformedAttrs[i] = ''\n\t}\n\n\treturn new EFBaseComponent([\n\t\t{\n\t\t\tt: tag,\n\t\t\ta: transformedAttrs\n\t\t},\n\t\t...children\n\t])\n}\n\nexport default createElement\n","// Import everything\nimport parse from './lib/parser.js'\nimport typeOf from 'ef-core/src/lib/utils/type-of.js'\nimport { mixStr } from 'ef-core/src/lib/utils/literals-mix.js'\nimport parseEft from 'eft-parser'\nimport { version } from '../package.json'\n// Import core components\nimport {\n\tcreate as createComponent,\n\tcreateElement,\n\tmapAttrs,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tsetDOMImpl,\n\tmountOptions\n} from 'ef-core'\n\n// Set parser\nlet parser = parseEft\n\n/**\n * @typedef {import('ef-core/src/ef-core.js').EFMountOption} EFMountOption\n * @typedef {import('ef-core/src/ef-core.js').EFMountConfig} EFMountConfig\n * @typedef {import('ef-core/src/ef-core.js').EFAST} EFAST\n * @typedef {import('ef-core/src/ef-core.js').EFBaseClass} EFBaseClass\n * @typedef {import('ef-core/src/ef-core.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('ef-core/src/ef-core.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('ef-core/src/ef-core.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('ef-core/src/ef-core.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('ef-core/src/ef-core.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('ef-core/src/ef-core.js').Fragment} Fragment\n * @typedef {import('ef-core/src/ef-core.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('ef-core/src/ef-core.js').EFTextFragment} EFTextFragment\n * @typedef {import('ef-core/src/ef-core.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Return a brand new class for the new component\n * @param {string|EFAST} value - Template or AST for the component\n */\nconst create = (value) => {\n\tconst valType = typeOf(value)\n\tif (valType === 'string') value = parse(value, parser)\n\telse if (valType !== 'array') throw new TypeError('Cannot create new component without proper template or AST!')\n\n\treturn createComponent(value)\n}\n\n/**\n * Change parser\n * @param {Function} newParser - Parser you want to change with\n * @returns {void}\n */\nconst setParser = (newParser) => {\n\tparser = newParser\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Tagged template to quickly create an inline ef component class\n * @param {...*} args - String literal\n */\nconst t = (...args) => create(mixStr(...args))\n\nexport {\n\tt,\n\tcreate,\n\tcreateElement,\n\tmapAttrs,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tsetParser,\n\tparseEft,\n\tmountOptions,\n\tsetDOMImpl,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') console.info(`[EF] ef.js v${version} initialized!`)\n","// Import everything\nimport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent} from './lib/renderer.js'\nimport {applyMountingPoint} from './lib/creator.js'\nimport mountOptions from './mount-options.js'\nimport createElement from './lib/jsx-create-element.js'\nimport mapAttrs from './lib/map-attrs.js'\nimport {onNextRender, inform, exec, bundle, isPaused} from './lib/render-queue.js'\nimport dbg from './lib/utils/debug.js'\nimport typeOf from './lib/utils/type-of.js'\nimport scoped from './lib/utils/scoped-component.js'\nimport {setDOMImpl} from './lib/utils/dom-helper.js'\nimport {version} from '../package.json'\n\n// Apply mounting point properties for classes\nconst applyMountingPoints = (node, tpl) => {\n\tconst nodeType = typeOf(node)\n\tswitch (nodeType) {\n\t\tcase 'array': {\n\t\t\tconst [info, ...childNodes] = node\n\t\t\tif (typeOf(info) === 'object') for (let i of childNodes) applyMountingPoints(i, tpl)\n\t\t\tbreak\n\t\t}\n\t\tcase 'object': {\n\t\t\tif (node.t > 1) throw new TypeError(`[EF] Not a standard ef.js AST: Unknown mounting point type '${node.t}'`)\n\t\t\tapplyMountingPoint(node.t, node.n, tpl)\n\t\t\tbreak\n\t\t}\n\t\tcase 'string': {\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new TypeError(`[EF] Not a standard ef.js AST: Unknown node type '${nodeType}'`)\n\t\t}\n\t}\n}\n\n/**\n * @typedef {import('./mount-options.js').EFMountOption} EFMountOption\n * @typedef {import('./mount-options.js').EFMountConfig} EFMountConfig\n * @typedef {import('./lib/renderer.js').EFAST} EFAST\n * @typedef {import('./lib/renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('./lib/renderer.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('./lib/renderer.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('./lib/renderer.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('./lib/renderer.js').Fragment} Fragment\n * @typedef {import('./lib/renderer.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('./lib/renderer.js').EFTextFragment} EFTextFragment\n * @typedef {import('./lib/utils/event-helper.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create a brand new component class for the new component\n * @param {EFAST} ast - AST for the component\n */\nconst create = (ast) => {\n\n\t/**\n\t * The very basic component which users can use\n\t * @class EFComponent\n\t * @param {Object=} initState - Initial state for the component to create with\n\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t */\n\tconst EFComponent = class extends EFBaseComponent {\n\n\t\t/**\n\t\t * Create an EFComponent with initial state\n\t\t * @param {Object=} initState - Initial state for the component to create with\n\t\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t\t */\n\t\tconstructor(initState, scope) {\n\t\t\tinform()\n\t\t\tsuper(ast, scope)\n\t\t\tif (initState) this.$update(initState)\n\t\t\texec()\n\t\t}\n\t}\n\tapplyMountingPoints(ast, EFComponent)\n\n\t// Workaround for a bug of buble\n\t// https://github.com/bublejs/buble/issues/197\n\tObject.defineProperty(EFComponent.prototype, 'constructor', {enumerable: false})\n\treturn EFComponent\n}\n\nexport {\n\tcreate,\n\tmapAttrs,\n\tcreateElement,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\ttoEFComponent,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tmountOptions,\n\tsetDOMImpl,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') dbg.info(`ef-core v${version} initialized!`)\n","import eftParser from 'eft-parser'\n\nconst parse = (template, parser) => {\n\tif (!parser) parser = eftParser\n\treturn parser(template)\n}\n\nexport default parse\n","import {assign} from './polyfills.js'\n\n/**\n * @typedef {import('../renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('../renderer.js').EFTemplateScope} EFTemplateScope\n */\n\n/**\n * Attach a default scope to the component class\n * @template {component} T\n * @param {EFBaseClass} component - Component class to be scoped\n * @param {EFTemplateScope} initScope - Scope to be bond on the component class\n * @returns {T} - Scoped component class\n */\nconst scoped = (component, initScope) => class extends component {\n\tconstructor(state, scope = {}) {\n\t\tconst _scope = assign({}, initScope)\n\t\tsuper(state, assign(_scope, scope))\n\t}\n}\n\nexport default scoped\n"],"names":["O2C","SyntaxError","UC2C","val","substr","length","parseInt","String","fromCodePoint","err","U2C","substring","fromCharCode","X2C","efEscape","string","const","escaped","split","doubleChar","let","escapedStr","replace","oct","ucp","uni","hex","b","t","n","v","f","r","esc","push","join","char","splitWith","escapedSplit","i","splitBy","splitArr","shift","getErrorMsg","msg","line","checkValidType","obj","indexOf","ESCAPE","parsed","JSON","parse","e","splitDefault","slice","pathArr","_path","trim","map","_default","defaultVal","splitLiterals","strs","mustache","tmpl","mustaches","match","pushStr","textArr","str","parseText","result","exprs","dotToSpace","getOption","options","keys","option","keyCode","isNaN","s","p","h","a","c","u","console","warn","setOption","parseLine","parsingInfo","offset","offsetReg","trimmedLine","removed","prevDepth","removeOffset","indentReg","spaces","spaceIndent","RegExp","getIndent","content","escapedName","splitted","tagInfo","depth","test","getDepth","prevType","topExists","type","currentNode","ast","resolveDepth","info","hashref","ref","tag","class","newNode","name","value","propPath","l","listener","ops","k","getEventOptions","m","method","_value","reserved","parseEft","template","TypeError","tplType","lines","Array","isArray","Object","hasOwnProperty","call","typeOf","mixStr","getVal","data","proto","prototype","ARR","copy","arr","empty","equals","left","right","pop","apply","items","remove","item","index","splice","reverse","rightUnique","newArr","j","sort","fn","args","unshift","Set","from","unique","queue","handlers","modificationQueue","queueDom","handler","domQueue","inform","count","execUserQueue","userQueue","userFnQueue","exec","immediate","renderQueue","execModifications","domRenderQueue","execDomModifications","setTimeout","legacyAssign","ee","er","defineNode","key","node","defineProperty","get","set","assign","configurable","enumerable","resolve","parentNode","resolveReactivePath","subscribers","innerData","handlerNode","subscriberNode","dataNode","resolveAllPath","_key","undefined","isnan","initBinding","subscriberExecuting","bind","ctx","subscriber","state","dbg","error","isInstance","constructor","enumerableFalse","classObj","prepareArgs","self","appendNode","tempFragment","$ctx","nodeInfo","DOM","append","element","placeholder","handleMountingPoint","nodeType","mountingPoint","mountingPointStore","strTpl","log","isBrowser","document","Node","shared","WeakMap","EFFragment","this","$children","$safeZone","createDocumentFragment","appendTo","removeChild","before","nodes","EFBaseComponent","$mount","target","appendChild","insertBefore","after","nextSibling","children","toEFComponent","$umount","setDOMImpl","sim","getEvent","bubbles","cancelable","event","createEvent","initEvent","typeValid","getElement","tagType","tagName","tagContent","attrs","svg","createElementNS","toLowerCase","is","createElement","refs","regTmpl","_handler","addAttr","attr","custom","setAttributeNS","xlinkNS","setAttribute","removeAttribute","removeAttributeNS","addProp","keyPath","lastKey","addListener","dispatch","lastNode","resolvePath","expr","_update","canceoable","radios","querySelectorAll","selected","dispatchEvent","$data","checked","rawHandler","addEvent","shiftKey","altKey","ctrlKey","metaKey","which","stopPropagation","stopImmediatePropagation","preventDefault","methods","bindTextNode","textNode","textContent","createTextNode","bindMountingList","anchor","defineProperties","DOMARR","clear","isFragment","safeZone","resolveAST","create","getGetter","Error","checkTrue","base","getSetter","baseNode","_trueVal","trueVal","_falseVal","falseVal","defaultRoot","getBase","root","mapAttrs","tpl","attrMap","basicProperty","$destroy","poped","elements","parent","tempArr","shifted","sorted","spliced","mountOptions","BEFORE","AFTER","APPEND","REPLACE","nullComponent","mountingPointUpdaters","child","fragment","isPrototypeOf","scope","childNodes","mount","prototypeAccessors","newData","$methods","newMethods","$refs","querySelector","$subscribe","pathStr","$unsubscribe","resolveSubscriber","$update","newState","$dispatch","$emit","eventName","$on","addEventListener","$off","removeEventListener","delete","fragmentAST","EFNodeWrapper","super","prototypeAccessors$1","$el","Fragment","textFragmentAst","EFTextFragment","text","stringify","flatten","prev","EFComponent","valType","parser","eftParser","applyMountingPoints","initState","cb","reduce","transformedAttrs","component","initScope","_scope","newParser"],"mappings":"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"}
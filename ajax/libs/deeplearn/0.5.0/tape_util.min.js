"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var util=require("./util"),tensor_1=require("./tensor");function getFilteredNodesXToY(t,r,e){for(var n={},o={},i=0;i<r.length;i++)n[r[i].id]=!0;for(i=0;i<t.length;i++){var u=(T=t[i]).inputAndArgs.inputs;for(var s in u){for(var a=u[s],p=!1,d=0;d<r.length;d++)if(n[a.id]){if(T.output instanceof tensor_1.Tensor)n[T.output.id]=!0;else for(var f=0,l=Object.keys(T.output);f<l.length;f++){var c=l[f];n[T.output[c].id]=!0}p=!0,o[T.id]=!0;break}if(p)break}}var g={};g[e.id]=!0;for(var h={},i=t.length-1;0<=i;i--){var u=(T=t[i]).inputAndArgs.inputs,v=[];if(T.output instanceof tensor_1.Tensor)v.push(T.output);else for(var b=0,A=Object.keys(T.output);b<A.length;b++){c=A[b];v.push(T.output[c])}for(d=0;d<v.length;d++)if(g[v[d].id]){for(var s in u)g[u[s].id]=!0,h[T.id]=!0;break}}for(var T,k=[],i=0;i<t.length;i++){if(o[(T=t[i]).id]&&h[T.id]){var m={};for(var s in T.inputAndArgs.inputs){var F=T.inputAndArgs.inputs[s];n[F.id]&&(m[s]=F)}var _=void 0;if(T.output instanceof tensor_1.Tensor)_=T.output;else for(var x in _={},T.output){g[T.output[x].id]&&(_[x]=T.output[x])}var y=Object.assign({},T);y.inputAndArgs={inputs:m},y.output=_,k.push(y)}}return k}function backpropagateGradients(t,r){for(var e=r.length-1;0<=e;e--){var n=r[e],o=void 0;if(n.output instanceof tensor_1.Tensor)o=t[n.output.id];else{o={};for(var i=0,u=Object.keys(n.output);i<u.length;i++){var s=u[i];o[s]=t[n.output[s].id]}}if(null==n.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+n.name+".");var a=n.gradient(o,n.output);for(var p in n.inputAndArgs.inputs){if(!(p in a))throw new Error("Cannot backprop through input "+p+". Available gradients found: "+Object.keys(a)+".");var d,f=a[p](),l=n.inputAndArgs.inputs[p];if(!util.arraysEqual(f.shape,l.shape))throw new Error("Error in gradient for op "+n.name+". The gradient of input '"+p+"' has shape '"+f.shape+"', which does not match the shape of the input '"+l.shape+"'");null==t[l.id]?t[l.id]=f:(d=t[l.id],t[l.id]=d.add(f),d.dispose())}}}function extractTensorsFromScopeResult(t){if(null==t)return[];if(t instanceof tensor_1.Tensor)return[t];var r=[],e=t;for(var n in e){var o=util.flatten(e[n]).filter(function(t){return t instanceof tensor_1.Tensor});r.push.apply(r,o)}return r}function stripUndefinedInputsFromInputConfig(r){return Object.keys(r.inputs).forEach(function(t){null==r.inputs[t]&&delete r.inputs[t]}),r}exports.getFilteredNodesXToY=getFilteredNodesXToY,exports.backpropagateGradients=backpropagateGradients,exports.extractTensorsFromScopeResult=extractTensorsFromScopeResult,exports.stripUndefinedInputsFromInputConfig=stripUndefinedInputsFromInputConfig;
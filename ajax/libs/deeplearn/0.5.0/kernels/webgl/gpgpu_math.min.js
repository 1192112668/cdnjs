"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var environment_1=require("../../environment"),util=require("../../util"),shader_compiler=require("./shader_compiler"),ATTRIBUTE_NAMES=["uv","clipSpacePos"],NAN_UNIFORM_NAME="NaN";function shouldUploadNaNUniform(){return!environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")}function compileProgram(a,t,e,r){for(var o=t.userCode,n=e.map(function(e,a){var r={logicalShape:e.tensor.shape,texShape:e.texData.texShape};return{name:t.variableNames[a],shapeInfo:r}}),i=n.map(function(e){return e.shapeInfo}),u={logicalShape:r.tensor.shape,texShape:r.texData.texShape},s=shader_compiler.makeShader(n,u,o,!0===t.supportsBroadcasting),p=a.createProgram(s),h={},m=0;m<t.variableNames.length;m++){var c=t.variableNames[m];h[c]=a.getUniformLocation(p,c)}var l={};return ATTRIBUTE_NAMES.forEach(function(e){l[e]=a.getAttributeLocation(p,e)}),shouldUploadNaNUniform()&&(h[NAN_UNIFORM_NAME]=a.getUniformLocation(p,NAN_UNIFORM_NAME,!1)),{program:t,source:s,webGLProgram:p,uniformLocations:h,attributeLocations:l,gpgpu:a,inShapeInfos:i,outShapeInfo:u}}function validateBinaryAndProgram(e,i){if(e.length!==i.length)throw Error("Binary was compiled with "+e.length+" inputs, but was executed with "+i.length+" inputs");e.forEach(function(e,a){var r=e.logicalShape,t=e.texShape,o=i[a].tensor.shape,n=i[a].texData.texShape;if(!util.arraysEqual(r,o))throw Error("Binary was compiled with different shapes than the current args. Shapes "+r+" and "+o+" must match");if(!util.arraysEqual(t,n))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+t+" and "+n+" must match")})}function runProgram(n,e,a,r){validateBinaryAndProgram(n.inShapeInfos,e),validateBinaryAndProgram([n.outShapeInfo],[a]);var t=a.texData.texture,o=a.texData.texShape,i=n.gpgpu;i.setOutputMatrixTexture(t,o[0],o[1]),i.setProgram(n.webGLProgram),e.forEach(function(e,a){var r=e.texData.texture,t=n.program.variableNames[a],o=n.uniformLocations[t];i.setInputMatrixTexture(r,o,a)}),shouldUploadNaNUniform()&&i.gl.uniform1f(n.uniformLocations[NAN_UNIFORM_NAME],NaN),null!=r&&r(i,n.webGLProgram),i.executeProgram(n.attributeLocations)}function makeShaderKey(e,a,r){var t="";a.concat(r).forEach(function(e){t+=e.tensor.shape+"_"+e.texData.texShape});var o=e.userCode,n=(!0===e.supportsBroadcasting).toString(),i=e.constructor.name;return i+="_"+n+"_"+t+"_"+o}exports.compileProgram=compileProgram,exports.runProgram=runProgram,exports.makeShaderKey=makeShaderKey;
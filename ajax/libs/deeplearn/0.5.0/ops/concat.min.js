"use strict";var __decorate=this&&this.__decorate||function(e,t,n,c){var o,r=arguments.length,a=r<3?t:null===c?c=Object.getOwnPropertyDescriptor(t,n):c;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,n,c);else for(var i=e.length-1;0<=i;i--)(o=e[i])&&(a=(r<3?o(a):3<r?o(t,n,a):o(t,n))||a);return 3<r&&a&&Object.defineProperty(t,n,a),a};Object.defineProperty(exports,"__esModule",{value:!0});var doc_1=require("../doc"),environment_1=require("../environment"),util=require("../util"),concat_util=require("./concat_util"),operation_1=require("./operation"),Concat=function(){function n(){}return n.concat1d=function(e){return n.concat(e,0)},n.concat2d=function(e,t){return n.concat(e,t)},n.concat3d=function(e,t){return n.concat(e,t)},n.concat4d=function(e,t){return n.concat(e,t)},n.concat=function(e,t){void 0===t&&(t=0),util.assert(2<=e.length,"Pass at least two tensors to concat");for(var n=e[0],c=1;c<e.length;++c)n=concat2Tensors(n,e[c],t);return n},__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],n,"concat",null),n}();function concat2Tensors(e,t,n){concat_util.assertParams(e.shape,t.shape,n);var c=concat_util.computeOutShape(e.shape,t.shape,n),o=e.as2D(-1,util.sizeFromShape(e.shape.slice(n))),r=t.as2D(-1,util.sizeFromShape(t.shape.slice(n))),a=concat_util.computeGradientSliceShapes(o.shape,r.shape),i=a.aBegin,u=a.aSize,s=a.bBegin,l=a.bSize;return environment_1.ENV.engine.executeKernel("Concat",{inputs:{a:o,b:r}},function(e){return{a:function(){return e.slice(i,u)},b:function(){return e.slice(s,l)}}}).reshape(c)}exports.Concat=Concat;
"use strict";var __decorate=this&&this.__decorate||function(e,n,r,o){var t,a=arguments.length,i=a<3?n:null===o?o=Object.getOwnPropertyDescriptor(n,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,n,r,o);else for(var s=e.length-1;0<=s;s--)(t=e[s])&&(i=(a<3?t(i):3<a?t(n,r,i):t(n,r))||i);return 3<a&&i&&Object.defineProperty(n,r,i),i};Object.defineProperty(exports,"__esModule",{value:!0});var doc_1=require("../doc"),environment_1=require("../environment"),tensor_1=require("../tensor"),util=require("../util"),concat_1=require("./concat"),operation_1=require("./operation"),rand_1=require("./rand"),Ops=function(){function i(){}return i.tensor=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);return null!=n&&1!==o.length&&util.assertShapesMatch(n,o,"Error creating a new Tensor. Inferred shape ("+o+") does not match the provided shape ("+n+"). "),util.isTypedArray(e)||Array.isArray(e)||(e=[e]),n=n||o,tensor_1.Tensor.make(n,{values:toTypedArray(e,r)},r)},i.scalar=function(e,n){if(void 0===n&&(n="float32"),util.isTypedArray(e)||Array.isArray(e))throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean)");return i.tensor(e,[],n)},i.tensor1d=function(e,n){void 0===n&&(n="float32");var r=util.inferShape(e);if(1!==r.length)throw new Error("Error creating a new Tensor1D: values must be a flat/TypedArray");return i.tensor(e,r,n)},i.tensor2d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(2!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor2D: values must be number[][] or flat/TypedArray");return i.tensor(e,n=n||o,r)},i.tensor3d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(3!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor3D: values must be number[][][]or flat/TypedArray");return i.tensor(e,n=n||o,r)},i.tensor4d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(4!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor4D: values must be number[][][][]or flat/TypedArray");return i.tensor(e,n=n||o,r)},i.ones=function(e,n){void 0===n&&(n="float32");var r=makeOnesTypedArray(util.sizeFromShape(e),n);return tensor_1.Tensor.make(e,{values:r},n)},i.zeros=function(e,n){void 0===n&&(n="float32");var r=makeZerosTypedArray(util.sizeFromShape(e),n);return tensor_1.Tensor.make(e,{values:r},n)},i.fill=function(e,n,r){void 0===r&&(r="float32");var o=util.getTypedArrayFromDType(r,util.sizeFromShape(e));return o.fill(n),tensor_1.Tensor.make(e,{values:o},r)},i.onesLike=function(e){return i.ones(e.shape,e.dtype)},i.zerosLike=function(e){return i.zeros(e.shape,e.dtype)},i.clone=function(e){return tensor_1.Tensor.make(e.shape,{dataId:e.dataId},e.dtype)},i.randomNormal=function(e,n,r,o,t){if(void 0===n&&(n=0),void 0===r&&(r=1),null!=o&&"bool"===o)throw new Error("Unsupported data type "+o);var a=new rand_1.MPRandGauss(n,r,o,!1,t);return tensor_1.Tensor.rand(e,function(){return a.nextValue()},o)},i.truncatedNormal=function(e,n,r,o,t){if(void 0===n&&(n=0),void 0===r&&(r=1),null!=o&&"bool"===o)throw new Error("Unsupported data type "+o);var a=new rand_1.MPRandGauss(n,r,o,!0,t);return tensor_1.Tensor.rand(e,function(){return a.nextValue()},o)},i.randomUniform=function(e,n,r,o){return void 0===n&&(n=0),void 0===r&&(r=1),void 0===o&&(o="float32"),tensor_1.Tensor.rand(e,function(){return util.randUniform(n,r)},o)},i.rand=function(e,n,r){var o=util.sizeFromShape(e),t=null;if(null==r||"float32"===r)t=new Float32Array(o);else if("int32"===r)t=new Int32Array(o);else{if("bool"!==r)throw new Error("Unknown data type "+r);t=new Uint8Array(o)}for(var a=0;a<o;a++)t[a]=n();return tensor_1.Tensor.make(e,{values:t},r)},i.multinomial=function(e,n,r){var o=e.size;if(o<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+o+".");if(2<e.rank)throw new Error("Rank of probabilities must be 1 or 2, but is "+e.rank);r=r||Math.random();var t=e.rank;1===e.rank&&(e=e.as2D(1,-1));var a=environment_1.ENV.engine.executeKernel("Multinomial",{inputs:{probs:e},args:{numSamples:n,seed:r}});return 1===t?a.as1D():a},i.oneHot=function(e,n,r,o){if(void 0===r&&(r=1),void 0===o&&(o=0),n<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+n);return environment_1.ENV.engine.executeKernel("OneHot",{inputs:{indices:e},args:{depth:n,onValue:r,offValue:o}})},i.fromPixels=function(e,n){if(void 0===n&&(n=3),4<n)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");return environment_1.ENV.engine.fromPixels(e,n)},i.reshape=function(r,e){e=util.inferFromImplicitShape(e,r.size),util.assert(r.size===util.sizeFromShape(e),"new shape and old shape must have the same number of elements.");return environment_1.ENV.engine.executeKernel("Reshape",{inputs:{x:r},args:{newShape:e}},function(e,n){return{x:function(){return e.reshape(r.shape)}}})},i.squeeze=function(e,n){return i.reshape(e,util.squeezeShape(e.shape,n).newShape)},i.cast=function(e,n){return environment_1.ENV.engine.executeKernel("Cast",{inputs:{x:e},args:{newDType:n}},function(e,n){return{x:function(){return e.reshape(e.shape)}}})},i.tile=function(e,n){return util.assert(e.rank===n.length,"Error in transpose: rank of input "+e.rank+" must match length of reps "+n+"."),environment_1.ENV.engine.executeKernel("Tile",{inputs:{x:e},args:{reps:n}})},i.gather=function(e,n,r){return void 0===r&&(r=0),environment_1.ENV.engine.executeKernel("Gather",{inputs:{x:e,indices:n},args:{axis:r}})},i.pad1d=function(e,n,r){return void 0===r&&(r=0),util.assert(2===n.length,"Invalid number of paddings. Must be length of 2."),environment_1.ENV.engine.executeKernel("Pad1D",{inputs:{x:e},args:{paddings:n,constantValue:r}})},i.pad2d=function(e,n,r){return void 0===r&&(r=0),util.assert(2===n.length&&2===n[0].length&&2===n[1].length,"Invalid number of paddings. Must be length of 2 each."),environment_1.ENV.engine.executeKernel("Pad2D",{inputs:{x:e},args:{paddings:n,constantValue:r}})},i.pad=function(e,n,r){if(void 0===r&&(r=0),0===e.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");if(1===e.rank)return i.pad1d(e,n[0],r);if(2===e.rank)return i.pad2d(e,n,r);throw new Error("pad of rank-"+e.rank+" tensor is not yet supported")},i.stack=function(e,n){void 0===n&&(n=0),util.assert(2<=e.length,"Pass at least two tensors to dl.stack");var r=e[0].rank,o=e[0].shape,t=e[0].dtype;util.assert(n<=r,"Axis must be <= rank of the tensor"),e.forEach(function(e){util.assertShapesMatch(o,e.shape,"All tensors passed to stack must have matching shapes")}),e.forEach(function(e){util.assert(t===e.dtype,"All tensors passed to stack must have matching dtypes")});var a=e.map(function(e){return e.expandDims(n)});return concat_1.Concat.concat(a,n)},i.expandDims=function(e,n){void 0===n&&(n=0),util.assert(n<=e.rank,"Axis must be <= rank of the tensor");var r=e.shape.slice();return r.splice(n,0,1),i.reshape(e,r)},i.linspace=function(e,n,r){if(0===r)throw new Error("Cannot request zero samples");var o=(n-e)/(r-1),t=makeZerosTypedArray(r,"float32");t[0]=e;for(var a=1;a<t.length;a++)t[a]=t[a-1]+o;return tensor_1.Tensor1D.new(t,"float32")},i.range=function(e,n,r,o){if(void 0===r&&(r=1),void 0===o&&(o="float32"),0===r)throw new Error("Cannot have a step of zero");if(e===n||e<n&&r<0||n<e&&1<r)return i.zeros([0],o);var t=makeZerosTypedArray(Math.abs(Math.ceil((n-e)/r)),o);n<e&&1===r&&(r=-1),t[0]=e;for(var a=1;a<t.length;a++)t[a]=t[a-1]+r;return i.tensor1d(t,o)},i.buffer=function(e,n,r){return void 0===n&&(n="float32"),new tensor_1.TensorBuffer(e,n,r)},i.print=function(r,o){void 0===o&&(o=!1);var e=new function(){};e.shape=r.shape,e.values=Array.from(r.dataSync()),e.toString=function(){var e=["values: ["+this.values.join(", ")+"]","shape: ["+r.shape.join(", ")+"]","rank: "+r.rank];o&&(e.push("dtype: '"+this.dtype+"'"),e.push("size: "+this.size));for(var n=0;n<e.length;n++)e[n]="  "+e[n];return"TensorInfo {\n"+e.join(",\n")+"\n}"},o&&(e.dtype=r.dtype,e.size=r.size),console.log(e)},__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"tensor",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"scalar",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"tensor1d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"tensor2d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"tensor3d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"tensor4d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"ones",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"zeros",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"fill",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"onesLike",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"zerosLike",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"clone",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"randomNormal",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"truncatedNormal",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"randomUniform",null),__decorate([operation_1.operation],i,"rand",null),__decorate([operation_1.operation],i,"multinomial",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"oneHot",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],i,"fromPixels",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],i,"reshape",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"})],i,"squeeze",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],i,"cast",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],i,"tile",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],i,"gather",null),__decorate([operation_1.operation],i,"pad1d",null),__decorate([operation_1.operation],i,"pad2d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],i,"pad",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],i,"stack",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],i,"expandDims",null),__decorate([operation_1.operation,doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"linspace",null),__decorate([operation_1.operation,doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"range",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"buffer",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],i,"print",null),i}();function makeZerosTypedArray(e,n){if(null==n||"float32"===n)return new Float32Array(e);if("int32"===n)return new Int32Array(e);if("bool"===n)return new Uint8Array(e);throw new Error("Unknown data type $ {dtype}")}function makeOnesTypedArray(e,n){for(var r=makeZerosTypedArray(e,n),o=0;o<r.length;o++)r[o]=1;return r}function toTypedArray(e,n){return noConversionNeeded(e,n)?e:(Array.isArray(e)&&(e=util.flatten(e)),util.copyTypedArray(e,n))}function noConversionNeeded(e,n){return e instanceof Float32Array&&"float32"===n||e instanceof Int32Array&&"int32"===n||e instanceof Uint8Array&&"bool"===n}exports.Ops=Ops;
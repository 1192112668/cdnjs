"use strict";var __decorate=this&&this.__decorate||function(t,r,e,n){var a,o=arguments.length,i=o<3?r:null===n?n=Object.getOwnPropertyDescriptor(r,e):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,r,e,n);else for(var s=t.length-1;0<=s;s--)(a=t[s])&&(i=(o<3?a(i):3<o?a(r,e,i):a(r,e))||i);return 3<o&&i&&Object.defineProperty(r,e,i),i};Object.defineProperty(exports,"__esModule",{value:!0});var doc_1=require("../doc"),environment_1=require("../environment"),matmul_1=require("../kernels/types/matmul"),util=require("../util"),operation_1=require("./operation"),Ops=function(){function t(){}return t.matMul=function(e,n,a,o){void 0===a&&(a=!1),void 0===o&&(o=!1),t=[enumToBool(a),enumToBool(o)],o=t[1];var t,r=(a=t[0])?e.shape[0]:e.shape[1],i=o?n.shape[1]:n.shape[0];return util.assert(2===e.rank&&2===n.rank,"Error in matMul: inputs must be rank 2, got ranks "+e.rank+" and "+n.rank+"."),util.assert(r===i,"Error in matMul: inner shapes ("+r+") and ("+i+") of Tensors with shapes "+e.shape+" and "+n.shape+" and transposeA="+a+" and transposeB="+o+" must match."),environment_1.ENV.engine.executeKernel("MatMul",{inputs:{a:e,b:n},args:{transposeA:a,transposeB:o}},function(t,r){if(a||o)throw new Error("Backprop for transposed MatMul not yet implemented.");return{a:function(){return t.matMul(n.toFloat(),!1,!0)},b:function(){return e.toFloat().matMul(t,!0,!1)}}})},t.vectorTimesMatrix=function(t,r){return util.assert(1===t.rank,"Error in vectorTimesMatrix: first input must be rank 1, but got rank "+t.rank+"."),util.assert(2===r.rank,"Error in vectorTimesMatrix: second input must be rank 2, but got rank "+r.rank+"."),util.assert(t.size===r.shape[0],"Error in vectorTimesMatrix: size of vector ("+t.size+") must match first dimension of matrix ("+r.shape[0]+")"),t.as2D(1,-1).matMul(r).as1D()},t.matrixTimesVector=function(t,r){return util.assert(1===r.rank,"Error in matrixTimesVector: second input must rank 1, but got rank "+r.rank+"."),util.assert(2===t.rank,"Error in matrixTimesVector: first input must be a rank 2, but got rank "+t.rank+"."),util.assert(r.size===t.shape[1],"Error in matrixTimesVector: size of first rank 1 input "+r.size+" must match inner dimension of second rank 2 input, but got shape "+t.shape+"."),t.matMul(r.as2D(-1,1)).as1D()},t.dotProduct=function(t,r){return util.assert(1===t.rank&&1===r.rank,"Error in dotProduct: inputs must be rank 1, but got ranks "+t.rank+" and "+r.rank+"."),util.assert(t.size===r.size,"Error in dotProduct: size of inputs ("+t.size+") and ("+r.size+") must match."),t.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar()},t.outerProduct=function(t,r){return util.assert(1===t.rank&&1===r.rank,"Error in outerProduct: inputs must be rank 1, but got ranks "+t.rank+" and "+r.rank+"."),t.as2D(-1,1).matMul(r.as2D(1,-1))},__decorate([doc_1.doc({heading:"Operations",subheading:"Matrices"}),operation_1.operation],t,"matMul",null),__decorate([operation_1.operation],t,"vectorTimesMatrix",null),__decorate([operation_1.operation],t,"matrixTimesVector",null),__decorate([operation_1.operation],t,"dotProduct",null),__decorate([doc_1.doc({heading:"Operations",subheading:"Matrices"}),operation_1.operation],t,"outerProduct",null),t}();function enumToBool(t){return t!==matmul_1.MatrixOrientation.REGULAR&&(t===matmul_1.MatrixOrientation.TRANSPOSED||t)}exports.Ops=Ops;
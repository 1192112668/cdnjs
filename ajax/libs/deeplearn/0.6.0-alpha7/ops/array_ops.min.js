"use strict";var __decorate=this&&this.__decorate||function(e,n,r,o){var t,a=arguments.length,i=a<3?n:null===o?o=Object.getOwnPropertyDescriptor(n,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,n,r,o);else for(var s=e.length-1;0<=s;s--)(t=e[s])&&(i=(a<3?t(i):3<a?t(n,r,i):t(n,r))||i);return 3<a&&i&&Object.defineProperty(n,r,i),i};Object.defineProperty(exports,"__esModule",{value:!0});var doc_1=require("../doc"),environment_1=require("../environment"),tensor_1=require("../tensor"),tensor_util=require("../tensor_util"),util=require("../util"),axis_util_1=require("./axis_util"),concat_1=require("./concat"),operation_1=require("./operation"),ops=require("./ops"),rand_1=require("./rand"),ArrayOps=function(){function u(){}return u.tensor=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);return null!=n&&1!==o.length&&util.assertShapesMatch(n,o,"Error creating a new Tensor. Inferred shape ("+o+") does not match the provided shape ("+n+"). "),util.isTypedArray(e)||Array.isArray(e)||(e=[e]),n=n||o,tensor_1.Tensor.make(n,{values:toTypedArray(e,r)},r)},u.scalar=function(e,n){if(void 0===n&&(n="float32"),util.isTypedArray(e)||Array.isArray(e))throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean)");return u.tensor(e,[],n)},u.tensor1d=function(e,n){void 0===n&&(n="float32");var r=util.inferShape(e);if(1!==r.length)throw new Error("Error creating a new Tensor1D: values must be a flat/TypedArray");return u.tensor(e,r,n)},u.tensor2d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(2!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor2D: values must be number[][] or flat/TypedArray");return u.tensor(e,n=n||o,r)},u.tensor3d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(3!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor3D: values must be number[][][]or flat/TypedArray");return u.tensor(e,n=n||o,r)},u.tensor4d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(4!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor4D: values must be number[][][][]or flat/TypedArray");return u.tensor(e,n=n||o,r)},u.ones=function(e,n){void 0===n&&(n="float32");var r=makeOnesTypedArray(util.sizeFromShape(e),n);return tensor_1.Tensor.make(e,{values:r},n)},u.zeros=function(e,n){void 0===n&&(n="float32");var r=makeZerosTypedArray(util.sizeFromShape(e),n);return tensor_1.Tensor.make(e,{values:r},n)},u.fill=function(e,n,r){void 0===r&&(r="float32");var o=util.getTypedArrayFromDType(r,util.sizeFromShape(e));return o.fill(n),tensor_1.Tensor.make(e,{values:o},r)},u.onesLike=function(e){return u.ones(e.shape,e.dtype)},u.zerosLike=function(e){return u.zeros(e.shape,e.dtype)},u.clone=function(e){return tensor_1.Tensor.make(e.shape,{dataId:e.dataId},e.dtype)},u.randomNormal=function(e,n,r,o,t){if(void 0===n&&(n=0),void 0===r&&(r=1),null!=o&&"bool"===o)throw new Error("Unsupported data type "+o);for(var a=new rand_1.MPRandGauss(n,r,o,!1,t),i=u.buffer(e,o),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()},u.truncatedNormal=function(e,n,r,o,t){if(void 0===n&&(n=0),void 0===r&&(r=1),null!=o&&"bool"===o)throw new Error("Unsupported data type "+o);for(var a=new rand_1.MPRandGauss(n,r,o,!0,t),i=u.buffer(e,o),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()},u.randomUniform=function(e,n,r,o){void 0===n&&(n=0),void 0===r&&(r=1),void 0===o&&(o="float32");for(var t=u.buffer(e,o),a=0;a<t.values.length;a++)t.values[a]=util.randUniform(n,r);return t.toTensor()},u.rand=function(e,n,r){var o=util.sizeFromShape(e),t=null;if(null==r||"float32"===r)t=new Float32Array(o);else if("int32"===r)t=new Int32Array(o);else{if("bool"!==r)throw new Error("Unknown data type "+r);t=new Uint8Array(o)}for(var a=0;a<o;a++)t[a]=n();return tensor_1.Tensor.make(e,{values:t},r)},u.multinomial=function(e,n,r,o){void 0===o&&(o=!1);var t=e.size,a=e.rank;if(t<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+t+".");if(2<a)throw new Error("Rank of probabilities must be 1 or 2, but is "+a);o||(e=ops.softmax(e)),r=r||Math.random();var i=1===a?e.as2D(1,-1):e,s=environment_1.ENV.engine.runKernel(function(e){return e.multinomial(i,n,r)},{prob2D:i});return 1===a?s.as1D():s},u.oneHot=function(n,r,o,t){if(void 0===o&&(o=1),void 0===t&&(t=0),r<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+r);return environment_1.ENV.engine.runKernel(function(e){return e.oneHot(n,r,o,t)},{indices:n})},u.fromPixels=function(e,n){if(void 0===n&&(n=3),4<n)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");return environment_1.ENV.engine.fromPixels(e,n)},u.reshape=function(n,r){r=util.inferFromImplicitShape(r,n.size),util.assert(n.size===util.sizeFromShape(r),"new shape and old shape must have the same number of elements.");return environment_1.ENV.engine.runKernel(function(e){return e.reshape(n,r)},{x:n},function(e){return{x:function(){return e.reshape(n.shape)}}})},u.squeeze=function(e,n){return u.reshape(e,util.squeezeShape(e.shape,n).newShape)},u.cast=function(n,r){return environment_1.ENV.engine.runKernel(function(e){return e.cast(n,r)},{x:n},function(e){return{x:function(){return e.clone()}}})},u.tile=function(i,s){util.assert(i.rank===s.length,"Error in transpose: rank of input "+i.rank+" must match length of reps "+s+".");return environment_1.ENV.engine.runKernel(function(e){return e.tile(i,s)},{x:i},function(a){return{x:function(){var e=u.zerosLike(i);if(1===i.rank)for(var n=0;n<s[0];++n)e=e.add(a.slice([n*i.shape[0]],[i.shape[0]]));else if(2===i.rank)for(n=0;n<s[0];++n)for(var r=0;r<s[1];++r)e=e.add(a.slice([n*i.shape[0],r*i.shape[1]],[i.shape[0],i.shape[1]]));else if(3===i.rank)for(n=0;n<s[0];++n)for(r=0;r<s[1];++r)for(var o=0;o<s[2];++o)e=e.add(a.slice([n*i.shape[0],r*i.shape[1],o*i.shape[2]],[i.shape[0],i.shape[1],i.shape[2]]));else{if(4!==i.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+i.rank+" tensors yet.");for(n=0;n<s[0];++n)for(r=0;r<s[1];++r)for(o=0;o<s[2];++o)for(var t=0;t<s[3];++t)e=e.add(a.slice([n*i.shape[0],r*i.shape[1],o*i.shape[2],t*i.shape[3]],[i.shape[0],i.shape[1],i.shape[2],i.shape[3]]))}return e}}})},u.gather=function(n,r,e){void 0===e&&(e=0);var o=axis_util_1.parseAxisParam(e,n.shape);return environment_1.ENV.engine.runKernel(function(e){return e.gather(n,r,o[0])},{x:n,indices:r})},u.pad1d=function(e,n,r){return void 0===r&&(r=0),util.assert(2===n.length,"Invalid number of paddings. Must be length of 2."),u.pad(e,[n],r)},u.pad2d=function(e,n,r){return void 0===r&&(r=0),util.assert(2===n.length&&2===n[0].length&&2===n[1].length,"Invalid number of paddings. Must be length of 2 each."),u.pad(e,n,r)},u.pad3d=function(e,n,r){return void 0===r&&(r=0),util.assert(3===n.length&&2===n[0].length&&2===n[1].length&&2===n[2].length,"Invalid number of paddings. Must be length of 2 each."),u.pad(e,n,r)},u.pad4d=function(e,n,r){return void 0===r&&(r=0),util.assert(4===n.length&&2===n[0].length&&2===n[1].length&&2===n[2].length&&2===n[3].length,"Invalid number of paddings. Must be length of 2 each."),u.pad(e,n,r)},u.pad=function(n,r,o){if(void 0===o&&(o=0),0===n.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var t=r.map(function(e){return e[0]});return environment_1.ENV.engine.runKernel(function(e){return e.pad(n,r,o)},{x:n},function(e){return{x:function(){return e.slice(t,n.shape)}}})},u.stack=function(e,n){void 0===n&&(n=0),util.assert(2<=e.length,"Pass at least two tensors to dl.stack");var r=e[0].rank,o=e[0].shape,t=e[0].dtype;util.assert(n<=r,"Axis must be <= rank of the tensor"),e.forEach(function(e){util.assertShapesMatch(o,e.shape,"All tensors passed to stack must have matching shapes")}),e.forEach(function(e){util.assert(t===e.dtype,"All tensors passed to stack must have matching dtypes")});var a=e.map(function(e){return e.expandDims(n)});return concat_1.ConcatOps.concat(a,n)},u.expandDims=function(e,n){void 0===n&&(n=0),util.assert(n<=e.rank,"Axis must be <= rank of the tensor");var r=e.shape.slice();return r.splice(n,0,1),u.reshape(e,r)},u.linspace=function(e,n,r){if(0===r)throw new Error("Cannot request zero samples");var o=(n-e)/(r-1),t=makeZerosTypedArray(r,"float32");t[0]=e;for(var a=1;a<t.length;a++)t[a]=t[a-1]+o;return u.tensor1d(t,"float32")},u.range=function(e,n,r,o){if(void 0===r&&(r=1),void 0===o&&(o="float32"),0===r)throw new Error("Cannot have a step of zero");if(e===n||e<n&&r<0||n<e&&1<r)return u.zeros([0],o);var t=makeZerosTypedArray(Math.abs(Math.ceil((n-e)/r)),o);n<e&&1===r&&(r=-1),t[0]=e;for(var a=1;a<t.length;a++)t[a]=t[a-1]+r;return u.tensor1d(t,o)},u.buffer=function(e,n,r){return void 0===n&&(n="float32"),new tensor_1.TensorBuffer(e,n,r)},u.print=function(e,n){void 0===n&&(n=!1),console.log(tensor_util.tensorToString(e,n))},__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"tensor",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"scalar",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"tensor1d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"tensor2d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"tensor3d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"tensor4d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"ones",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"zeros",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"fill",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"onesLike",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"zerosLike",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"clone",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"randomNormal",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"truncatedNormal",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"randomUniform",null),__decorate([operation_1.operation],u,"rand",null),__decorate([operation_1.operation],u,"multinomial",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"oneHot",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],u,"fromPixels",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],u,"reshape",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"})],u,"squeeze",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],u,"cast",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],u,"tile",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],u,"gather",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],u,"pad",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],u,"stack",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],u,"expandDims",null),__decorate([operation_1.operation,doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"linspace",null),__decorate([operation_1.operation,doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"range",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"buffer",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],u,"print",null),u}();function makeZerosTypedArray(e,n){if(null==n||"float32"===n)return new Float32Array(e);if("int32"===n)return new Int32Array(e);if("bool"===n)return new Uint8Array(e);throw new Error("Unknown data type $ {dtype}")}function makeOnesTypedArray(e,n){for(var r=makeZerosTypedArray(e,n),o=0;o<r.length;o++)r[o]=1;return r}function toTypedArray(e,n){return noConversionNeeded(e,n)?e:(Array.isArray(e)&&(e=util.flatten(e)),util.copyTypedArray(e,n))}function noConversionNeeded(e,n){return e instanceof Float32Array&&"float32"===n||e instanceof Int32Array&&"int32"===n||e instanceof Uint8Array&&"bool"===n}exports.ArrayOps=ArrayOps;
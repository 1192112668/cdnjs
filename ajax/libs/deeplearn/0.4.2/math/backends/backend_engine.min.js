"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var util=require("../../util"),ndarray_1=require("../ndarray"),kernel_registry=require("./kernel_registry"),tape_util=require("./tape_util"),BackendEngine=function(){function t(t,e){this.backend=t,this.safeMode=e,this.nextTapeNodeId=0,this.gradientScopeCount=0,this.customGradientDepth=0,this.debugMode=!1,this.activeScope={keep:[],track:[]},this.scopeStack=[this.activeScope]}return t.prototype.enableDebugMode=function(){this.debugMode=!0},t.prototype.executeKernel=function(t,e,r){var n,i=this;this.debugMode&&(n=performance.now());var o,a,s,c,p,u,h,d=kernel_registry.executeKernel(i.backend,t,e);return this.debugMode&&(o=d.dataSync(),a=util.rightPad(performance.now()-n+"ms",9),s=util.rightPad(t,25),c=d.rank,p=d.size,u=util.rightPad(d.shape.toString(),14),console.log("%c"+s+"\t%c"+a+"\t%c"+c+"D "+u+"\t%c"+p,"font-weight:bold","color:red","color:blue","color: orange"),util.checkForNaN(o,d.dtype,name)),null!=this.activeTape&&0===this.customGradientDepth&&(e=tape_util.stripUndefinedInputsFromInputConfig(e),h={id:this.nextTapeNodeId++,type:"kernel",name:"kernel: "+t,kernel:t,inputAndArgs:e,output:d,gradient:r},this.activeTape.push(h)),d},t.prototype.customGradient=function(n,t,e){var i;this.customGradientDepth++;var r,o=this.scope("customGradient",function(){var t=n(),e=t.value,r=t.gradients;return i=r,e},!0);return this.customGradientDepth--,null!=this.activeTape&&0===this.customGradientDepth&&(r={id:this.nextTapeNodeId++,type:"customGradient",name:e,inputAndArgs:{inputs:t},output:o,gradient:i},this.activeTape.push(r)),o},t.prototype.gradients=function(r,n,i){var o=this,t=this.scope("gradients",function(){var t=r();if(0!==t.rank)throw new Error("Cannot compute gradient of non-scalar y output. Got y with rank "+t.rank);var e=o.gradientWrt(t,n);return i?[t].concat(e):e},!0);return i?{value:t[0],gradients:t.slice(1)}:t},t.prototype.vjp=function(e,r,n){var i=this;return this.scope("vjp",function(){var t=e();if(!util.arraysEqual(t.shape,n.shape))throw new Error("Cannot compute vector jacobian product, y shape ("+t.shape+") does not match dy shape ("+n.shape+").");return i.gradientWrt(t,r,n)},!0)},t.prototype.gradientWrt=function(t,e,r){var n=tape_util.getFilteredNodesXToY(this.activeTape,e,t);if(0===n.length)throw new Error("Cannot compute gradient: y is not a function of xs.Make sure the xs you are computing gradients with respect to are used inside the gradient function.");var i={};i[t.id]=null==r?ndarray_1.Scalar.new(1):r,tape_util.backpropagateGradients(i,n);var o=e.map(function(t){return i[t.id]});return o.forEach(function(t,e){if(null==t)throw new Error("Gradient error: y was not a function of xs["+e+"]")}),o},t.prototype.scope=function(t,e,r){var n=this;this.startScope(r);var i=e(function(t){return n.keep(t)},function(t){return t});return i instanceof Promise?i.then(function(t){return n.endScope(t,r)}):this.endScope(i,r),i},t.prototype.startScope=function(t){t&&0===this.gradientScopeCount&&(this.activeTape=[]),t&&this.gradientScopeCount++;var e={keep:[],track:[]};this.scopeStack.push(e),this.activeScope=e},t.prototype.endScope=function(t,e){var r=this;e&&(this.gradientScopeCount--,0===this.gradientScopeCount&&(this.activeTape=null));for(var n=this.activeScope.keep,i=tape_util.extractNDArraysFromScopeResult(t),n=n.concat(i),o=0;o<this.activeScope.track.length;o++){var a=this.activeScope.track[o];util.isNDArrayInList(a,n)||(null!=this.activeTape?i.push(a):a.dispose())}this.scopeStack.pop(),this.activeScope=0===this.scopeStack.length?null:this.scopeStack[this.scopeStack.length-1],i.forEach(function(t){util.isNDArrayInList(t,r.activeScope.keep)||r.track(t)})},t.prototype.keep=function(t){if(1===this.scopeStack.length&&this.safeMode)throw new Error("You are using math in safe mode. Enclose all math.method() calls inside a scope: math.scope(() => {math.method();...}) to avoid memory leaks.");return this.activeScope.keep.push(t),t},t.prototype.track=function(t){if(1===this.scopeStack.length&&this.safeMode)throw new Error("You are using math in safe mode. Enclose all math.method() calls inside a scope: math.scope(() => {math.method();...}) to avoid memory leaks.");return this.activeScope.track.push(t),t},t.prototype.getBackend=function(){return this.backend},t}();exports.BackendEngine=BackendEngine;
import{nextTick}from"@riim/next-tick";import{EventEmitter}from"./EventEmitter";import{logError}from"./utils";import{WaitError}from"./WaitError";const KEY_LISTENER_WRAPPERS=Symbol("listenerWrappers");function defaultPut(t,e){t.push(e)}const pendingCells=[];let afterRelease,pendingCellsIndex=0,currentCell=null;const $error={error:null};let lastUpdationId=0;function release(){for(;pendingCellsIndex<pendingCells.length;){let t=pendingCells[pendingCellsIndex++];t._active&&t.actualize()}if(pendingCells.length=0,pendingCellsIndex=0,afterRelease){let t=afterRelease;afterRelease=null;for(let e of t)e()}}let Cell=(()=>{class t extends EventEmitter{constructor(e,i){super(),this._reactions=[],this._error=null,this._lastErrorEvent=null,this._hasSubscribers=!1,this._active=!1,this._currentlyPulling=!1,this._updationId=-1,this.debugKey=i&&i.debugKey,this.context=i&&void 0!==i.context?i.context:this,this._pull=i&&i.pull||("function"==typeof e?e:null),this._get=i&&i.get||null,this._validate=i&&i.validate||null,this._merge=i&&i.merge||null,this._put=i&&i.put||defaultPut,this._reap=i&&i.reap||null,this.meta=i&&i.meta||null,this._pull?(this._dependencies=void 0,this._value=void 0,this._state="dirty",this._inited=!1):(this._dependencies=null,i&&void 0!==i.value&&(e=i.value),this._validate&&this._validate(e,void 0),this._merge&&(e=this._merge(e,void 0)),this._value=e,this._state="actual",this._inited=!0,e instanceof EventEmitter&&e.on("change",this._onValueChange,this)),i&&(i.onChange&&this.on("change",i.onChange),i.onError&&this.on(t.EVENT_ERROR,i.onError))}static get currentlyPulling(){return!!currentCell}static autorun(e,i){let s;return new t(function(t,i){return s||(s=(()=>{t.dispose()})),e.call(this,i,s)},i&&i.onChange?i:Object.assign(Object.assign({},i),{onChange(){}})),s}static release(){release()}static afterRelease(t){(afterRelease||(afterRelease=[])).push(t)}on(t,e,i){return null!==this._dependencies&&this.actualize(),"object"==typeof t?super.on(t,void 0!==e?e:this.context):super.on(t,e,void 0!==i?i:this.context),this._hasSubscribers=!0,this._activate(!0),this}off(e,i,s){return null!==this._dependencies&&this.actualize(),e?"object"==typeof e?super.off(e,void 0!==i?i:this.context):super.off(e,i,void 0!==s?s:this.context):super.off(),!this._hasSubscribers||this._reactions.length||this._events.has(t.EVENT_CHANGE)||this._events.has(t.EVENT_ERROR)||(this._hasSubscribers=!1,this._deactivate(),this._reap&&this._reap.call(this.context)),this}onChange(e,i){return this.on(t.EVENT_CHANGE,e,void 0!==i?i:this.context)}offChange(e,i){return this.off(t.EVENT_CHANGE,e,void 0!==i?i:this.context)}onError(e,i){return this.on(t.EVENT_ERROR,e,void 0!==i?i:this.context)}offError(e,i){return this.off(t.EVENT_ERROR,e,void 0!==i?i:this.context)}subscribe(e,i){let s=e[KEY_LISTENER_WRAPPERS]||(e[KEY_LISTENER_WRAPPERS]=new Map);if(s.has(this))return this;function r(t){return e.call(this,t.data.error||null,t)}return s.set(this,r),void 0===i&&(i=this.context),this.on(t.EVENT_CHANGE,r,i).on(t.EVENT_ERROR,r,i)}unsubscribe(e,i){let s=e[KEY_LISTENER_WRAPPERS],r=s&&s.get(this);return r?(s.delete(this),void 0===i&&(i=this.context),this.off(t.EVENT_CHANGE,r,i).off(t.EVENT_ERROR,r,i)):this}_addReaction(t,e){this._reactions.push(t),this._hasSubscribers=!0,this._activate(e)}_deleteReaction(e){this._reactions.splice(this._reactions.indexOf(e),1),!this._hasSubscribers||this._reactions.length||this._events.has(t.EVENT_CHANGE)||this._events.has(t.EVENT_ERROR)||(this._hasSubscribers=!1,this._deactivate(),this._reap&&this._reap.call(this.context))}_activate(t){if(this._active||!this._pull)return;let e=this._dependencies;if(e){let i=e.length;do{e[--i]._addReaction(this,t)}while(i);t&&(this._state="actual"),this._active=!0}}_deactivate(){if(!this._active)return;let t=this._dependencies,e=t.length;do{t[--e]._deleteReaction(this)}while(e);this._state="dirty",this._active=!1}_onValueChange(t){this._inited=!0,this._updationId=++lastUpdationId;let e=this._reactions;for(let t=0;t<e.length;t++)e[t]._addToRelease(!0);this.handleEvent(t)}_addToRelease(t){this._state=t?"dirty":"check";let e=this._reactions,i=e.length;if(i)do{"actual"==e[--i]._state&&e[i]._addToRelease(!1)}while(i);else 1==pendingCells.push(this)&&nextTick(release)}actualize(){if("dirty"==this._state)this.pull();else if("check"==this._state){let t=this._dependencies;for(let e=0;;){if(t[e].actualize(),"dirty"==this._state){this.pull();break}if(++e==t.length){this._state="actual";break}}}}get value(){return this.get()}set value(t){this.set(t)}get(){if("actual"!=this._state&&this._updationId!=lastUpdationId&&this.actualize(),currentCell&&(currentCell._dependencies?-1==currentCell._dependencies.indexOf(this)&&currentCell._dependencies.push(this):currentCell._dependencies=[this],this._error&&this._error instanceof WaitError))throw this._error;return this._get?this._get(this._value):this._value}pull(){if(!this._pull)return!1;if(this._currentlyPulling)throw TypeError("Circular pulling detected");this._currentlyPulling=!0;let t=this._dependencies;this._dependencies=null;let e,i=currentCell;currentCell=this;try{e=this._pull.length?this._pull.call(this.context,this,this._value):this._pull.call(this.context)}catch(t){$error.error=t,e=$error}if(currentCell=i,this._currentlyPulling=!1,this._hasSubscribers){let e=this._dependencies,i=0;if(e){let s=e.length;do{let r=e[--s];t&&-1!=t.indexOf(r)||(r._addReaction(this,!1),i++)}while(s)}if(t&&(!e||e.length-i<t.length))for(let i=t.length;i;)i--,e&&-1!=e.indexOf(t[i])||t[i]._deleteReaction(this);e?this._active=!0:(this._state="actual",this._active=!1)}else this._state=this._dependencies?"dirty":"actual";return e===$error?this.fail($error.error):this.push(e)}set(t){return this._inited||this.pull(),this._validate&&this._validate(t,this._value),this._merge&&(t=this._merge(t,this._value)),this._put.length>=3?this._put.call(this.context,this,t,this._value):this._put.call(this.context,this,t),this}push(e){this._inited=!0,this._error&&this._setError(null);let i=this._value,s=!Object.is(e,i);if(s&&(this._value=e,i instanceof EventEmitter&&i.off("change",this._onValueChange,this),e instanceof EventEmitter&&e.on("change",this._onValueChange,this)),this._active&&(this._state="actual"),this._updationId=++lastUpdationId,s){let s=this._reactions;for(let t=0;t<s.length;t++)s[t]._addToRelease(!0);this.emit(t.EVENT_CHANGE,{prevValue:i,value:e})}return s}fail(t){this._inited=!0;let e=t instanceof WaitError;return e||(this.debugKey?logError("["+this.debugKey+"]",t):logError(t),t instanceof Error||(t=new Error(String(t)))),this._setError(t),this._active&&(this._state="actual"),e}_setError(e){this._error=e,this._updationId=++lastUpdationId,e&&this._handleErrorEvent({target:this,type:t.EVENT_ERROR,data:{error:e}})}_handleErrorEvent(t){if(this._lastErrorEvent===t)return;this._lastErrorEvent=t,this.handleEvent(t);let e=this._reactions;for(let i=0;i<e.length;i++)e[i]._handleErrorEvent(t)}wait(){throw new WaitError}reap(){this.off();let t=this._reactions;for(let e=0;e<t.length;e++)t[e].reap();return this}dispose(){return this.reap()}}return t.EVENT_CHANGE="change",t.EVENT_ERROR="error",t})();export{Cell};
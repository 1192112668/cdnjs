const DOMAIN="utils",INFINITY=1/0,MAX_INTEGER=1.7976931348623157e308,BOOL_TAG="[object Boolean]",DATE_TAG="[object Date]",FUNC_TAG="[object Function]",NUMBER_TAG="[object Number]",OBJECT_TAG="[object Object]",REGEXP_TAG="[object RegExp]",STRING_TAG="[object String]",objToString=Object.prototype.toString,PATH=/^(.+)\.(.+)$/,ERRORS={400:(...e)=>`expected: ${e[0]}, found: ${e[2]?e[1]:typeof e[1]}`,404:(...e)=>`${e[0]} not found`},toInteger=e=>{if(!e)return 0;if((e=+e)===1/0||e===-1/0){return(e<0?-1:1)*MAX_INTEGER}const t=e%1;return e==e?t?e-t:e:0},toStr=e=>objToString.call(e),isPlainObject=e=>!!e&&"object"==typeof e&&e.constructor===Object,mkdirP=(e,t)=>{if(!t)return e;return t.split(".").forEach(t=>{e[t]||(e[t]={}),e=e[t]}),e},utils={_(e,t){utils.forOwn(t,(t,i)=>{i&&void 0===e[i]&&!utils.isFunction(t)&&0!==i.indexOf("_")&&(e[i]=t)})},_forRelation(e={},t,i,s){const r=t.relation;let n,o=null;if(e.with=e.with||[],(n=utils._getIndex(e.with,r))>=0?o=r:(n=utils._getIndex(e.with,t.localField))>=0&&(o=t.localField),e.withAll)return void i.call(s,t,{});if(!o)return;const l={};utils.fillIn(l,t.getRelation()),utils.fillIn(l,e),l.with=e.with.slice(),l._activeWith=l.with.splice(n,1)[0],l.with.forEach((e,t)=>{e&&0===e.indexOf(o)&&e.length>=o.length&&"."===e[o.length]?l.with[t]=e.substr(o.length+1):l.with[t]=""}),i.call(s,t,l)},_getIndex(e,t){let i=-1;return e.forEach((e,s)=>e===t?(i=s,!1):utils.isObject(e)&&e.relation===t?(i=s,!1):void 0),i},addHiddenPropsToTarget(e,t){const i={};Object.keys(t).forEach(e=>{const s=Object.getOwnPropertyDescriptor(t,e);s.enumerable=!1,i[e]=s}),Object.defineProperties(e,i)},areDifferent(e,t,i={}){const s=utils.diffObjects(e,t,i);return Object.keys(s.added).length+Object.keys(s.removed).length+Object.keys(s.changed).length>0},copy(e,t,i,s,r,n){if(t){if(e===t)throw utils.err("utils.copy")(500,"Cannot copy! Source and destination are identical.");if(i=i||[],s=s||[],utils.isObject(e)){const r=i.indexOf(e);if(-1!==r)return s[r];i.push(e),s.push(t)}let o;if(utils.isArray(e)){let l;for(t.length=0,l=0;l<e.length;l++)o=utils.copy(e[l],null,i,s,r,n),utils.isObject(e[l])&&(i.push(e[l]),s.push(o)),t.push(o)}else{utils.isArray(t)?t.length=0:utils.forOwn(t,(e,i)=>{delete t[i]});for(const l in e)if(e.hasOwnProperty(l)){if(utils.isBlacklisted(l,r))continue;o=utils.copy(e[l],null,i,s,r,n),utils.isObject(e[l])&&(i.push(e[l]),s.push(o)),t[l]=o}}}else t=e,e&&(utils.isArray(e)?t=utils.copy(e,[],i,s,r,n):utils.isDate(e)?t=new Date(e.getTime()):utils.isRegExp(e)?(t=new RegExp(e.source,e.toString().match(/[^/]*$/)[0])).lastIndex=e.lastIndex:utils.isObject(e)&&(t=n?utils.copy(e,{},i,s,r,n):utils.copy(e,Object.create(Object.getPrototypeOf(e)),i,s,r,n)));return t},deepFillIn:(e,t)=>(t&&utils.forOwn(t,(t,i)=>{const s=e[i];isPlainObject(t)&&isPlainObject(s)?utils.deepFillIn(s,t):e.hasOwnProperty(i)&&void 0!==e[i]||(e[i]=t)}),e),deepMixIn(e,t){if(t)for(const i in t){const s=t[i],r=e[i];isPlainObject(s)&&isPlainObject(r)?utils.deepMixIn(r,s):e[i]=s}return e},diffObjects(e,t,i={}){let s=i.equalsFn;const r=i.ignore,n={added:{},changed:{},removed:{}};utils.isFunction(s)||(s=utils.deepEqual);const o=Object.keys(e).filter(e=>!utils.isBlacklisted(e,r)),l=Object.keys(t).filter(e=>!utils.isBlacklisted(e,r));return o.forEach(i=>{const r=t[i],o=e[i];s(r,o)||(void 0===r?n.added[i]=o:n.changed[i]=o)}),l.forEach(i=>{const s=t[i];void 0===e[i]&&void 0!==s&&(n.removed[i]=void 0)}),n},equal:(e,t)=>e==t,err:(e,t)=>(i,...s)=>{const r=`[${e}:${t}] `;let n=ERRORS[i].apply(null,s);return n=`${r}${n}\nhttp://www.js-data.io/v3.0/docs/errors#${i}`,new Error(n)},eventify(e,t,i){e=e||this;let s={};t||i||(t=(()=>s),i=(e=>s=e)),Object.defineProperties(e,{emit:{value(...e){const i=t.call(this)||{},s=e.shift();let r,n=i[s]||[];for(r=0;r<n.length;r++)n[r].f.apply(n[r].c,e);for(n=i.all||[],e.unshift(s),r=0;r<n.length;r++)n[r].f.apply(n[r].c,e)}},off:{value(e,s){const r=t.call(this)[e];if(r)if(s){for(let e=0;e<r.length;e++)if(r[e].f===s){r.splice(e,1);break}}else r.splice(0,r.length);else i.call(this,{})}},on:{value(e,s,r){t.call(this)||i.call(this,{});const n=t.call(this);n[e]=n[e]||[],n[e].push({c:r,f:s})}}})},fillIn(e,t){utils.forOwn(t,(t,i)=>{e.hasOwnProperty(i)&&void 0!==e[i]||(e[i]=t)})},findIndex(e,t){let i=-1;return e?(e.forEach((e,s)=>{if(t(e))return i=s,!1}),i):i},forEachRelation(e,t,i,s){const r=e.relationList||[];r.length&&r.forEach(e=>{utils._forRelation(t,e,i,s)})},forOwn(e,t,i){const s=Object.keys(e),r=s.length;let n;for(n=0;n<r&&!1!==t.call(i,e[s[n]],s[n],e);n++);},fromJson:e=>utils.isString(e)?JSON.parse(e):e,get(e,t){if(!t)return;if(utils.isFunction(t))return t(e);const i=t.split("."),s=i.pop();for(;t=i.shift();)if(null==(e=e[t]))return;return e[s]},getSuper(e,t){const i=t?e:e.constructor;return i.hasOwnProperty("__super__")?i.__super__:Object.getPrototypeOf(i)||i.__proto__},intersection(e,t){if(!e||!t)return[];e=Array.isArray(e)?e:[e],t=Array.isArray(t)?t:[t];const i=[];let s,r;const n=e.length;for(r=0;r<n;r++)s=e[r],-1===i.indexOf(s)&&-1!==t.indexOf(s)&&i.push(s);return i},isArray:Array.isArray,isBlacklisted(e,t){if(!t||!t.length)return!1;let i;for(const s of t)if(toStr(s)===REGEXP_TAG&&s.test(e)||s===e)return!!(i=e);return!!i},isBoolean:e=>toStr(e)===BOOL_TAG,isDate:e=>e&&"object"==typeof e&&toStr(e)===DATE_TAG,isFunction:e=>"function"==typeof e||e&&toStr(e)===FUNC_TAG,isInteger:e=>toStr(e)===NUMBER_TAG&&e==toInteger(e),isNull:e=>null===e,isNumber(e){const t=typeof e;return"number"===t||e&&"object"===t&&toStr(e)===NUMBER_TAG},isObject:e=>toStr(e)===OBJECT_TAG,isRegExp:e=>toStr(e)===REGEXP_TAG,isSorN:e=>utils.isString(e)||utils.isNumber(e),isString:e=>"string"==typeof e||e&&"object"==typeof e&&toStr(e)===STRING_TAG,isUndefined:e=>void 0===e,logify(e){utils.addHiddenPropsToTarget(e,{dbg(...e){utils.isFunction(this.log)&&this.log("debug",...e)},log(e,...t){if(e&&!t.length&&(t.push(e),e="debug"),"debug"===e&&!this.debug)return;const i=`${e.toUpperCase()}: (${this.name||this.constructor.name})`;utils.isFunction(console[e])?console[e](i,...t):console.log(i,...t)}})},noDupeAdd(e,t,i){if(!e)return;this.findIndex(e,i)<0&&e.push(t)},omit(e,t){const i={};return utils.forOwn(e,(e,s)=>{-1===t.indexOf(s)&&(i[s]=e)}),i},pick:(e,t)=>t.reduce((t,i)=>(t[i]=e[i],t),{}),plainCopy:e=>utils.copy(e,void 0,void 0,void 0,void 0,!0),reject:e=>Promise.reject(e),remove(e,t){if(!e||!e.length)return;const i=this.findIndex(e,t);i>=0&&e.splice(i,1)},resolve:e=>Promise.resolve(e),set(e,t,i,s){if(utils.isObject(t))utils.forOwn(t,(t,i)=>{utils.set(e,i,t)});else{const s=PATH.exec(t);s?mkdirP(e,s[1])[s[2]]=i:e[t]=i}},deepEqual(e,t){if(e===t)return!0;let i=!0;if(utils.isArray(e)&&utils.isArray(t)){if(e.length!==t.length)return!1;for(let i=e.length;i--;)if(!utils.deepEqual(e[i],t[i]))return!1}else{if(!utils.isObject(e)||!utils.isObject(t))return!1;utils.forOwn(e,(e,s)=>{if(!(i=utils.deepEqual(e,t[s])))return!1}),i&&utils.forOwn(t,(t,s)=>{if(!(i=utils.deepEqual(t,e[s])))return!1})}return i},toJson:JSON.stringify,unset(e,t){const i=t.split("."),s=i.pop();for(;t=i.shift();)if(null==(e=e[t]))return;e[s]=void 0},getDefaultLocale:()=>"en"},safeSetProp=(e,t,i)=>{var s;(null===(s=e)||void 0===s?void 0:s._set)?e._set(`props.${t}`,i):utils.set(e,t,i)},safeSetLink=(e,t,i)=>{var s;(null===(s=e)||void 0===s?void 0:s._set)?e._set(`links.${t}`,i):utils.set(e,t,i)};class Settable{constructor(){const e={};Object.defineProperties(this,{_get:{value:t=>utils.get(e,t)},_set:{value:(t,i)=>utils.set(e,t,i)},_unset:{value:t=>utils.unset(e,t)}})}}class Component extends Settable{constructor(e={}){var t;super(),this._listeners={},this.debug=null!=(t=e.debug)&&t}}utils.logify(Component.prototype),utils.eventify(Component.prototype,function(){return this._listeners},function(e){this._listeners=e});const DOMAIN$1="Query",INDEX_ERR="Index inaccessible after first operation",reserved={limit:"",offset:"",orderBy:"",skip:"",sort:"",where:"",locale:""},escapeRegExp=/([.*+?^=!:${}()|[\]/\\])/g,percentRegExp=/%/g,underscoreRegExp=/_/g;function escape(e){return e.replace(escapeRegExp,"\\$1")}class Query extends Component{constructor(e){super(),this.collection=e,this.data=null}_applyWhereFromObject(e){const t=[],i=[],s=[];return utils.forOwn(e,(e,r)=>{utils.isObject(e)||(e={"==":e}),utils.forOwn(e,(e,n)=>{t.push(r),i.push(n),s.push(e)})}),{fields:t,ops:i,predicates:s}}_applyWhereFromArray(e){const t=[];return e.forEach((i,s)=>{if(utils.isString(i))return;const r=e[s-1],n=(utils.isArray(i)?this._applyWhereFromArray:this._applyWhereFromObject).call(this,i);"or"===r&&(n.isOr=!0),t.push(n)}),t.isArray=!0,t}_testObjectGroup(e,t,i,s){let r;const n=i.fields,o=i.ops,l=i.predicates,a=o.length;for(r=0;r<a;r++){let i=o[r];const a="|"===i.charAt(0);i=a?i.substr(1):i;const h=this.evaluate(utils.get(s,n[r]),i,l[r]);void 0!==h&&(e=t?h:a?e||h:e&&h),t=!1}return{keep:e,first:t}}_testArrayGroup(e,t,i,s){let r;const n=i.length;for(r=0;r<n;r++){const n=i[r],o=(n.isArray?this._testArrayGroup:this._testObjectGroup).call(this,!0,!0,n,s);e=i[r-1]?n.isOr?e||o.keep:e&&o.keep:o.keep,t=o.first}return{keep:e,first:t}}between(e,t,i={}){if(this.data)throw utils.err(`${DOMAIN$1}#between`)(500,"Cannot access index");return this.data=this.collection.getIndex(i.index).between(e,t,i),this}compare(e,t,i,s,r){const n=e[t];let o=utils.get(i,n[0]),l=utils.get(s,n[0]);if(o&&utils.isString(o)&&(o=o.toUpperCase()),l&&utils.isString(l)&&(l=l.toUpperCase()),void 0===i&&(i=null),void 0===s&&(s=null),"DESC"===n[1].toUpperCase()){const e=l;l=o,o=e}const a=r(o,l);return-1===a||1===a?a:t<e.length-1?this.compare(e,t+1,i,s,r):0}evaluate(e,t,i){const s=Query.ops;return s[t]?s[t](e,i):0===t.indexOf("like")?null!==this.like(i,t.substr(4)).exec(e):0===t.indexOf("notLike")?null===this.like(i,t.substr(7)).exec(e):void 0}filter(e={},t){if(this.getData(),utils.isObject(e)){let t,i={};(utils.isObject(e.where)||utils.isArray(e.where))&&(i=e.where),utils.forOwn(e,(e,t)=>{t in reserved||t in i||(i[t]={"==":e})}),utils.isObject(i)&&0!==Object.keys(i).length?t=this._applyWhereFromArray([i]):utils.isArray(i)&&(t=this._applyWhereFromArray(i)),t&&(this.data=this.data.filter(e=>this._testArrayGroup(!0,!0,t,e).keep));let s=e.orderBy||e.sort;if(utils.isString(s)&&(s=[[s,"ASC"]]),utils.isArray(s)||(s=null),s){const t=0;s.forEach((e,t)=>{utils.isString(e)&&(s[t]=[e,"ASC"])});let i=utils.getDefaultLocale();utils.isString(e.locale)&&(i=e.locale);const r=new Intl.Collator(i,{numeric:!0});this.data.sort((e,i)=>this.compare(s,t,e,i,r.compare))}utils.isNumber(e.skip)?this.skip(e.skip):utils.isNumber(e.offset)&&this.skip(e.offset),utils.isNumber(e.limit)&&this.limit(e.limit)}else utils.isFunction(e)&&(this.data=this.data.filter(e,t));return this}forEach(e,t){return this.getData().forEach(e,t),this}get(e=[],t={}){if(this.data)throw utils.err(`${DOMAIN$1}#get`)(500,INDEX_ERR);return e&&!utils.isArray(e)&&(e=[e]),e.length?(this.data=this.collection.getIndex(t.index).get(e),this):(this.getData(),this)}getAll(...e){let t={};if(this.data)throw utils.err(`${DOMAIN$1}#getAll`)(500,INDEX_ERR);if(!e.length||1===e.length&&utils.isObject(e[0]))return this.getData(),this;e.length&&utils.isObject(e[e.length-1])&&(t=e[e.length-1],e.pop());const i=this.collection.getIndex(t.index);return this.data=[],e.forEach(e=>{this.data=this.data.concat(i.get(e))}),this}getData(){return this.data||(this.data=this.collection.index.getAll()),this.data}like(e,t){return new RegExp(`^${escape(e).replace(percentRegExp,".*").replace(underscoreRegExp,".")}$`,t)}limit(e){if(!utils.isNumber(e))throw utils.err(`${DOMAIN$1}#limit`,"num")(400,"number",e);const t=this.getData();return this.data=t.slice(0,Math.min(t.length,e)),this}map(e,t){return this.data=this.getData().map(e,t),this}mapCall(e,...t){return this.data=this.getData().map(i=>i[e](...t)),this}run(){const e=this.data;return this.data=null,e}skip(e){if(!utils.isNumber(e))throw utils.err(`${DOMAIN$1}#skip`,"num")(400,"number",e);const t=this.getData();return e<t.length?this.data=t.slice(e):this.data=[],this}}Query.ops={"=":(e,t)=>e==t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,">":(e,t)=>e>t,">=":(e,t)=>e>=t,"<":(e,t)=>e<t,"<=":(e,t)=>e<=t,isectEmpty:(e,t)=>!utils.intersection(e||[],t||[]).length,isectNotEmpty:(e,t)=>utils.intersection(e||[],t||[]).length,in:(e,t)=>-1!==t.indexOf(e),notIn:(e,t)=>-1===t.indexOf(e),contains:(e,t)=>-1!==(e||[]).indexOf(t),notContains:(e,t)=>-1===(e||[]).indexOf(t)};const belongsToType="belongsTo",hasManyType="hasMany",hasOneType="hasOne",DOMAIN$2="Relation";class Relation{constructor(e,t={}){this.TYPE_NAME=DOMAIN$2,t.type=this.constructor.TYPE_NAME,this.validateOptions(e,t),"object"==typeof e&&(this.relatedMapper=e),utils.fillIn(this,t)}get canAutoAddLinks(){return void 0===this.add||!!this.add}get relatedCollection(){return this.mapper.datastore.getCollection(this.relation)}validateOptions(e,t){const i=`new ${DOMAIN$2}`,s=t.localField;if(!s)throw utils.err(i,"opts.localField")(400,"string",s);const r=t.foreignKey=t.foreignKey||t.localKey;if(!r&&(t.type===belongsToType||t.type===hasOneType))throw utils.err(i,"opts.foreignKey")(400,"string",r);if(utils.isString(e)){if(t.relation=e,!utils.isFunction(t.getRelation))throw utils.err(i,"opts.getRelation")(400,"function",t.getRelation)}else{if(!e)throw utils.err(i,"related")(400,"Mapper or string",e);t.relation=e.name}}assignTo(e){this.name=e.name,Object.defineProperty(this,"mapper",{value:e}),e.relationList||Object.defineProperty(e,"relationList",{value:[]}),e.relationFields||Object.defineProperty(e,"relationFields",{value:[]}),e.relationList.push(this),e.relationFields.push(this.localField)}canFindLinkFor(e){return!(!this.foreignKey&&!this.localKey)}getRelation(){return this.relatedMapper}getForeignKey(e){return utils.get(e,this.mapper.idAttribute)}setForeignKey(e,t){e&&t&&this._setForeignKey(e,t)}_setForeignKey(e,t){const i=this.mapper.idAttribute;utils.isArray(t)||(t=[t]),t.forEach(t=>{utils.set(t,this.foreignKey,utils.get(e,i))})}getLocalField(e){return utils.get(e,this.localField)}setLocalField(e,t){return utils.set(e,this.localField,t)}getInverse(e){return this.inverse||this.findInverseRelation(e),this.inverse}findInverseRelation(e){this.getRelation().relationList.forEach(t=>{if(t.getRelation()===e&&this.isInversedTo(t)&&this!==t)return this.inverse=t,!0})}isInversedTo(e){return!e.foreignKey||e.foreignKey===this.foreignKey}addLinkedRecords(e){const t=this.mapper.datastore;e.forEach(e=>{let i=this.getLocalField(e);utils.isFunction(this.add)?i=this.add(t,this,e):i&&(i=this.linkRecord(e,i)),(!i||utils.isArray(i)&&!i.length)&&this.canFindLinkFor(e)&&(i=this.findExistingLinksFor(e)),i&&this.setLocalField(e,i)})}removeLinkedRecords(e,t){const i=this.localField;t.forEach(e=>{utils.set(e,i,void 0)})}linkRecord(e,t){const i=utils.get(t,this.mapper.idAttribute);if(void 0===i){-1===this.relatedCollection.unsaved().indexOf(t)&&this.canAutoAddLinks&&(t=this.relatedCollection.add(t))}else t!==this.relatedCollection.get(i)&&(this.setForeignKey(e,t),this.canAutoAddLinks&&(t=this.relatedCollection.add(t)));return t}findExistingLinksByForeignKey(e){if(null!=e)return this.relatedCollection.filter({[this.foreignKey]:e})}ensureLinkedDataHasProperType(e,t){const i=this.getRelation(),s=this.getLocalField(e);(!utils.isArray(s)||s.length&&!i.is(s[0]))&&s&&!i.is(s)&&utils.set(e,this.localField,i.createRecord(s,t))}isRequiresParentId(){return!1}isRequiresChildId(){return!1}createChildRecord(e,t,i){return this.setForeignKey(e,t),this.createLinked(t,i).then(t=>{this.setLocalField(e,t)})}createLinked(e,t){const i=utils.isArray(e)?"createMany":"create";return this.getRelation()[i](e,t)}}const DOMAIN$3="Record";function superMethod(e,t){var i;const s=e.datastore;return(null===(i=s)||void 0===i?void 0:i[t])?(...i)=>s[t](e.name,...i):e[t].bind(e)}const creatingPath="creating",noValidatePath="noValidate",keepChangeHistoryPath="keepChangeHistory",previousPath="previous";class Record extends Settable{constructor(e={},t={}){var i;super();const s=this._set,r=this.constructor.mapper;s(creatingPath,!0),s(noValidatePath,!!t.noValidate),s(keepChangeHistoryPath,void 0===t.keepChangeHistory?!r||r.keepChangeHistory:t.keepChangeHistory);const n=r?utils.get(e,r.idAttribute):void 0;void 0!==n&&utils.set(this,r.idAttribute,n),utils.fillIn(this,e),s(creatingPath,!1),void 0!==t.validateOnSet?s(noValidatePath,!t.validateOnSet):void 0!==(null===(i=r)||void 0===i?void 0:i.validateOnSet)?s(noValidatePath,!r.validateOnSet):s(noValidatePath,!1),s(previousPath,r?r.toJSON(e):utils.plainCopy(e))}_mapper(){const e=this.constructor.mapper;if(!e)throw utils.err(`${DOMAIN$3}#_mapper`,"")(404,"mapper");return e}afterLoadRelations(e,t){}beforeLoadRelations(e,t){}changeHistory(){return(this._get("history")||[]).slice()}changes(e={}){return utils.diffObjects("function"==typeof this.toJSON?this.toJSON(e):this,this._get("previous"),e)}commit(e){this._set("changed"),this._set("changing",!1),this._set("history",[]),this._set("previous",this.toJSON(e))}destroy(e={}){const t=this._mapper();return superMethod(t,"destroy")(utils.get(this,t.idAttribute),e)}get(e){return utils.get(this,e)}hasChanges(e){return!!(this._get("changed")||[]).length||utils.areDifferent("function"==typeof this.toJSON?this.toJSON(e):this,this._get("previous"),e)}isNew(e){return void 0===utils.get(this,this._mapper().idAttribute)}isValid(e){return!this._mapper().validate(this,e)}removeInverseRelation(e,t,i,s){if(i.type===hasOneType)safeSetLink(e,i.localField,void 0);else if(i.type===hasManyType){const r=utils.get(e,i.localField);void 0===t?utils.remove(r,e=>e===this):utils.remove(r,e=>e===this||t===utils.get(e,s))}}setupInverseRelation(e,t,i,s){if(i.type===hasOneType)safeSetLink(e,i.localField,this);else if(i.type===hasManyType){const r=utils.get(e,i.localField);void 0===t?utils.noDupeAdd(r,this,e=>e===this):utils.noDupeAdd(r,this,e=>e===this||t===utils.get(e,s))}}loadRelations(e=[],t={}){let i;const s=this._mapper();return utils.isString(e)&&(e=[e]),t.with=e,utils._(t,s),t.adapter=s.getAdapterName(t),i=t.op="beforeLoadRelations",utils.resolve(this[i](e,t)).then(()=>{i=t.op="loadRelations",s.dbg(i,this,e,t);const r=[];let n;return utils.forEachRelation(s,t,(e,i)=>{const o=e.getRelation();if(i.raw=!1,utils.isFunction(e.load))n=e.load(s,e,this,t);else if("hasMany"===e.type||"hasOne"===e.type)e.foreignKey?n=superMethod(o,"findAll")({[e.foreignKey]:utils.get(this,s.idAttribute)},i).then(t=>"hasOne"===e.type?t.length?t[0]:void 0:t):e.localKeys?n=superMethod(o,"findAll")({where:{[o.idAttribute]:{in:utils.get(this,e.localKeys)}}}):e.foreignKeys&&(n=superMethod(o,"findAll")({where:{[e.foreignKeys]:{contains:utils.get(this,s.idAttribute)}}},t));else if("belongsTo"===e.type){const t=utils.get(this,e.foreignKey);utils.isSorN(t)&&(n=superMethod(o,"find")(t,i))}n&&(n=n.then(t=>{e.setLocalField(this,t)}),r.push(n))}),Promise.all(r)}).then(()=>(i=t.op="afterLoadRelations",utils.resolve(this[i](e,t)).then(()=>this)))}previous(e){return e?this._get(`previous.${e}`):this._get("previous")}revert(e={}){const t=this._get("previous");e.preserve=e.preserve||[],utils.forOwn(this,(i,s)=>{s!==this._mapper().idAttribute&&!t.hasOwnProperty(s)&&this.hasOwnProperty(s)&&-1===e.preserve.indexOf(s)&&delete this[s]}),utils.forOwn(t,(t,i)=>{-1===e.preserve.indexOf(i)&&(this[i]=t)}),this.commit()}save(e={}){const t=this._mapper(),i=utils.get(this,t.idAttribute);let s=this;const r=t=>{const i=e.raw?t.data:t;return i&&(utils.deepMixIn(this,i),this.commit()),t};if(void 0===i)return superMethod(t,"create")(s,e).then(r);if(e.changesOnly){const t=this.changes(e);s={},utils.fillIn(s,t.added),utils.fillIn(s,t.changed)}return superMethod(t,"update")(i,s,e).then(r)}set(e,t,i){utils.isObject(e)&&(i=t),(i=i||{}).silent&&this._set("silent",!0),utils.set(this,e,t),this._get("eventId")||this._set("silent")}toJSON(e){const t=this.constructor.mapper;if(t)return t.toJSON(this,e);{const e={};return utils.forOwn(this,(t,i)=>{e[i]=utils.plainCopy(t)}),e}}unset(e,t){this.set(e,void 0,t)}validate(e){return this._mapper().validate(this,e)}}function sort(e,t,i){return e===t?0:(i&&(e=i(e),t=i(t)),null===e&&null===t||void 0===e&&void 0===t?-1:null==e?-1:null==t?1:e<t?-1:e>t?1:0)}function insertAt(e,t,i){return e.splice(t,0,i),e}function removeAt(e,t){return e.splice(t,1),e}function binarySearch(e,t,i){let s,r,n=0,o=e.length;for(;n<o;){if(0===(s=sort(t,e[r=(n+o)/2|0],i)))return{found:!0,index:r};s<0?o=r:n=r+1}return{found:!1,index:o}}Record.creatingPath=creatingPath,Record.noValidatePath=noValidatePath,Record.keepChangeHistoryPath=keepChangeHistoryPath,Record.previousPath=previousPath,utils.eventify(Record.prototype,function(){return this._get("events")},function(e){this._set("events",e)});class Index{constructor(e=[],t={}){if(!utils.isArray(e))throw new Error("fieldList must be an array.");this.fieldList=e,this.fieldGetter=t.fieldGetter,this.hashCode=t.hashCode,this.isIndex=!0,this.keys=[],this.values=[]}set(e,t){utils.isArray(e)||(e=[e]);const i=e.shift()||void 0,s=binarySearch(this.keys,i);if(0===e.length)if(s.found){const e=binarySearch(this.values[s.index],t,this.hashCode);e.found||insertAt(this.values[s.index],e.index,t)}else insertAt(this.keys,s.index,i),insertAt(this.values,s.index,[t]);else if(s.found)this.values[s.index].set(e,t);else{insertAt(this.keys,s.index,i);const r=new Index([],{hashCode:this.hashCode});r.set(e,t),insertAt(this.values,s.index,r)}}get(e){utils.isArray(e)||(e=[e]);const t=e.shift()||void 0,i=binarySearch(this.keys,t);return 0===e.length?i.found?this.values[i.index].isIndex?this.values[i.index].getAll():this.values[i.index].slice():[]:i.found?this.values[i.index].get(e):[]}getAll(e={}){let t=[];const i=this.values;if("desc"===e.order)for(let s=i.length-1;s>=0;s--){const r=i[s];t=r.isIndex?t.concat(r.getAll(e)):t.concat(r)}else for(const s of i)t=s.isIndex?t.concat(s.getAll(e)):t.concat(s);return t}visitAll(e,t){this.values.forEach(i=>{i.isIndex?i.visitAll(e,t):i.forEach(e,t)})}between(e,t,i={}){utils.isArray(e)||(e=[e]),utils.isArray(t)||(t=[t]),utils.fillIn(i,{leftInclusive:!0,rightInclusive:!1,limit:void 0,offset:0});const s=this._between(e,t,i);return i.limit?s.slice(i.offset,i.limit+i.offset):s.slice(i.offset)}_between(e,t,i){let s=[];const r=e.shift(),n=t.shift();let o;if(o=void 0!==r?binarySearch(this.keys,r):{found:!1,index:0},0===e.length){o.found&&!1===i.leftInclusive&&(o.index+=1);for(let e=o.index;e<this.keys.length;e+=1){if(void 0!==n)if(i.rightInclusive){if(this.keys[e]>n)break}else if(this.keys[e]>=n)break;if(s=this.values[e].isIndex?s.concat(this.values[e].getAll()):s.concat(this.values[e]),i.limit&&s.length>=i.limit+i.offset)break}}else for(let l=o.index;l<this.keys.length;l+=1){const o=this.keys[l];if(o>n)break;if(s=this.values[l].isIndex?o===r?s.concat(this.values[l]._between(utils.copy(e),t.map(()=>void 0),i)):o===n?s.concat(this.values[l]._between(e.map(()=>void 0),utils.copy(t),i)):s.concat(this.values[l].getAll()):s.concat(this.values[l]),i.limit&&s.length>=i.limit+i.offset)break}return i.limit?s.slice(0,i.limit+i.offset):s}peek(){return this.values.length?this.values[0].isIndex?this.values[0].peek():this.values[0]:[]}clear(){this.keys=[],this.values=[]}insertRecord(e){const t=this.fieldList.map(t=>utils.isFunction(t)?t(e)||void 0:e[t]||void 0);this.set(t,e)}removeRecord(e){let t;const i=void 0!==this.hashCode(e);return this.values.forEach((s,r)=>{if(s.isIndex){if(s.removeRecord(e))return 0===s.keys.length&&(removeAt(this.keys,r),removeAt(this.values,r)),t=!0,!1}else{let n={};if(void 0!==this.keys[r]&&i)i&&(n=binarySearch(s,e,this.hashCode));else for(let t=s.length-1;t>=0;t--)if(s[t]===e){n={found:!0,index:t};break}if(n.found)return removeAt(s,n.index),0===s.length&&(removeAt(this.keys,r),removeAt(this.values,r)),t=!0,!1}}),t?e:void 0}updateRecord(e){void 0!==this.removeRecord(e)&&this.insertRecord(e)}}const{noValidatePath:noValidatePath$1}=Record,DOMAIN$4="Collection",COLLECTION_DEFAULTS={commitOnMerge:!0,emitRecordEvents:!0,idAttribute:"id",onConflict:"merge"};class Collection extends Component{constructor(e={},t={}){super(t),this.indexes={},this._added={},e&&!utils.isArray(e)&&(t=e,e=[]),utils.isString(t)&&(t={idAttribute:t}),utils.fillIn(this,t),utils.fillIn(this,utils.copy(COLLECTION_DEFAULTS)),this.queryClass||(this.queryClass=Query);const i=this.recordId();this.index=new Index([i],{hashCode:e=>utils.get(e,i)}),(utils.isObject(e)||utils.isArray(e)&&e.length)&&this.add(e)}_onRecordEvent(...e){this.emitRecordEvents&&this.emit(...e)}add(e,t={}){utils._(t,this),e=this.beforeAdd(e,t)||e;let i=!1;const s=this.recordId();if(!utils.isArray(e)){if(!utils.isObject(e))throw utils.err(`${DOMAIN$4}#add`,"records")(400,"object or array",e);e=[e],i=!0}e=e.map(e=>{const i=this.recordId(e),r=void 0===i?i:this.get(i);if(e===r)return r;if(r){const i=t.onConflict||this.onConflict;if("merge"!==i&&"replace"!==i&&"skip"!==i)throw utils.err(`${DOMAIN$4}#add`,"opts.onConflict")(400,"one of (merge, replace, skip)",i,!0);const n=r._get(noValidatePath$1);t.noValidate&&r._set(noValidatePath$1,!0),"merge"===i?utils.deepMixIn(r,e):"replace"===i&&(utils.forOwn(r,(t,i)=>{i!==s&&void 0===e[i]&&(r[i]=void 0)}),r.set(e)),t.noValidate&&r._set(noValidatePath$1,n),e=r,t.commitOnMerge&&utils.isFunction(e.commit)&&e.commit(),this.updateIndexes(e)}else e=this.mapper?this.mapper.createRecord(e,t):e,this.index.insertRecord(e),utils.forOwn(this.indexes,(t,i)=>{t.insertRecord(e)}),e&&utils.isFunction(e.on)&&e.on("all",this._onRecordEvent,this);return e});const r=i?e[0]:e;return t.silent||this.emit("add",r),this.afterAdd(e,t,r)||r}afterAdd(e,t,i){return null}afterRemove(e,t,i){return null}afterRemoveAll(e,t,i){return null}beforeAdd(e,t){return null}beforeRemove(e,t){return null}beforeRemoveAll(e,t){return null}between(e,t,i){return this.query().between(e,t,i).run()}createIndex(e,t,i={}){utils.isString(e)&&void 0===t&&(t=[e]),i.hashCode=i.hashCode||(e=>this.recordId(e));const s=this.indexes[e]=new Index(t,i);this.index.visitAll(s.insertRecord,s)}filter(e,t){return this.query().filter(e,t).run()}forEach(e,t){this.index.visitAll(e,t)}get(e){const t=void 0===e?[]:this.query().get(e).run();return t.length?t[0]:void 0}getAll(...e){return this.query().getAll(...e).run()}getIndex(e){const t=e?this.indexes[e]:this.index;if(!t)throw utils.err(`${DOMAIN$4}#getIndex`,e)(404,"index");return t}limit(e){return this.query().limit(e).run()}map(e,t){const i=[];return this.index.visitAll(s=>{i.push(e.call(t,s))}),i}mapCall(e,...t){const i=[];return this.index.visitAll(s=>{i.push(s[e](...t))}),i}prune(e){return this.removeAll(this.unsaved(),e)}query(){return new(0,this.queryClass)(this)}recordId(e){return e?utils.get(e,this.recordId()):this.mapper?this.mapper.idAttribute:this.idAttribute}reduce(e,t){return this.getAll().reduce(e,t)}remove(e,t={}){this.beforeRemove(e,t);let i=utils.isSorN(e)?this.get(e):e;return utils.isObject(i)&&(i=this.index.removeRecord(i))&&(utils.forOwn(this.indexes,(e,t)=>{e.removeRecord(i)}),utils.isFunction(i.off)&&i.off("all",this._onRecordEvent,this),t.silent||this.emit("remove",i)),this.afterRemove(e,t,i)||i}removeAll(e,t={}){this.beforeRemoveAll(e,t);let i=utils.isArray(e)?e.slice():this.filter(e);const s=utils.plainCopy(t);return s.silent=!0,i=i.map(e=>this.remove(e,s)).filter(e=>e),t.silent||this.emit("remove",i),this.afterRemoveAll(e,t,i)||i}skip(e){return this.query().skip(e).run()}toJSON(e){return this.mapCall("toJSON",e)}unsaved(e){return this.index.get()}updateIndex(e,t={}){this.getIndex(t.index).updateRecord(e)}updateIndexes(e){this.index.updateRecord(e),utils.forOwn(this.indexes,t=>t.updateRecord(e))}}class TsDataError extends Error{}const DOMAIN$5="Schema",types={array:utils.isArray,boolean:utils.isBoolean,integer:utils.isInteger,null:utils.isNull,number:utils.isNumber,object:utils.isObject,string:utils.isString};function segmentToString(e,t){let i="";return e&&(utils.isNumber(e)?i+=`[${e}]`:i+=t?`.${e}`:`${e}`),i}function makePath(e={}){let t="";return(e.path||[]).forEach(e=>{t+=segmentToString(e,t)}),t+=segmentToString(e.prop,t)}function makeError(e,t,i){return{expected:t,actual:""+e,path:makePath(i)}}function addError(e,t,i,s){s.push(makeError(e,t,i))}function maxLengthCommon(e,t,i,s){const r=i[e];if(t.length>r)return makeError(t.length,`length no more than ${r}`,s)}function minLengthCommon(e,t,i,s){const r=i[e];if(t.length<r)return makeError(t.length,`length no less than ${r}`,s)}const validationKeywords={allOf(e,t,i){let s=[];return t.allOf.forEach(t=>{s=s.concat(validate(e,t,i)||[])}),s.length?s:void 0},anyOf(e,t,i){let s=!1,r=[];return t.anyOf.forEach(t=>{const n=validate(e,t,i);n?r=r.concat(n):s=!0}),s?void 0:r},dependencies(e,t,i){},enum(e,t,i){const s=t.enum;if(-1===utils.findIndex(s,t=>utils.deepEqual(t,e)))return makeError(e,`one of (${s.join(", ")})`,i)},items(e,t,i={}){let s=t.items,r=[];const n=utils.isArray(s),o=e.length;for(let l=0;l<o;l++)n&&(s=t.items[l]),i.prop=l,r=r.concat(validate(e[l],s,i)||[]);return r.length?r:void 0},maximum(e,t,i){const s=t.maximum,r=t.exclusiveMaximum;if(typeof e==typeof s&&!(r?s>e:s>=e))return makeError(e,r?`no more than nor equal to ${s}`:`no more than ${s}`,i)},maxItems(e,t,i){if(utils.isArray(e))return maxLengthCommon("maxItems",e,t,i)},maxLength:(e,t,i)=>maxLengthCommon("maxLength",e,t,i),maxProperties(e,t,i){if(!utils.isObject(e))return;const s=t.maxProperties,r=Object.keys(e).length;return r>s?makeError(r,`no more than ${s} properties`,i):void 0},minimum(e,t,i){const s=t.minimum,r=t.exclusiveMinimum;if(typeof e==typeof s&&!(r?e>s:e>=s))return makeError(e,r?`no less than nor equal to ${s}`:`no less than ${s}`,i)},minItems(e,t,i){if(utils.isArray(e))return minLengthCommon("minItems",e,t,i)},minLength:(e,t,i)=>minLengthCommon("minLength",e,t,i),minProperties(e,t,i){if(!utils.isObject(e))return;const s=t.minProperties,r=Object.keys(e).length;return r<s?makeError(r,`no more than ${s} properties`,i):void 0},multipleOf(e,t,i){const s=t.multipleOf;if(utils.isNumber(e)&&e/s%1!=0)return makeError(e,`multipleOf ${s}`,i)},not(e,t,i){if(!validate(e,t.not,i))return makeError("succeeded","should have failed",i)},oneOf(e,t,i){let s=!1,r=[];return t.oneOf.forEach(t=>{const n=validate(e,t,i);if(n)r=r.concat(n);else{if(s)return r=[makeError("valid against more than one","valid against only one",i)],s=!1,!1;s=!0}}),s?void 0:r},pattern(e,t,i){const s=t.pattern;if(utils.isString(e)&&!e.match(s))return makeError(e,s,i)},properties(e,t,i={}){if(utils.isArray(e))return;const s=void 0===t.additionalProperties||t.additionalProperties,r=[],n=t.properties||{},o=t.patternProperties||{};let l=[];utils.forOwn(n,(t,s)=>{i.prop=s,l=l.concat(validate(e[s],t,i)||[]),r.push(s)});const a=utils.omit(e,r);utils.forOwn(o,(t,s)=>{utils.forOwn(a,(n,o)=>{o.match(s)&&(i.prop=o,l=l.concat(validate(e[o],t,i)||[]),r.push(o))})});const h=Object.keys(utils.omit(e,r));if(!1===s){if(h.length){const e=i.prop;i.prop="",addError(`extra fields: ${h.join(", ")}`,"no extra fields",i,l),i.prop=e}}else utils.isObject(s)&&h.forEach(t=>{i.prop=t,l=l.concat(validate(e[t],s,i)||[])});return l.length?l:void 0},required(e,t,i={}){const s=t.required,r=[];return i.existingOnly||s.forEach(t=>{if(void 0===utils.get(e,t)){const e=i.prop;i.prop=t,addError(void 0,"a value",i,r),i.prop=e}}),r.length?r:void 0},type(e,t,i){let s,r=t.type;if(utils.isString(r)&&(r=[r]),r.forEach(r=>{if(types[r](e,t,i))return s=r,!1}),!s)return makeError(null!=e?typeof e:""+e,`one of (${r.join(", ")})`,i);const n=typeGroupValidators[s];return n?n(e,t,i):void 0},uniqueItems(e,t,i){var s;if((null===(s=e)||void 0===s?void 0:s.length)&&t.uniqueItems){let t,s,r;for(s=e.length-1;s>0;s--)for(t=e[s],r=s-1;r>=0;r--)if(utils.deepEqual(t,e[r]))return makeError(t,"no duplicates",i)}}};function runOps(e,t,i,s){let r=[];return e.forEach(e=>{void 0!==i[e]&&(r=r.concat(validationKeywords[e](t,i,s)||[]))}),r.length?r:void 0}const ANY_OPS=["enum","type","allOf","anyOf","oneOf","not"],ARRAY_OPS=["items","maxItems","minItems","uniqueItems"],NUMERIC_OPS=["multipleOf","maximum","minimum"],OBJECT_OPS=["maxProperties","minProperties","required","properties","dependencies"],STRING_OPS=["maxLength","minLength","pattern"],validateAny=(e,t,i)=>runOps(ANY_OPS,e,t,i),validate=(e,t,i={})=>{let s,r=[];i.ctx=i.ctx||{value:e,schema:t};const n=i.prop;if(void 0!==t){if(!utils.isObject(t))throw utils.err("Schema#validate")(500,`Invalid schema at path: "${i.path}"`);return void 0===i.path&&(i.path=[]),void 0!==i.prop&&(s=!0,i.path.push(i.prop),i.prop=void 0),t.extends&&(r=utils.isFunction(t.extends.validate)?r.concat(t.extends.validate(e,i)||[]):r.concat(validate(e,t.extends,i)||[])),void 0===e?(!0!==t.required||i.existingOnly||addError(e,"a value",i,r),s&&(i.path.pop(),i.prop=n),r.length?r:void 0):(r=r.concat(validateAny(e,t,i)||[]),s&&(i.path.pop(),i.prop=n),r.length?r:void 0)}},changingPath="changing",changedPath="changed",changeHistoryPath="history",creatingPath$1="creating",eventIdPath="eventId",noValidatePath$2="noValidate",keepChangeHistoryPath$1="keepChangeHistory",silentPath="silent",validationFailureMsg="validation failed",typeGroupValidators={array:(e,t,i)=>runOps(ARRAY_OPS,e,t,i),integer:(e,t,i)=>typeGroupValidators.numeric(e,t,i),number:(e,t,i)=>typeGroupValidators.numeric(e,t,i),numeric:(e,t,i)=>runOps(NUMERIC_OPS,e,t,i),object:(e,t,i)=>runOps(OBJECT_OPS,e,t,i),string:(e,t,i)=>runOps(STRING_OPS,e,t,i)};class Schema extends Component{constructor(e={}){super(),utils.fillIn(this,e),"object"===this.type?(this.properties=this.properties||{},utils.forOwn(this.properties,(e,t)=>{e instanceof Schema||(this.properties[t]=new Schema(e))})):"array"!==this.type||!this.items||this.items instanceof Schema||(this.items=new Schema(this.items)),!this.extends||this.extends instanceof Schema||(this.extends=new Schema(this.extends)),["allOf","anyOf","oneOf"].forEach(e=>{this[e]&&this[e].forEach((t,i)=>{t instanceof Schema||(this[e][i]=new Schema(t))})})}apply(e,t={}){t.getter=t.getter||"_get",t.setter=t.setter||"_set",t.unsetter=t.unsetter||"_unset",t.track=t.track||this.track;const i=this.properties||{};utils.forOwn(i,(i,s)=>{Object.defineProperty(e,s,this.makeDescriptor(s,i,t))})}applyDefaults(e){if(!e)return;const t=this.properties||{},i=utils.isFunction(e.set)||utils.isFunction(e._set);utils.forOwn(t,(t,s)=>{if(t.hasOwnProperty("default")&&void 0===utils.get(e,s)&&(i?e.set(s,utils.plainCopy(t.default),{silent:!0}):utils.set(e,s,utils.plainCopy(t.default))),"object"===t.type&&t.properties){if(i){const t=e._get("noValidate");e._set("noValidate",!0),utils.set(e,s,utils.get(e,s)||{},{silent:!0}),e._set("noValidate",t)}else utils.set(e,s,utils.get(e,s)||{});t.applyDefaults(utils.get(e,s))}})}makeDescriptor(e,t,i){const s={configurable:!0,enumerable:void 0===t.enumerable||!!t.enumerable,get(){return this._get(r)},set(i){const s=this[o],u=this[l],d=this[a];if(!s(noValidatePath$2)){const s=t.validate(i,{path:[e]});if(s){const e=new TsDataError(validationFailureMsg);throw e.errors=s,e}}if(h&&!s(creatingPath$1)){const t=s(n),o=s(r);let l=s(changingPath),a=s(changedPath);l||(a=[]);const h=a.indexOf(e);o!==i&&-1===h&&a.push(e),t===i&&h>=0&&a.splice(h,1),a.length||(l=!1,d(changingPath),d(changedPath),s(eventIdPath)&&(clearTimeout(s(eventIdPath)),d(eventIdPath))),!l&&a.length&&(u(changedPath,a),u(changingPath,!0),u(eventIdPath,setTimeout(()=>{if(d(changedPath),d(eventIdPath),d(changingPath),!s(silentPath)){let t;for(t=0;t<a.length;t++)this.emit("change:"+a[t],this,utils.get(this,a[t]));const r=utils.diffObjects({[e]:i},{[e]:o});if(s(keepChangeHistoryPath$1)){const e=utils.plainCopy(r);e.timestamp=(new Date).getTime();let t=s(changeHistoryPath);t||u(changeHistoryPath,t=[]),t.push(e)}this.emit("change",this,r)}d(silentPath)},0)))}return u(r,i),i}},r=`props.${e}`,n=`previous.${e}`,o=i.getter,l=i.setter,a=i.unsetter,h=utils.isBoolean(i.track)?i.track:t.track;if(utils.isFunction(t.get)){const e=s.get;s.get=function(){return t.get.call(this,e)}}if(utils.isFunction(t.set)){const e=s.set;s.set=function(i){return t.set.call(this,i,e)}}return s}pick(e,t){if(void 0!==e){if("object"===this.type){const t={},i=this.properties;if(i&&utils.forOwn(i,(i,s)=>{t[s]=i.pick(e[s])}),this.extends&&utils.fillIn(t,this.extends.pick(e)),this.additionalProperties)for(const s in e)i[s]||(t[s]=utils.plainCopy(e[s]));return t}return"array"===this.type?e.map(e=>{const t=this.items?this.items.pick(e):{};return this.extends&&utils.fillIn(t,this.extends.pick(e)),t}):utils.plainCopy(e)}}validate(e,t){return validate(e,this,t)}}Schema.ANY_OPS=ANY_OPS,Schema.ARRAY_OPS=ARRAY_OPS,Schema.NUMERIC_OPS=NUMERIC_OPS,Schema.OBJECT_OPS=OBJECT_OPS,Schema.STRING_OPS=STRING_OPS,Schema.typeGroupValidators=typeGroupValidators,Schema.types=types,Schema.validate=validate,Schema.validationKeywords=validationKeywords;class BelongsToRelation extends Relation{getForeignKey(e){return utils.get(e,this.foreignKey)}_setForeignKey(e,t){utils.set(e,this.foreignKey,utils.get(t,this.getRelation().idAttribute))}findExistingLinksFor(e){if(!e)return;const t=utils.get(e,this.foreignKey);return null!=t?this.relatedCollection.get(t):void 0}isRequiresParentId(){return!0}createParentRecord(e,t){const i=this.getLocalField(e);return this.createLinked(i,t).then(t=>{this.setForeignKey(e,t)})}createChildRecord(){throw new Error('"BelongsTo" relation does not support child creation as it cannot have children.')}}BelongsToRelation.TYPE_NAME="belongsTo";class HasManyRelation extends Relation{validateOptions(e,t){super.validateOptions(e,t);const{localKeys:i,foreignKeys:s,foreignKey:r}=t;if(!r&&!i&&!s)throw utils.err("new Relation","opts.<foreignKey|localKeys|foreignKeys>")(400,"string",r)}canFindLinkFor(e){return!!(this.foreignKey||this.foreignKeys||this.localKeys&&utils.get(e,this.localKeys))}linkRecord(e,t){const i=this.relatedCollection,s=this.canAutoAddLinks,r=this.foreignKey,n=this.relatedCollection.unsaved();return t.map(t=>{const o=i.recordId(t);return(void 0===o&&-1===n.indexOf(t)||t!==i.get(o))&&(r&&this.setForeignKey(e,t),s&&(t=i.add(t))),t})}findExistingLinksFor(e){var t;const i=utils.get(e,this.mapper.idAttribute),s=this.localKeys?utils.get(e,this.localKeys):null;let r;if(void 0!==i&&this.foreignKey?r=this.findExistingLinksByForeignKey(i):this.localKeys&&s?r=this.findExistingLinksByLocalKeys(s):void 0!==i&&this.foreignKeys&&(r=this.findExistingLinksByForeignKeys(i)),null===(t=r)||void 0===t?void 0:t.length)return r}findExistingLinksByLocalKeys(e){return this.relatedCollection.filter({where:{[this.relatedCollection.mapper.idAttribute]:{in:e}}})}findExistingLinksByForeignKeys(e){return this.relatedCollection.filter({where:{[this.foreignKeys]:{contains:e}}})}isRequiresParentId(){return!!this.localKeys&&this.localKeys.length>0}isRequiresChildId(){return!!this.foreignKey}createParentRecord(e,t){const i=this.getLocalField(e),s=this.getRelation().idAttribute;return this.createLinked(i,t).then(t=>{utils.set(e,this.localKeys,t.map(e=>utils.get(e,s)))})}createLinked(e,t){return this.getRelation().createMany(e,t)}}HasManyRelation.TYPE_NAME="hasMany";class HasOneRelation extends Relation{findExistingLinksFor(e,t){var i;const s=utils.get(t,e.idAttribute),r=this.findExistingLinksByForeignKey(s);if(null===(i=r)||void 0===i?void 0:i.length)return r[0]}isRequiresChildId(){return!0}}function belongsTo(e,t){return i=>{Relation.belongsTo(e,t).assignTo(i)}}function hasMany(e,t){return i=>{Relation.hasMany(e,t).assignTo(i)}}function hasOne(e,t){return i=>{Relation.hasOne(e,t).assignTo(i)}}HasOneRelation.TYPE_NAME="hasOne",[BelongsToRelation,HasManyRelation,HasOneRelation].forEach(e=>{Relation[e.TYPE_NAME]=((t,i)=>new e(t,i))});const DOMAIN$6="Mapper",applyDefaultsHooks=["beforeCreate","beforeCreateMany"],validatingHooks=["beforeCreate","beforeCreateMany","beforeUpdate","beforeUpdateAll","beforeUpdateMany"];function makeNotify(e){return function(...t){var i;const s=t[t.length-e],r=s.op;if(this.dbg(r,...t),-1!==applyDefaultsHooks.indexOf(r)&&!1!==s.applyDefaults){const e=this.getSchema();if(null===(i=e)||void 0===i?void 0:i.applyDefaults){let i=t[0];utils.isArray(i)||(i=[i]),i.forEach(t=>{e.applyDefaults(t)})}}if(-1!==validatingHooks.indexOf(r)&&!s.noValidate){const e=s.existingOnly;0===r.indexOf("beforeUpdate")&&void 0===s.existingOnly&&(s.existingOnly=!0);const i=this.validate(t["beforeUpdate"===r?1:0],utils.pick(s,["existingOnly"]));if(s.existingOnly=e,i){const e=new TsDataError("validation failed");return e.errors=i,utils.reject(e)}}(s.notify||void 0===s.notify&&this.notify)&&setTimeout(()=>{this.emit(r,...t)})}}const notify=makeNotify(1),notify2=makeNotify(2),LIFECYCLE_METHODS={count:{defaults:[{},{}],skip:!0,types:[]},destroy:{defaults:[{},{}],skip:!0,types:[]},destroyAll:{defaults:[{},{}],skip:!0,types:[]},find:{defaults:[void 0,{}],types:[]},findAll:{defaults:[{},{}],types:[]},sum:{defaults:[void 0,{},{}],skip:!0,types:[]},update:{adapterArgs:(e,t,i,s)=>[t,e.toJSON(i,s),s],beforeAssign:1,defaults:[void 0,{},{}],types:[]},updateAll:{adapterArgs:(e,t,i,s)=>[e.toJSON(t,s),i,s],beforeAssign:0,defaults:[{},{},{}],types:[]},updateMany:{adapterArgs:(e,t,i)=>[t.map(t=>e.toJSON(t,i)),i],beforeAssign:0,defaults:[[],{}],types:[]}},MAPPER_DEFAULTS={_adapters:{},applyDefaults:!0,applySchema:!0,defaultAdapter:"http",idAttribute:"id",keepChangeHistory:!0,notify:!0,noValidate:!1,raw:!1,validateOnSet:!0};class Mapper extends Component{constructor(e={}){if(super(),this.lifecycleMethods=LIFECYCLE_METHODS,this.afterCount=notify2,this.afterCreate=notify2,this.afterCreateMany=notify2,this.afterDestroy=notify2,this.afterDestroyAll=notify2,this.afterFind=notify2,this.afterFindAll=notify2,this.afterSum=notify2,this.afterUpdate=notify2,this.afterUpdateAll=notify2,this.afterUpdateMany=notify2,this.beforeCreate=notify,this.beforeCreateMany=notify,this.beforeCount=notify,this.beforeDestroy=notify,this.beforeDestroyAll=notify,this.beforeFind=notify,this.beforeFindAll=notify,this.beforeSum=notify,this.beforeUpdate=notify,this.beforeUpdateAll=notify,this.beforeUpdateMany=notify,utils.fillIn(this,e),utils.fillIn(this,utils.copy(MAPPER_DEFAULTS)),!this.name)throw utils.err(`new ${DOMAIN$6}`,"opts.name")(400,"string",this.name);this.schema&&(this.schema.type=this.schema.type||"object",this.schema instanceof Schema||(this.schema=new Schema(this.schema||{type:"object"}))),void 0===this.recordClass&&(this.recordClass=class extends Record{}),this.recordClass&&(this.recordClass.mapper=this,utils.isObject(this.methods)&&utils.addHiddenPropsToTarget(this.recordClass.prototype,this.methods),Record.prototype.isPrototypeOf(Object.create(this.recordClass.prototype))&&this.schema&&this.schema.apply&&this.applySchema&&this.schema.apply(this.recordClass.prototype))}_end(e,t,i=!1){if(t.raw&&utils._(e,t),i)return e;let s=t.raw?e.data:e;return s&&utils.isFunction(this.wrap)&&(s=this.wrap(s,t),t.raw?e.data=s:e=s),e}belongsTo(e,t){return belongsTo(e,t)(this)}count(e,t){return this.crud("count",e,t)}create(e={},t={}){const i=e;let s={},r={};return utils._(t,this),t.adapter=this.getAdapterName(t),t.op="beforeCreate",this._runHook(t.op,e,t).then(e=>(t.with=t.with||[],this._createParentRecordIfRequired(e,t))).then(e=>{s=e}).then(()=>(t.op="create",this._invokeAdapterMethod(t.op,e,t))).then(e=>{r=e}).then(()=>{const i=t.raw?r.data:r;return this._createOrAssignChildRecordIfRequired(i,{opts:t,parentRelationMap:s,originalProps:e})}).then(e=>this._commitChanges(i,e)).then(i=>{t.raw?r.data=i:r=i;const s=this._end(r,t);return t.op="afterCreate",this._runHook(t.op,e,t,s)})}_commitChanges(e,t){return utils.isArray(e)?e.map((e,i)=>this._commitChanges(e,t[i])):(utils.set(e,t,{silent:!0}),utils.isFunction(e.commit)&&e.commit(),e)}createInstance(e,t){return this.createRecord(e,t)}_createParentRecordIfRequired(e,t){const i=[],s=[];return utils.forEachRelation(this,t,(t,r)=>{t.isRequiresParentId()&&t.getLocalField(e)&&(r.raw=!1,s.push(t),i.push(t.createParentRecord(e,r)))}),Promise.all(i).then(e=>s.reduce((t,i,s)=>(i.setLocalField(t,e[s]),t),{}))}_createOrAssignChildRecordIfRequired(e,t){const i=[];return utils.forEachRelation(this,t.opts,(s,r)=>{const n=s.getLocalField(t.originalProps);if(n)if(r.raw=!1,s.isRequiresChildId())i.push(s.createChildRecord(e,n,r));else if(s.isRequiresParentId()){const i=s.getLocalField(t.parentRelationMap);i&&s.setLocalField(e,i)}}),Promise.all(i).then(()=>e)}createMany(e=[],t={}){const i=e;let s;return utils._(t,this),t.adapter=this.getAdapterName(t),t.op="beforeCreateMany",this._runHook(t.op,e,t).then(e=>{const r={};t.with=t.with||[];let n=[];return utils.forEachRelation(this,t,(t,i)=>{const s=e.map(e=>t.getLocalField(e)).filter(Boolean);t.type===belongsToType&&s.length===e.length&&(i.raw=!1,n.push(t.createLinked(s,i).then(i=>{e.forEach((e,s)=>t.setForeignKey(e,i[s]))}).then(e=>{t.setLocalField(r,e)})))}),Promise.all(n).then(()=>(t.op="createMany",this._invokeAdapterMethod(t.op,e,t))).then(e=>{s=e}).then(()=>{const o=t.raw?s.data:s;return n=[],utils.forEachRelation(this,t,(t,i)=>{const s=e.map(e=>t.getLocalField(e)).filter(Boolean);if(s.length!==e.length)return;i.raw=!1;const l=t.getLocalField(r);let a;t.type===hasManyType?this.log("warn","deep createMany of hasMany type not supported!"):t.type===hasOneType?(o.forEach((e,i)=>{t.setForeignKey(e,s[i])}),a=t.getRelation().createMany(s,i).then(e=>{o.forEach((i,s)=>{t.setLocalField(i,e[s])})})):t.type===belongsToType&&l&&l.length===o.length&&o.forEach((e,i)=>{t.setLocalField(e,l[i])}),a&&n.push(a)}),Promise.all(n).then(()=>this._commitChanges(i,o))})}).then(e=>{t.raw?s.data=e:s=e;const i=this._end(s,t);return t.op="afterCreateMany",this._runHook(t.op,e,t,i)})}createRecord(e={},t){if(utils.isArray(e))return e.map(e=>this.createRecord(e,t));if(!utils.isObject(e))throw utils.err(`${DOMAIN$6}#createRecord`,"props")(400,"array or object",e);this.relationList&&this.relationList.forEach(i=>{i.ensureLinkedDataHasProperType(e,t)});const i=this.recordClass;return!i||e instanceof i?e:new i(e,t)}crud(e,...t){const i=this.lifecycleMethods[e];if(!i)throw utils.err(`${DOMAIN$6}#crud`,e)(404,"method");const s=`${e.charAt(0).toUpperCase()}${e.substr(1)}`,r=`before${s}`,n=`after${s}`;let o;i.defaults.forEach((e,i)=>{void 0===t[i]&&(t[i]=utils.copy(e))});const l=t[t.length-1];utils._(l,this);const a=l.adapter=this.getAdapterName(l);return o=l.op=r,utils.resolve(this[o](...t)).then(s=>(void 0!==t[i.beforeAssign]&&(t[i.beforeAssign]=void 0===s?t[i.beforeAssign]:s),o=l.op=e,t=i.adapterArgs?i.adapterArgs(this,...t):t,this.dbg(o,...t),utils.resolve(this.getAdapter(a)[o](this,...t)))).then(e=>{const s=/find/.test(o)||l.noValidate,r=Object.assign({},l,{noValidate:s});return e=this._end(e,r,!!i.skip),t.push(e),o=l.op=n,utils.resolve(this[o](...t)).then(t=>void 0===t?e:t)})}destroy(e,t){return this.crud("destroy",e,t)}destroyAll(e,t){return this.crud("destroyAll",e,t)}find(e,t){return this.crud("find",e,t)}findAll(e,t){return this.crud("findAll",e,t)}getAdapter(e){this.dbg("getAdapter","name:",e);const t=this.getAdapterName(e);if(!t)throw utils.err(`${DOMAIN$6}#getAdapter`,"name")(400,"string",e);return this.getAdapters()[t]}getAdapterName(e={}){return utils.isString(e)&&(e={adapter:e}),e.adapter||e.defaultAdapter}getAdapters(){return this._adapters}getSchema(){return this.schema}hasMany(e,t){return hasMany(e,t)(this)}hasOne(e,t){return hasOne(e,t)(this)}is(e){const t=this.recordClass;return!!t&&e instanceof t}registerAdapter(e,t,i={}){this.getAdapters()[e]=t,(!0===i||i.default)&&(this.defaultAdapter=e)}_runHook(e,...t){const i=0===e.indexOf("after")?t.length-1:0;return utils.resolve(this[e](...t)).then(e=>void 0===e?t[i]:e)}_invokeAdapterMethod(e,t,i){const s={with:i.pass||[]};let r;return this.dbg(i.op,t,i),r=utils.isArray(t)?t.map(e=>this.toJSON(e,s)):this.toJSON(t,s),this.getAdapter(i.adapter)[e](this,r,i)}sum(e,t,i){return this.crud("sum",e,t,i)}toJSON(e,t={}){let i;if(utils.isArray(e))return e.map(e=>this.toJSON(e,t));i=e;const s=(this?this.relationFields:[])||[];let r={};if(this&&this.schema)r=this.schema.pick(i);else for(const e in i)-1===s.indexOf(e)&&(r[e]=utils.plainCopy(i[e]));return this&&t.withAll&&(t.with=s.slice()),this&&t.with&&(utils.isString(t.with)&&(t.with=[t.with]),utils.forEachRelation(this,t,(e,t)=>{const s=e.getLocalField(i);s&&(utils.isArray(s)?e.setLocalField(r,s.map(i=>e.getRelation().toJSON(i,t))):e.setLocalField(r,e.getRelation().toJSON(s,t)))})),r}update(e,t,i){return this.crud("update",e,t,i)}updateAll(e,t,i){return this.crud("updateAll",e,t,i)}updateMany(e,t){return this.crud("updateMany",e,t)}validate(e,t={}){const i=this.getSchema();if(!i)return;const s=utils.pick(t,["existingOnly"]);if(utils.isArray(e)){const t=e.map(e=>i.validate(e,utils.pick(s,["existingOnly"])));return t.some(Boolean)?t:void 0}return i.validate(e,s)}wrap(e,t){return this.createRecord(e,t)}defineRelations(){utils.forOwn(this.relations,(e,t)=>{utils.forOwn(e,(e,i)=>{utils.isObject(e)&&(e=[e]),e.forEach(e=>{const s=this.datastore.getMapperByName(i)||i;if(e.getRelation=(()=>this.datastore.getMapper(i)),"function"!=typeof Relation[t])throw utils.err(DOMAIN$6,"defineRelations")(400,"relation type (hasOne, hasMany, etc)",t,!0);this[t](s,e)})})})}}const DOMAIN$7="Container",proxiedMapperMethods=["count","create","createMany","createRecord","destroy","destroyAll","find","findAll","getSchema","is","sum","toJSON","update","updateAll","updateMany","validate"];class Container extends Component{constructor(e={}){super(),Object.defineProperties(this,{_adapters:{value:{}},_mappers:{value:{}},mapperClass:{value:void 0,writable:!0}}),utils.fillIn(this,e),this.mapperDefaults=this.mapperDefaults||{},this.mapperClass=this.mapperClass||Mapper}_onMapperEvent(e,...t){const i=t.shift();this.emit(i,e,...t)}as(e){const t={},i=this;return proxiedMapperMethods.forEach(s=>{t[s]={writable:!0,value:(...t)=>i[s](e,...t)}}),t.getMapper={writable:!0,value:()=>i.getMapper(e)},Object.create(this,t)}defineMapper(e,t){if(utils.isObject(e)&&(e=(t=e).name),!utils.isString(e))throw utils.err(`${DOMAIN$7}#defineMapper`,"name")(400,"string",e);(t=t||{}).name=e,t.relations=t.relations||{};const i=t.mapperClass||this.mapperClass;delete t.mapperClass,utils.fillIn(t,this.mapperDefaults);const s=this._mappers[e]=new i(t);return s.relations=s.relations||{},s.name=e,s._adapters=this.getAdapters(),s.datastore=this,s.on("all",(...t)=>this._onMapperEvent(e,...t)),s.defineRelations(),s}defineResource(e,t){return console.warn("DEPRECATED: defineResource is deprecated, use defineMapper instead"),this.defineMapper(e,t)}getAdapter(e){const t=this.getAdapterName(e);if(!t)throw utils.err(`${DOMAIN$7}#getAdapter`,"name")(400,"string",e);return this.getAdapters()[t]}getAdapterName(e={}){return utils.isString(e)&&(e={adapter:e}),e.adapter||this.mapperDefaults.defaultAdapter}getAdapters(){return this._adapters}getMapper(e){const t=this.getMapperByName(e);if(!t)throw utils.err(`${DOMAIN$7}#getMapper`,e)(404,"mapper");return t}getMapperByName(e){return this._mappers[e]}registerAdapter(e,t,i={}){this.getAdapters()[e]=t,(!0===i||i.default)&&(this.mapperDefaults.defaultAdapter=e,utils.forOwn(this._mappers,t=>{t.defaultAdapter=e}))}count(e,t,i){return this.getMapper(e).count(t,i)}create(e,t,i){return this.getMapper(e).create(t,i)}createMany(e,t,i){return this.getMapper(e).createMany(t,i)}createRecord(e,t,i){return this.getMapper(e).createRecord(t,i)}destroy(e,t,i){return this.getMapper(e).destroy(t,i)}destroyAll(e,t,i){return this.getMapper(e).destroyAll(t,i)}find(e,t,i){return this.getMapper(e).find(t,i)}findAll(e,t,i){return this.getMapper(e).findAll(t,i)}getSchema(e){return this.getMapper(e).getSchema()}is(e,t){return this.getMapper(e).is(t)}sum(e,t,i,s){return this.getMapper(e).sum(t,i,s)}toJSON(e,t,i){return this.getMapper(e).toJSON(t,i)}update(e,t,i,s){return this.getMapper(e).update(t,i,s)}updateAll(e,t,i,s){return this.getMapper(e).updateAll(t,i,s)}updateMany(e,t,i){return this.getMapper(e).updateMany(t,i)}validate(e,t,i){return this.getMapper(e).validate(t,i)}}const DOMAIN$8="SimpleStore",proxiedCollectionMethods=["add","between","createIndex","filter","get","getAll","prune","query","toJSON","unsaved"],ownMethodsForScoping=["addToCache","cachedFind","cachedFindAll","cacheFind","cacheFindAll","hashQuery"],cachedFn=function(e,t,i){const s=this._completedQueries[e][t];return utils.isFunction(s)?s(e,t,i):s},SIMPLESTORE_DEFAULTS={usePendingFind:!0,usePendingFindAll:!0};class SimpleStore extends Container{constructor(e={}){super(Object.assign(Object.assign({},SIMPLESTORE_DEFAULTS),e)),this._collections={},this._completedQueries={},this._pendingQueries={},this.cachedFind=cachedFn,this.cachedFindAll=cachedFn,this.collectionClass=this.collectionClass||Collection}_end(e,t,i){let s=i.raw?t.data:t;return s&&utils.isFunction(this.addToCache)&&(s=this.addToCache(e,s,i),i.raw?t.data=s:t=s),t}_onCollectionEvent(e,...t){const i=t.shift();this.emit(i,e,...t)}addToCache(e,t,i){return this.getCollection(e).add(t,i)}as(e){const t={},i=this;return ownMethodsForScoping.concat(proxiedMapperMethods).concat(proxiedCollectionMethods).forEach(s=>{t[s]={writable:!0,value:(...t)=>i[s](e,...t)}}),t.getMapper={writable:!0,value:()=>i.getMapper(e)},t.getCollection={writable:!0,value:()=>i.getCollection(e)},Object.create(this,t)}cacheFind(e,t,i,s){this._completedQueries[e][i]=((e,t,i)=>this.get(e,t))}cacheFindAll(e,t,i,s){this._completedQueries[e][i]=((e,t,i)=>this.filter(e,utils.fromJson(t)))}clear(){const e={};return utils.forOwn(this._collections,(t,i)=>{e[i]=t.removeAll(),this._completedQueries[i]={}}),e}create(e,t,i={}){return super.create(e,t,i).then(t=>this._end(e,t,i))}createMany(e,t,i={}){return super.createMany(e,t,i).then(t=>this._end(e,t,i))}defineMapper(e,t={}){const i=this,s=super.defineMapper(e,t);i._pendingQueries[e]={},i._completedQueries[e]={},s.relationList||Object.defineProperty(s,"relationList",{value:[]});const r={_added:{},datastore:this,mapper:s};t&&"onConflict"in t&&(r.onConflict=t.onConflict);const n=i._collections[e]=new i.collectionClass(null,r),o=(s.schema||{}).properties||{};return utils.forOwn(o,(e,t)=>{e.indexed&&n.createIndex(t)}),n.createIndex("addedTimestamps",["$"],{fieldGetter:e=>n._added[n.recordId(e)]}),n.on("all",(...t)=>{i._onCollectionEvent(e,...t)}),s}destroy(e,t,i={}){return super.destroy(e,t,i).then(s=>{const r=this.getCollection(e).remove(t,i);return i.raw?s.data=r:s=r,delete this._pendingQueries[e][t],delete this._completedQueries[e][t],s})}destroyAll(e,t,i={}){return super.destroyAll(e,t,i).then(s=>{const r=this.getCollection(e).removeAll(t,i);i.raw?s.data=r:s=r;const n=this.hashQuery(e,t,i);return delete this._pendingQueries[e][n],delete this._completedQueries[e][n],s})}eject(e,t,i){return console.warn('DEPRECATED: "eject" is deprecated, use "remove" instead'),this.remove(e,t,i)}ejectAll(e,t,i){return console.warn('DEPRECATED: "ejectAll" is deprecated, use "removeAll" instead'),this.removeAll(e,t,i)}find(e,t,i={}){const s=this.getMapper(e),r=this._pendingQueries[e][t],n=void 0===i.usePendingFind?this.usePendingFind:i.usePendingFind;if(utils._(i,s),r&&(utils.isFunction(n)?n.call(this,e,t,i):n))return r;const o=this.cachedFind(e,t,i);if(i.force||!o){return(this._pendingQueries[e][t]=super.find(e,t,i)).then(s=>(delete this._pendingQueries[e][t],s=this._end(e,s,i),this.cacheFind(e,s,t,i),s),i=>(delete this._pendingQueries[e][t],utils.reject(i)))}return utils.resolve(o)}findAll(e,t,i={}){const s=this.getMapper(e),r=this.hashQuery(e,t,i),n=this._pendingQueries[e][r],o=void 0===i.usePendingFindAll?this.usePendingFindAll:i.usePendingFindAll;if(utils._(i,s),n&&(utils.isFunction(o)?o.call(this,e,t,i):o))return n;const l=this.cachedFindAll(e,r,i);if(i.force||!l){return(this._pendingQueries[e][r]=super.findAll(e,t,i)).then(t=>(delete this._pendingQueries[e][r],t=this._end(e,t,i),this.cacheFindAll(e,t,r,i),t),t=>(delete this._pendingQueries[e][r],utils.reject(t)))}return utils.resolve(l)}getCollection(e){const t=this._collections[e];if(!t)throw utils.err(`${DOMAIN$8}#getCollection`,e)(404,"collection");return t}hashQuery(e,t,i){return utils.toJson(t||{})}inject(e,t,i){return console.warn('DEPRECATED: "inject" is deprecated, use "add" instead'),this.add(e,t,i)}remove(e,t,i){const s=this.getCollection(e).remove(t,i);return s&&this.removeRelated(e,[s],i),s}removeAll(e,t,i){t&&Object.keys(t).length?this._completedQueries[e][this.hashQuery(e,t,i)]=void 0:this._completedQueries[e]={};const s=this.getCollection(e).removeAll(t,i);return s.length&&this.removeRelated(e,s,i),s}removeRelated(e,t,i){utils.isArray(t)||(t=[t]),utils.forEachRelation(this.getMapper(e),i,(e,i)=>{t.forEach(t=>{let s,r;if(!e.foreignKey||e.type!==hasOneType&&e.type!==hasManyType?e.type===hasManyType&&e.localKeys?r={where:{[e.getRelation().idAttribute]:{in:utils.get(t,e.localKeys)}}}:e.type===hasManyType&&e.foreignKeys?r={where:{[e.foreignKeys]:{contains:e.getForeignKey(t)}}}:e.type===belongsToType&&(s=this.remove(e.relation,e.getForeignKey(t),i)):r={[e.foreignKey]:e.getForeignKey(t)},r&&(s=this.removeAll(e.relation,r,i)),s){if(utils.isArray(s)&&!s.length)return;e.type===hasOneType&&(s=s[0]),e.setLocalField(t,s)}})})}update(e,t,i,s={}){return super.update(e,t,i,s).then(t=>this._end(e,t,s))}updateAll(e,t,i,s={}){return super.updateAll(e,t,i,s).then(t=>this._end(e,t,s))}updateMany(e,t,i={}){return super.updateMany(e,t,i).then(t=>this._end(e,t,i))}add(e,t,i){return this.getCollection(e).add(t,i)}between(e,t,i,s){return this.getCollection(e).between(t,i,s)}createIndex(e,t,i,s){return this.getCollection(e).createIndex(t,i,s)}filter(e,t,i){return this.getCollection(e).filter(t,i)}get(e,t){return this.getCollection(e).get(t)}getAll(e,...t){return this.getCollection(e).getAll(...t)}prune(e,t){return this.getCollection(e).prune(t)}query(e){return this.getCollection(e).query()}toJSON(e,t){return this.getCollection(e).toJSON(t)}unsaved(e,t){return this.getCollection(e).unsaved(t)}}const DOMAIN$9="LinkedCollection";class LinkedCollection extends Collection{constructor(e,t){if(super(e,t),!this.datastore)throw utils.err(`new ${DOMAIN$9}`,"opts.datastore")(400,"DataStore",this.datastore)}_addMeta(e,t){this._added[this.recordId(e)]=t,utils.isFunction(e._set)&&e._set("$",t)}_clearMeta(e){delete this._added[this.recordId(e)],utils.isFunction(e._set)&&e._set("$")}_onRecordEvent(...e){Collection.prototype._onRecordEvent.apply(this,e);const t=e[0];utils.isString(t)&&0===t.indexOf("change")&&this.updateIndexes(e[1])}add(e,t){const i=this.mapper,s=(new Date).getTime(),r=utils.isObject(e)&&!utils.isArray(e);return r&&(e=[e]),e=super.add(e,t),i.relationList.length&&e.length&&i.relationList.forEach(t=>{t.addLinkedRecords(e)}),e.forEach(e=>this._addMeta(e,s)),r?e[0]:e}remove(e,t){const i=this.mapper,s=super.remove(e,t);return s&&this._clearMeta(s),i.relationList.length&&s&&i.relationList.forEach(e=>{e.removeLinkedRecords(i,[s])}),s}removeAll(e,t){const i=this.mapper,s=super.removeAll(e,t);return s.forEach(this._clearMeta,this),i.relationList.length&&s.length&&i.relationList.forEach(e=>{e.removeLinkedRecords(i,s)}),s}}const DATASTORE_DEFAULTS={unlinkOnDestroy:!0,collectionClass:LinkedCollection};class DataStore extends SimpleStore{constructor(e={}){super(Object.assign(Object.assign({},DATASTORE_DEFAULTS),e))}defineMapper(e,t){const i=this,s=super.defineMapper(e,t),r=s.idAttribute,n=this.getCollection(e);return s.relationList.forEach(e=>{const t=e.relation,o=e.localField,l=`links.${o}`,a=e.foreignKey,h=e.type,u={index:a};let d;const c=function(){return this._get(l)};if(h===belongsToType){n.indexes[a]||n.createIndex(a),d={get:c,set(h){const d=this._get(l);if(h===d)return d;const c=utils.get(this,r),p=e.getInverse(s);if(d&&p&&this.removeInverseRelation(d,c,p,r),h){const s=e.getRelation().idAttribute,l=utils.get(h,s);void 0!==l&&this._get("$")&&(h=i.get(t,l)||h),safeSetLink(this,o,h),safeSetProp(this,a,l),n.updateIndex(this,u),p&&this.setupInverseRelation(h,c,p,r)}else safeSetLink(this,o,void 0);return h}};let h=Object.getOwnPropertyDescriptor(s.recordClass.prototype,a);h||(h={enumerable:!0});const p=h.get;h.get=function(){return p?p.call(this):this._get(`props.${a}`)};const f=h.set;h.set=function(l){f&&f.call(this,l);const h=utils.get(this,o),d=utils.get(this,r),c=e.getInverse(s),p=h?utils.get(h,e.getRelation().idAttribute):void 0;if(c&&h&&void 0!==p&&p!==l)if(c.type===hasOneType)safeSetLink(h,c.localField,void 0);else if(c.type===hasManyType){const e=utils.get(h,c.localField);void 0===d?utils.remove(e,e=>e===this):utils.remove(e,e=>e===this||d===utils.get(e,r))}if(safeSetProp(this,a,l),n.updateIndex(this,u),null==l)void 0!==p&&utils.set(this,o,void 0);else if(this._get("$")){const e=i.get(t,l);e&&utils.set(this,o,e)}},Object.defineProperty(s.recordClass.prototype,a,h)}else if(h===hasManyType){const n=e.localKeys,h=e.foreignKeys;i._collections[t]&&a&&!i.getCollection(t).indexes[a]&&i.getCollection(t).createIndex(a),d={get(){return c.call(this)||this._set(l,[]),c.call(this)},set(d){d&&!utils.isArray(d)&&(d=[d]);const c=utils.get(this,r),p=e.getRelation().idAttribute,f=e.getInverse(s),g=f.localField,y=this._get(l)||[],m=[],v={};if(d&&d.forEach(e=>{const s=utils.get(e,p),r=utils.get(e,g);if(r&&r!==this){const t=utils.get(r,o);void 0===s?utils.remove(t,t=>t===e):utils.remove(t,t=>t===e||s===utils.get(t,p))}void 0!==s&&(this._get("$")&&(e=i.get(t,s)||e),v[s]=e),m.push(e)}),a)y.forEach(e=>{const s=utils.get(e,p);(void 0===s&&-1===m.indexOf(e)||void 0!==s&&!(s in v))&&(d&&(safeSetProp(e,a,void 0),i.getCollection(t).updateIndex(e,u)),safeSetLink(e,g,void 0))}),m.forEach(e=>{safeSetProp(e,a,c),i.getCollection(t).updateIndex(e,u),safeSetLink(e,g,this)});else if(n){const e=m.map(e=>utils.get(e,p)).filter(e=>void 0!==e);utils.set(this,n,e),f.foreignKeys&&(y.forEach(e=>{const t=utils.get(e,p);if(void 0===t&&-1===m.indexOf(e)||void 0!==t&&!(t in v)){const t=utils.get(e,g)||[];void 0===c?utils.remove(t,e=>e===this):utils.remove(t,e=>e===this||c===utils.get(e,r))}}),m.forEach(e=>{const t=utils.get(e,g);void 0===c?utils.noDupeAdd(t,this,e=>e===this):utils.noDupeAdd(t,this,e=>e===this||c===utils.get(e,r))}))}else h&&(y.forEach(e=>{const t=utils.get(e,h)||[];utils.remove(t,e=>c===e);const i=utils.get(e,g);void 0===c?utils.remove(i,e=>e===this):utils.remove(i,e=>e===this||c===utils.get(e,r))}),m.forEach(e=>{const t=utils.get(e,h)||[];utils.noDupeAdd(t,c,e=>c===e);const i=utils.get(e,g);void 0===c?utils.noDupeAdd(i,this,e=>e===this):utils.noDupeAdd(i,this,e=>e===this||c===utils.get(e,r))}));return this._set(l,m),m}}}else h===hasOneType&&(i._collections[t]&&a&&!i.getCollection(t).indexes[a]&&i.getCollection(t).createIndex(a),d={get:c,set(n){const h=this._get(l);if(n===h)return h;const d=e.getInverse(s).localField;if(h&&(safeSetProp(h,a,void 0),i.getCollection(t).updateIndex(h,u),safeSetLink(h,d,void 0)),n){const s=utils.get(n,e.getRelation().idAttribute);void 0!==s&&(n=i.get(t,s)||n),safeSetLink(this,o,n),safeSetProp(n,a,utils.get(this,r)),i.getCollection(t).updateIndex(n,u),safeSetLink(n,d,this)}else safeSetLink(this,o,void 0);return n}});if(d){if(d.enumerable=void 0!==e.enumerable&&e.enumerable,e.get){const t=d.get;d.get=function(){return e.get(e,this,(...e)=>t.apply(this,e))}}if(e.set){const t=d.set;d.set=function(i){return e.set(e,this,i,e=>t.call(this,void 0===e?i:e))}}Object.defineProperty(s.recordClass.prototype,o,d)}}),s}destroy(e,t,i={}){return super.destroy(e,t,i).then(t=>{let s;if((s=i.raw?t.data:t)&&this.unlinkOnDestroy){const t=utils.plainCopy(i);t.withAll=!0,utils.forEachRelation(this.getMapper(e),t,e=>{utils.set(s,e.localField,void 0)})}return t})}destroyAll(e,t,i={}){return super.destroyAll(e,t,i).then(t=>{var s;let r;if((null===(s=r=i.raw?t.data:t)||void 0===s?void 0:s.length)&&this.unlinkOnDestroy){const t=utils.plainCopy(i);t.withAll=!0,utils.forEachRelation(this.getMapper(e),t,e=>{r.forEach(t=>{utils.set(t,e.localField,void 0)})})}return t})}}const version={beta:4,full:"4.0.0-beta.4",major:4,minor:0,patch:0};export{Collection,Component,Container,DataStore,Index,LinkedCollection,Mapper,Query,Record,Schema,Settable,SimpleStore,belongsTo,belongsToType,hasMany,hasManyType,hasOne,hasOneType,utils,version};
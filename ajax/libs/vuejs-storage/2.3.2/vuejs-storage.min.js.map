{"version":3,"file":"vuejs-storage.min.js","sources":["../src/lsstorage.ts","../src/objpath.ts","../src/assign.ts","../src/install.ts","../src/index.ts","../src/vuexplugin.ts"],"sourcesContent":["import { Option } from './interfaces'\n\n/**\n * Create customize localStorage\n */\nexport default class LSStorage {\n\tprivate storage: Storage\n\tprivate stringify: (any) => string\n\tprivate parse: (string) => any\n\tconstructor({ storage = window.localStorage, stringify = JSON.stringify, parse = JSON.parse }: Option) {\n\t\tthis.storage = storage\n\t\tthis.stringify = stringify\n\t\tthis.parse = parse\n\t}\n\tset(key, value) {\n\t\tthis.storage.setItem(key, this.stringify(value))\n\t}\n\tget(key) {\n\t\treturn this.parse(this.storage.getItem(key))\n\t}\n\thas(key) {\n\t\treturn this.storage.getItem(key) != null\n\t}\n}\n","export function parsePath(path: string): string[] {\n\treturn path\n\t\t.replace(/\\[([^[\\]]*)\\]/g, '.$1.')\n\t\t.split('.')\n\t\t.filter(t => t !== '')\n}\nexport function get(obj: object, path: string): any {\n\treturn parsePath(path).reduce((prev, cur) => prev && prev[cur], obj)\n}\nexport function set(obj: object, path: string, value: any): void {\n\tconst paths = parsePath(path)\n\tlet cur = obj\n\tfor (let i = 0; i < paths.length - 1; i++) {\n\t\tconst pname = paths[i]\n\t\tif (!cur.hasOwnProperty(pname)) cur[pname] = {}\n\t\tcur = cur[pname]\n\t}\n\tcur[paths[paths.length - 1]] = value\n}\nexport function copy(dest: object, source: object, path: string): void {\n\tset(dest, path, get(source, path))\n}\n","// a simple object merge function implementation\nexport default function(obj1, ...objs) {\n\tfor (const obj2 of objs) {\n\t\tfor (const k in obj2) {\n\t\t\tif (!obj2.hasOwnProperty(k)) continue\n\t\t\tobj1[k] = obj2[k]\n\t\t}\n\t}\n\treturn obj1\n}\n","import { Vue, VueConstructor, Option } from './interfaces'\nimport LSStorage from './lsstorage'\nimport { set, copy } from './objpath'\n\nimport assign from './assign'\n\nfunction applyPersistence(vm, option: Option) {\n\tconst { keys, merge = assign, namespace: ns } = option\n\n\tconst ls = new LSStorage(option)\n\n\tlet optdata = {}\n\tfor (const k of keys) {\n\t\tcopy(optdata, vm, k)\n\t}\n\n\tlet data = null\n\tif (ls.has(ns)) {\n\t\tdata = ls.get(ns)\n\t} else {\n\t\tconst tmp = {}\n\t\tfor (const k of keys) {\n\t\t\tcopy(tmp, optdata, k)\n\t\t}\n\t\tdata = tmp\n\t}\n\tls.set(ns, data)\n\tdata = merge(optdata, data)\n\tfor (const k of keys) {\n\t\tcopy(vm, data, k)\n\t\tvm.$watch(k, {\n\t\t\thandler: value => {\n\t\t\t\tset(data, k, value)\n\t\t\t\tls.set(ns, data)\n\t\t\t},\n\t\t\tdeep: true\n\t\t})\n\t}\n}\n\nexport function install(Vue: VueConstructor) {\n\tVue.mixin({\n\t\tcreated() {\n\t\t\tif ('storage' in this.$options) {\n\t\t\t\tconst option: Option | Option[] = this.$options.storage\n\t\t\t\tif (Array.isArray(option)) {\n\t\t\t\t\toption.forEach(opt => applyPersistence(this, opt))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tapplyPersistence(this, option)\n\t\t\t}\n\t\t}\n\t})\n}\n","import { Vue, VueConstructor, VuexPlugin } from './interfaces'\n\nimport { install } from './install'\nimport { createVuexPlugin } from './vuexplugin'\n\ninterface vjs {\n\t(): VuexPlugin<Object>\n\tinstall: (Vue: VueConstructor) => any\n}\nconst vuejsStorage = <vjs>function(option) {\n\treturn createVuexPlugin(option)\n}\nvuejsStorage.install = install\n\nexport default vuejsStorage\n","import { Store, VuexPlugin, Option } from './interfaces'\nimport { copy } from './objpath'\nimport LSStorage from './lsstorage'\n\nimport assign from './assign'\n\n/**\n * Create Vuex plugin\n */\nexport function createVuexPlugin(option: Option): VuexPlugin<Object> {\n\tconst ls = new LSStorage(option)\n\tconst { keys, merge = assign, namespace: ns } = option\n\treturn (store: Store<Object>) => {\n\t\tlet data = null\n\t\tif (ls.has(ns)) {\n\t\t\tdata = ls.get(ns)\n\t\t} else {\n\t\t\tconst obj = {}\n\t\t\tfor (const k of keys) {\n\t\t\t\tcopy(obj, store.state, k)\n\t\t\t}\n\t\t\tdata = obj\n\t\t}\n\t\tstore.replaceState(merge(store.state, data)) //merge state\n\t\tls.set(ns, data)\n\t\tstore.subscribe((mutation, state) => {\n\t\t\tconst obj = {}\n\t\t\tfor (const k of keys) {\n\t\t\t\tcopy(obj, state, k)\n\t\t\t}\n\t\t\tdata = obj\n\t\t\tls.set(ns, obj)\n\t\t})\n\t}\n}\n"],"names":["_a","_b","storage","_c","stringify","_d","parse","this","LSStorage","key","value","setItem","getItem","path","replace","split","filter","t","obj","paths","parsePath","cur","i","length","pname","hasOwnProperty","dest","source","set","reduce","prev","get","obj1","_i","objs","objs_1","obj2","k","vm","option","keys","merge","ns","ls","optdata","keys_1","copy","data","has","tmp","keys_2","$watch","handler","deep","keys_3","vuejsStorage","store","state","replaceState","subscribe","mutation","createVuexPlugin","install","Vue","mixin","created","$options","Array","isArray","forEach","opt","applyPersistence","_this"],"mappings":"wLAKe,iBAId,WAAYA,OAAEC,YAAAC,mCAA+BC,cAAAC,8BAA4BC,UAAAC,0BACxEC,KAAKL,QAAUA,EACfK,KAAKH,UAAYA,EACjBG,KAAKD,MAAQA,EAWf,OATCE,gBAAA,SAAIC,EAAKC,GACRH,KAAKL,QAAQS,QAAQF,EAAKF,KAAKH,UAAUM,KAE1CF,gBAAA,SAAIC,GACH,OAAOF,KAAKD,MAAMC,KAAKL,QAAQU,QAAQH,KAExCD,gBAAA,SAAIC,GACH,OAAoC,MAA7BF,KAAKL,QAAQU,QAAQH,oBCrBJI,GACzB,OAAOA,EACLC,QAAQ,iBAAkB,QAC1BC,MAAM,KACNC,OAAO,SAAAC,GAAK,MAAM,KAANA,eAKKC,EAAaL,EAAcH,GAG9C,IAFA,IAAMS,EAAQC,EAAUP,GACpBQ,EAAMH,EACDI,EAAI,EAAGA,EAAIH,EAAMI,OAAS,EAAGD,IAAK,CAC1C,IAAME,EAAQL,EAAMG,GACfD,EAAII,eAAeD,KAAQH,EAAIG,OACpCH,EAAMA,EAAIG,GAEXH,EAAIF,EAAMA,EAAMI,OAAS,IAAMb,aAEXgB,EAAcC,EAAgBd,GAClDe,EAAIF,EAAMb,WAdSK,EAAaL,GAChC,OAAOO,EAAUP,GAAMgB,OAAO,SAACC,EAAMT,GAAQ,OAAAS,GAAQA,EAAKT,IAAMH,GAahDa,CAAIJ,EAAQd,eCnBLmB,OAAM,aAAAC,mBAAAA,IAAAC,oBAC7B,IAAmB,QAAAC,IAAAnC,WAAAA,KAAd,IAAMoC,OACV,IAAK,IAAMC,KAAKD,EACVA,EAAKX,eAAeY,KACzBL,EAAKK,GAAKD,EAAKC,IAGjB,OAAOL,ECFR,WAA0BM,EAAIC,GAM7B,IALQ,IAAAC,SAAMxC,UAAAyC,iBAAgBC,cAExBC,EAAK,IAAInC,EAAU+B,GAErBK,SACYC,IAAAZ,WAAAA,KAAX,IAAMI,OACVS,EAAKF,EAASN,EAAID,GAGnB,IAAIU,EAAO,KACX,GAAIJ,EAAGK,IAAIN,GACVK,EAAOJ,EAAGZ,IAAIW,OACR,CAEN,IADA,IAAMO,SACUC,IAAAjD,WAAAA,KACf6C,EAAKG,EAAKL,EADAP,QAGXU,EAAOE,EAERN,EAAGf,IAAIc,EAAIK,GACXA,EAAON,EAAMG,EAASG,GACtB,mBAAWV,GACVS,EAAKR,EAAIS,EAAMV,GACfC,EAAGa,OAAOd,GACTe,QAAS,SAAA1C,GACRkB,EAAImB,EAAMV,EAAG3B,GACbiC,EAAGf,IAAIc,EAAIK,IAEZM,MAAM,SAPQC,IAAAnD,WAAAA,OAALkC,SCnBZ,IAAMkB,EAAoB,SAAShB,GAClC,gBCDgCA,GAChC,IAAMI,EAAK,IAAInC,EAAU+B,GACjBC,SAAMxC,UAAAyC,iBAAgBC,cAC9B,OAAO,SAACc,GACP,IAAIT,EAAO,KACX,GAAIJ,EAAGK,IAAIN,GACVK,EAAOJ,EAAGZ,IAAIW,OACR,CAEN,IADA,IAAMxB,SACU2B,IAAAZ,WAAAA,KAAX,IAAMI,OACVS,EAAK5B,EAAKsC,EAAMC,MAAOpB,GAExBU,EAAO7B,EAERsC,EAAME,aAAajB,EAAMe,EAAMC,MAAOV,IACtCJ,EAAGf,IAAIc,EAAIK,GACXS,EAAMG,UAAU,SAACC,EAAUH,GAE1B,IADA,IAAMvC,SACUgC,IAAAjB,WAAAA,IACfa,EAAK5B,EAAKuC,QAEXV,EAAO7B,EACPyB,EAAGf,IAAIc,EAAIxB,MDrBN2C,CAAiBtB,WAEzBgB,EAAaO,iBD4BWC,GACvBA,EAAIC,OACHC,mBAAA,WACC,GAAI,YAAa1D,KAAK2D,SAAU,CAC/B,IAAM3B,EAA4BhC,KAAK2D,SAAShE,QAChD,GAAIiE,MAAMC,QAAQ7B,GAEjB,YADAA,EAAO8B,QAAQ,SAAAC,GAAO,OAAAC,EAAiBC,EAAMF,KAG9CC,EAAiBhE,KAAMgC"}
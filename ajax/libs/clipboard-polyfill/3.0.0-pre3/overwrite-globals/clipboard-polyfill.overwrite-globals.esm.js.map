{"version":3,"file":"clipboard-polyfill.overwrite-globals.esm.js","sources":["../../src/globals.ts","../../src/ClipboardItem/check.ts","../../src/ClipboardItem/ClipboardItemPolyfill.ts","../../src/ClipboardItem/convert.ts","../../src/ClipboardItem/data-types.ts","../../src/debug.ts","../../src/strategies/dom.ts","../../src/strategies/internet-explorer.ts","../../src/clipboard-polyfill.ts","../../src/index.overwrite-globals.ts"],"sourcesContent":["\n// We cache the references so that callers can do the following without causing infinite recursion/bugs:\n//\n//     import * as clipboard from \"clipboard-polyfill\";\n//     navigator.clipboard = clipboard;\n//\n//     import { ClipboardItem } from \"clipboard-polyfill\";\n//     window.ClipboardItem = clipboard;\n//\n// Note that per the spec:\n//\n// - is *not* possible to overwrite `navigator.clipboard`. https://www.w3.org/TR/clipboard-apis/#navigator-interface\n// - it *may* be possible to overwrite `window.ClipboardItem`.\n//\n// Chrome 83 and Safari 13.1 match this. We save the original\n// `navigator.clipboard` anyhow, because 1) it doesn't cost more code (in fact,\n// it probably saves code), and 2) just in case an unknown/future implementation\n// allows overwriting `navigator.clipboard` like this.\n\nimport { ClipboardItemConstructor, Clipboard, ClipboardItems } from \"./ClipboardItem/spec\";\n\nconst originalNavigatorClipboard: Clipboard | undefined = navigator.clipboard as any;\nexport const originalNavigatorClipboardRead: (() => Promise<ClipboardItems>) | undefined = originalNavigatorClipboard?.read.bind(originalNavigatorClipboard);\nexport const originalNavigatorClipboardReadText: (() => Promise<string>) | undefined = originalNavigatorClipboard?.readText.bind(originalNavigatorClipboard);\nexport const originalNavigatorClipboardWrite: ((data: ClipboardItems) => Promise<void>) | undefined = originalNavigatorClipboard?.write.bind(originalNavigatorClipboard);\nexport const originalNavigatorClipboardWriteText: ((data: string) => Promise<void>) | undefined = originalNavigatorClipboard?.writeText.bind(originalNavigatorClipboard);\n\n// The spec specifies that this goes on `window`, not e.g. `globalThis`. It's not (currently) available in workers.\nexport const originalWindowClipboardItem: ClipboardItemConstructor | undefined = window.ClipboardItem;\n","import { ClipboardItemInterface } from \"./spec\";\n\nexport function hasItemWithType(\n  clipboardItems: ClipboardItemInterface[],\n  typeName: string\n): boolean {\n  for (const item of clipboardItems) {\n    if (item.types.indexOf(typeName) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { stringToBlob } from \"./convert\";\nimport {\n  ClipboardItemConstructor,\n  ClipboardItemDataType,\n  ClipboardItemInterface,\n  ClipboardItemOptions,\n  PresentationStyle,\n} from \"./spec\";\n\nexport class ClipboardItemPolyfillImpl implements ClipboardItemInterface {\n  public readonly types: string[];\n  public readonly presentationStyle: PresentationStyle;\n  // We use an underscore to suggest that this field is private. We could\n  // theoretically transpile private fields to closure-scoped vars, but\n  // TypeScript doesn't do this. So we do the most compatible thing, and only\n  // mark it as private.\n  private _items: { [type: string]: Blob };\n  public constructor(\n    // TODO: The spec specifies values as `ClipboardItemData`, but\n    // implementations (e.g. Chrome 83) seem to assume `ClipboardItemDataType`\n    // values. https://github.com/w3c/clipboard-apis/pull/126\n    items: { [type: string]: ClipboardItemDataType },\n    options: ClipboardItemOptions = {}\n  ) {\n    this.types = Object.keys(items);\n    this._items = {};\n    // We avoid `Object.entries()` to avoid potential compatibility issues.\n    for (const type in items) {\n      const item = items[type];\n      if (typeof item === \"string\") {\n        this._items[type] = stringToBlob(type, item);\n      } else {\n        this._items[type] = item;\n      }\n    }\n    // The explicit default for `presentationStyle` is \"unspecified\":\n    // https://www.w3.org/TR/clipboard-apis/#clipboard-interface\n    this.presentationStyle = options?.presentationStyle ?? \"unspecified\";\n  }\n\n  public async getType(type: string): Promise<Blob> {\n    return this._items[type];\n  }\n}\n\nexport const ClipboardItemPolyfill: ClipboardItemConstructor = ClipboardItemPolyfillImpl;\n","import { ClipboardItemPolyfill } from \"./ClipboardItemPolyfill\";\nimport { TEXT_PLAIN } from \"./data-types\";\nimport { ClipboardItemInterface, ClipboardItemOptions } from \"./spec\";\nimport { originalWindowClipboardItem } from \"../globals\";\n\nexport interface ClipboardItemAsResolvedText {\n  [type: string]: string;\n}\n\nexport function stringToBlob(type: string, str: string): Blob {\n  return new Blob([str], {\n    type,\n  });\n}\n\nexport async function blobToString(blob: Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.addEventListener(\"load\", () => {\n      const result = fileReader.result;\n      if (typeof result === \"string\") {\n        resolve(result);\n      } else {\n        reject(\"could not convert blob to string\");\n      }\n    });\n    fileReader.readAsText(blob);\n  });\n}\n\nexport async function clipboardItemToGlobalClipboardItem(\n  clipboardItem: ClipboardItemInterface\n): Promise<ClipboardItemInterface> {\n  // Note that we use `Blob` instead of `ClipboardItemDataType`. This is because\n  // Chrome 83 can only accept `Blob` (not `string`). The return value of\n  // `getType()` is already `Blob` per the spec, so this is simple for us.\n  const items: { [type: string]: Blob } = {};\n  for (const type of clipboardItem.types) {\n    items[type] = await clipboardItem.getType(type);\n  }\n  const options: ClipboardItemOptions = {};\n  if (clipboardItem.presentationStyle) {\n    options.presentationStyle = clipboardItem.presentationStyle;\n  }\n  return new originalWindowClipboardItem!(items, options);\n}\n\nexport function textToClipboardItem(text: string): ClipboardItemInterface {\n  const items: { [type: string]: Blob } = {};\n  items[TEXT_PLAIN] = stringToBlob(text, TEXT_PLAIN);\n  return new ClipboardItemPolyfill(items);\n}\n\nexport async function getTypeAsText(\n  clipboardItem: ClipboardItemInterface,\n  type: string\n): Promise<string> {\n  const text: Blob = await clipboardItem.getType(type);\n  return await blobToString(text);\n}\n\nexport async function resolveItemsToText(\n  data: ClipboardItemInterface\n): Promise<ClipboardItemAsResolvedText> {\n  const items: ClipboardItemAsResolvedText = {};\n  for (const type of data.types) {\n    items[type] = await getTypeAsText(data, type);\n    // Object.defineProperty(items, type, {\n    //   value: data.getType(type),\n    //   // tslint:disable-next-line: object-literal-sort-keys\n    //   enumerable: true,\n    // });\n  }\n  return items;\n}\n","export const TEXT_PLAIN = \"text/plain\";\nexport const TEXT_HTML = \"text/html\";\n","/******** Debug Logging ********/\n\n// tslint:disable-next-line: no-empty\nlet debugLogImpl = (s: string) => {};\n\nexport function debugLog(s: string) {\n  debugLogImpl(s);\n}\n\nexport function setDebugLog(logFn: (s: string) => void) {\n  debugLogImpl = logFn;\n}\n\n/******** Warnings ********/\n\nlet showWarnings = true;\n\nexport function suppressWarnings() {\n  showWarnings = false;\n}\n\nexport function shouldShowWarnings(): boolean {\n  return showWarnings;\n}\n\n// Workaround for:\n// - IE9 (can't bind console functions directly), and\n// - Edge Issue #14495220 (referencing `console` without F12 Developer Tools can cause an exception)\nfunction warnOrLog() {\n  // tslint:disable-next-line: no-console\n  (console.warn || console.log).apply(console, arguments);\n}\n\nexport const warn = warnOrLog.bind(\"[clipboard-polyfill]\");\n","import { ClipboardItemAsResolvedText } from \"../ClipboardItem/convert\";\nimport { TEXT_PLAIN } from \"../ClipboardItem/data-types\";\nimport { debugLog } from \"../debug\";\n\n/******** Implementations ********/\n\nclass FallbackTracker {\n  public success: boolean = false;\n}\n\nfunction copyListener(\n  tracker: FallbackTracker,\n  data: ClipboardItemAsResolvedText,\n  e: ClipboardEvent,\n): void {\n  debugLog(\"listener called\");\n  tracker.success = true;\n  // tslint:disable-next-line: forin\n  for (const type in data) {\n    const value = data[type];\n    const clipboardData = e.clipboardData!;\n    clipboardData.setData(type, value);\n    if (type === TEXT_PLAIN && clipboardData.getData(type) !== value) {\n      debugLog(\"setting text/plain failed\");\n      tracker.success = false;\n    }\n  }\n  e.preventDefault();\n}\n\nexport function execCopy(data: ClipboardItemAsResolvedText): boolean {\n  const tracker = new FallbackTracker();\n  const listener = copyListener.bind(this, tracker, data);\n\n  document.addEventListener(\"copy\", listener);\n  try {\n    // We ignore the return value, since FallbackTracker tells us whether the\n    // listener was called. It seems that checking the return value here gives\n    // us no extra information in any browser.\n    document.execCommand(\"copy\");\n  } finally {\n    document.removeEventListener(\"copy\", listener);\n  }\n  return tracker.success;\n}\n\n// Temporarily select a DOM element, so that `execCommand()` is not rejected.\nexport function copyUsingTempSelection(\n  e: HTMLElement,\n  data: ClipboardItemAsResolvedText,\n): boolean {\n  selectionSet(e);\n  const success = execCopy(data);\n  selectionClear();\n  return success;\n}\n\n// Create a temporary DOM element to select, so that `execCommand()` is not\n// rejected.\nexport function copyUsingTempElem(data: ClipboardItemAsResolvedText): boolean {\n  const tempElem = document.createElement(\"div\");\n  // Setting an individual property does not support `!important`, so we set the\n  // whole style instead of just the `-webkit-user-select` property.\n  tempElem.setAttribute(\"style\", \"-webkit-user-select: text !important\");\n  // Place some text in the elem so that Safari has something to select.\n  tempElem.textContent = \"temporary element\";\n  document.body.appendChild(tempElem);\n\n  const success = copyUsingTempSelection(tempElem, data);\n\n  document.body.removeChild(tempElem);\n  return success;\n}\n\n// Uses shadow DOM.\nexport function copyTextUsingDOM(str: string): boolean {\n  debugLog(\"copyTextUsingDOM\");\n\n  const tempElem = document.createElement(\"div\");\n  // Setting an individual property does not support `!important`, so we set the\n  // whole style instead of just the `-webkit-user-select` property.\n  tempElem.setAttribute(\"style\", \"-webkit-user-select: text !important\");\n  // Use shadow DOM if available.\n  let spanParent: Node = tempElem;\n  if (tempElem.attachShadow) {\n    debugLog(\"Using shadow DOM.\");\n    spanParent = tempElem.attachShadow({ mode: \"open\" });\n  }\n\n  const span = document.createElement(\"span\");\n  span.innerText = str;\n\n  spanParent.appendChild(span);\n  document.body.appendChild(tempElem);\n  selectionSet(span);\n\n  const result = document.execCommand(\"copy\");\n\n  selectionClear();\n  document.body.removeChild(tempElem);\n\n  return result;\n}\n\n/******** Selection ********/\n\nfunction selectionSet(elem: Element): void {\n  const sel = document.getSelection();\n  if (sel) {\n    const range = document.createRange();\n    range.selectNodeContents(elem);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n}\n\nfunction selectionClear(): void {\n  const sel = document.getSelection();\n  if (sel) {\n    sel.removeAllRanges();\n  }\n}\n","interface IEWindow extends Window {\n  clipboardData: {\n    setData: (key: string, value: string) => boolean;\n    // Always results in a string: https://msdn.microsoft.com/en-us/library/ms536436(v=vs.85).aspx\n    getData: (key: string) => string;\n  };\n}\n\nconst ieWindow = (window as unknown) as IEWindow;\n\nexport function seemToBeInIE(): boolean {\n  return (\n    typeof ClipboardEvent === \"undefined\" &&\n    typeof ieWindow.clipboardData !== \"undefined\" &&\n    typeof ieWindow.clipboardData.setData !== \"undefined\"\n  );\n}\n\nexport function writeTextIE(text: string): boolean {\n  // IE supports text or URL, but not HTML: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx\n  // TODO: Write URLs to `text/uri-list`? https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types\n  return ieWindow.clipboardData.setData(\"Text\", text);\n}\n\n// Returns \"\" if the read failed, e.g. because the user rejected the permission.\nexport async function readTextIE(): Promise<string> {\n  const text = ieWindow.clipboardData.getData(\"Text\");\n  if (text === \"\") {\n    throw new Error(\n      \"Empty clipboard or could not read plain text from clipboard\"\n    );\n  }\n  return text;\n}\n","import { originalWindowClipboardItem, originalNavigatorClipboardWrite, originalNavigatorClipboardWriteText, originalNavigatorClipboardRead, originalNavigatorClipboardReadText } from \"./globals\";\nimport { hasItemWithType } from \"./ClipboardItem/check\";\nimport {\n  ClipboardItemAsResolvedText,\n  clipboardItemToGlobalClipboardItem,\n  getTypeAsText,\n  resolveItemsToText,\n  textToClipboardItem\n} from \"./ClipboardItem/convert\";\nimport { TEXT_HTML, TEXT_PLAIN } from \"./ClipboardItem/data-types\";\nimport { ClipboardItemInterface, ClipboardItems } from \"./ClipboardItem/spec\";\nimport { debugLog, shouldShowWarnings } from \"./debug\";\nimport {\n  copyTextUsingDOM,\n  copyUsingTempElem,\n  copyUsingTempSelection,\n  execCopy\n} from \"./strategies/dom\";\nimport {\n  readTextIE,\n  seemToBeInIE,\n  writeTextIE\n} from \"./strategies/internet-explorer\";\n\nexport async function write(data: ClipboardItemInterface[]): Promise<void> {\n  // Use the browser implementation if it exists.\n  // TODO: detect `text/html`.\n  if (\n    !hasItemWithType(data, TEXT_HTML) &&\n    originalNavigatorClipboardWrite &&\n    originalWindowClipboardItem\n  ) {\n    debugLog(\"Using `navigator.clipboard.write()`.\");\n    const globalClipboardItems: ClipboardItemInterface[] = await Promise.all(\n      data.map(clipboardItemToGlobalClipboardItem)\n    );\n    return originalNavigatorClipboardWrite(globalClipboardItems);\n  }\n\n  const hasTextPlain = hasItemWithType(data, TEXT_PLAIN);\n  if (shouldShowWarnings && !hasTextPlain) {\n    debugLog(\n      \"clipboard.write() was called without a \" +\n        \"`text/plain` data type. On some platforms, this may result in an \" +\n        \"empty clipboard. Call suppressWarnings() \" +\n        \"to suppress this warning.\"\n    );\n  }\n\n  // Internet Explorer\n  if (seemToBeInIE()) {\n    if (!hasTextPlain) {\n      throw new Error(\"No `text/plain` value was specified.\");\n    }\n    if (writeTextIE(await getTypeAsText(data[0], TEXT_PLAIN))) {\n      return;\n    } else {\n      throw new Error(\"Copying failed, possibly because the user rejected it.\");\n    }\n  }\n\n  const resolved: ClipboardItemAsResolvedText = await resolveItemsToText(\n    data[0]\n  );\n  if (execCopy(resolved)) {\n    debugLog(\"regular execCopy worked\");\n    return;\n  }\n\n  // Success detection on Edge is not possible, due to bugs in all 4\n  // detection mechanisms we could try to use. Assume success.\n  if (navigator.userAgent.indexOf(\"Edge\") > -1) {\n    debugLog('UA \"Edge\" => assuming success');\n    return;\n  }\n\n  // Fallback 1 for desktop Safari.\n  if (copyUsingTempSelection(document.body, resolved)) {\n    debugLog(\"copyUsingTempSelection worked\");\n    return;\n  }\n\n  // Fallback 2 for desktop Safari.\n  if (copyUsingTempElem(resolved)) {\n    debugLog(\"copyUsingTempElem worked\");\n    return;\n  }\n\n  // Fallback for iOS Safari.\n  if (copyTextUsingDOM(await getTypeAsText(data[0], TEXT_PLAIN))) {\n    debugLog(\"copyTextUsingDOM worked\");\n    return;\n  }\n\n  throw new Error(\"Copy command failed.\");\n}\n\nexport async function writeText(s: string): Promise<void> {\n  // Use the browser implementation if it exists.\n  if (originalNavigatorClipboardWriteText) {\n    debugLog(\"Using `navigator.clipboard.writeText()`.\");\n    return originalNavigatorClipboardWriteText(s);\n  }\n\n  // Fall back to the general writing strategy.\n  return write([textToClipboardItem(s)]);\n}\n\nexport async function read(): Promise<ClipboardItems> {\n  // Use the browser implementation if it exists.\n  if (originalNavigatorClipboardRead) {\n    debugLog(\"Using `navigator.clipboard.read()`.\");\n    return originalNavigatorClipboardRead();\n  }\n\n  // Fallback to reading text only.\n  return [textToClipboardItem(await readText())];\n}\n\nexport async function readText(): Promise<string> {\n  // Use the browser implementation if it exists.\n  if (originalNavigatorClipboardReadText) {\n    debugLog(\"Using `navigator.clipboard.readText()`.\");\n    return originalNavigatorClipboardReadText();\n  }\n\n  // Fallback for IE.\n  if (seemToBeInIE()) {\n    debugLog(\"Reading text using IE strategy.\");\n    return readTextIE();\n  }\n\n  throw new Error(\"Read is not supported in your browser.\");\n}\n","// Import `./globals` that the globals are cached before this runs.\nimport { read, readText, write, writeText } from \"./clipboard-polyfill\";\nimport { ClipboardItemPolyfill } from \"./ClipboardItem/ClipboardItemPolyfill\";\nimport { Clipboard as ClipboardInterface, ClipboardItemConstructor } from \"./ClipboardItem/spec\";\nimport \"./globals\";\n\ndeclare global {\n  const ClipboardItem: ClipboardItemConstructor;\n  interface Window {\n    ClipboardItem: ClipboardItemConstructor;\n  }\n  interface Clipboard extends ClipboardInterface {}\n}\n\nif (navigator) {\n  // Create the `navigator.clipboard` object if it doesn't exist.\n  (navigator as any).clipboard = navigator.clipboard ?? {};\n\n  // Set/replace the implementations.\n  navigator.clipboard.read = read;\n  navigator.clipboard.readText = readText;\n  navigator.clipboard.write = write;\n  navigator.clipboard.writeText = writeText;\n}\n\nif (window) {\n  window.ClipboardItem = ClipboardItemPolyfill;\n}\n"],"names":["originalNavigatorClipboard","navigator","clipboard","originalNavigatorClipboardRead","read","bind","originalNavigatorClipboardReadText","readText","originalNavigatorClipboardWrite","write","originalNavigatorClipboardWriteText","writeText","originalWindowClipboardItem","window","ClipboardItem","hasItemWithType","clipboardItems","typeName","clipboardItems_1","_i","types","indexOf","ClipboardItemPolyfill","items","options","type","this","Object","keys","_items","item","stringToBlob","presentationStyle","ClipboardItemPolyfillImpl","str","Blob","blobToString","blob","Promise","resolve","reject","fileReader","FileReader","addEventListener","result","readAsText","clipboardItemToGlobalClipboardItem","clipboardItem","_a","_b","_c","getType","_d","textToClipboardItem","text","getTypeAsText","resolveItemsToText","data","console","warn","log","apply","arguments","copyListener","tracker","e","success","value","clipboardData","setData","getData","preventDefault","execCopy","FallbackTracker","listener","document","execCommand","removeEventListener","copyUsingTempSelection","selectionSet","selectionClear","copyTextUsingDOM","tempElem","createElement","setAttribute","spanParent","attachShadow","mode","span","innerText","appendChild","body","removeChild","elem","sel","getSelection","range","createRange","selectNodeContents","removeAllRanges","addRange","ieWindow","seemToBeInIE","ClipboardEvent","writeTextIE","readTextIE","Error","all","map","globalClipboardItems","hasTextPlain","resolved","userAgent","textContent","copyUsingTempElem","s"],"mappings":"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"}
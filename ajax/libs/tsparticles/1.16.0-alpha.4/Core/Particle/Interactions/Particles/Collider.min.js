"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Collider=void 0;const Utils_1=require("../../../../Utils"),Enums_1=require("../../../../Enums");class Collider{static collide(i,e,s){const t=i.getPosition(),o=e.particles.quadTree.query(new Utils_1.Circle(t.x,t.y,2*i.size.value));for(const s of o){if(i===s||!s.particlesOptions.collisions.enable||i.particlesOptions.collisions.mode!==s.particlesOptions.collisions.mode)continue;const o=s.getPosition(),l=Utils_1.Utils.getDistance(t,o),a=e.retina.sizeValue;l<=this.getRadius(i,a)+this.getRadius(s,a)&&this.resolveCollision(i,s,e)}}static getRadius(i,e){return i.bubble.radius||i.size.value||e}static resolveCollision(i,e,s){const t=i.getPosition(),o=e.getPosition(),l=s.options.fpsLimit/1e3;switch(i.particlesOptions.collisions.mode){case Enums_1.CollisionMode.absorb:if(void 0===i.size.value&&void 0!==e.size.value)i.destroy();else if(void 0!==i.size.value&&void 0===e.size.value)e.destroy();else if(void 0!==i.size.value&&void 0!==e.size.value)if(i.size.value>=e.size.value){const t=Utils_1.Utils.clamp(i.size.value/e.size.value,0,e.size.value)*l;i.size.value+=t,e.size.value-=t,e.size.value<=s.retina.pixelRatio&&(e.size.value=0,e.destroy())}else{const t=Utils_1.Utils.clamp(e.size.value/i.size.value,0,i.size.value)*l;i.size.value-=t,e.size.value+=t,i.size.value<=s.retina.pixelRatio&&(i.size.value=0,i.destroy())}break;case Enums_1.CollisionMode.bounce:{const s=i.velocity.horizontal-e.velocity.horizontal,l=i.velocity.vertical-e.velocity.vertical;if(s*(o.x-t.x)+l*(o.y-t.y)>=0){const s=-Math.atan2(o.y-t.y,o.x-t.x),l=i.size.value,a=e.size.value,r=this.rotate(i.velocity,s),v=this.rotate(e.velocity,s),c=this.collisionVelocity(r,v,l,a),n=this.collisionVelocity(v,r,l,a),u=this.rotate(c,-s),z=this.rotate(n,-s);i.velocity.horizontal=u.horizontal,i.velocity.vertical=u.vertical,e.velocity.horizontal=z.horizontal,e.velocity.vertical=z.vertical}break}case Enums_1.CollisionMode.destroy:void 0===i.size.value&&void 0!==e.size.value?i.destroy():void 0!==i.size.value&&void 0===e.size.value?e.destroy():void 0!==i.size.value&&void 0!==e.size.value&&(i.size.value>=e.size.value?e.destroy():i.destroy())}}static rotate(i,e){return{horizontal:i.horizontal*Math.cos(e)-i.vertical*Math.sin(e),vertical:i.horizontal*Math.sin(e)+i.vertical*Math.cos(e)}}static collisionVelocity(i,e,s,t){return{horizontal:i.horizontal*(s-t)/(s+t)+2*e.horizontal*t/(s+t),vertical:i.vertical}}}exports.Collider=Collider;
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Mover=void 0;const Utils_1=require("../../Utils"),Enums_1=require("../../Enums");class Mover{constructor(t,i){this.container=t,this.particle=i}move(t){this.moveParticle(t),this.moveParallax()}moveParticle(t){var i;const e=this.particle,o=e.particlesOptions;if(!o.move.enable)return;const s=this.container,n=this.getProximitySpeedFactor(),r=(null!==(i=e.moveSpeed)&&void 0!==i?i:s.retina.moveSpeed)/2*n*t.factor;this.applyNoise(t),e.position.x+=e.velocity.horizontal*r,e.position.y+=e.velocity.vertical*r,o.move.vibrate&&(e.position.x+=Math.sin(e.position.x*Math.cos(e.position.y)),e.position.y+=Math.cos(e.position.y*Math.sin(e.position.x)))}applyNoise(t){const i=this.particle;if(!i.particlesOptions.move.noise.enable)return;const e=this.container;if(i.lastNoiseTime<=i.noiseDelay)return void(i.lastNoiseTime+=t.value);const o=e.noise.generate(i);i.velocity.horizontal+=Math.cos(o.angle)*o.length,i.velocity.horizontal=Utils_1.Utils.clamp(i.velocity.horizontal,-1,1),i.velocity.vertical+=Math.sin(o.angle)*o.length,i.velocity.vertical=Utils_1.Utils.clamp(i.velocity.vertical,-1,1),i.lastNoiseTime-=i.noiseDelay}moveParallax(){const t=this.container,i=t.options;if(!i.interactivity.events.onHover.parallax.enable)return;const e=this.particle,o=i.interactivity.events.onHover.parallax.force,s=t.interactivity.mouse.position;if(!s)return;const n=window.innerHeight/2,r=window.innerWidth/2,a=i.interactivity.events.onHover.parallax.smooth,l=(s.x-r)*(e.size.value/o),c=(s.y-n)*(e.size.value/o);e.offset.x+=(l-e.offset.x)/a,e.offset.y+=(c-e.offset.y)/a}getProximitySpeedFactor(){const t=this.container,i=t.options;if(!Utils_1.Utils.isInArray(Enums_1.HoverMode.slow,i.interactivity.events.onHover.mode))return 1;const e=this.container.interactivity.mouse.position;if(!e)return 1;const o=this.particle.getPosition(),s=Utils_1.Utils.getDistance(e,o),n=t.retina.slowModeRadius;return s>n?1:(s/n||0)/i.interactivity.modes.slow.factor}}exports.Mover=Mover;
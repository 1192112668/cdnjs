"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Updater=void 0;const Utils_1=require("../../Utils"),Mover_1=require("./Mover"),Enums_1=require("../../Enums");class Updater{constructor(t,e){this.container=t,this.particle=e,this.mover=new Mover_1.Mover(t,e)}static checkBounds(t,e,i,o,s){(t+e>i&&o>0||t-e<0&&o<0)&&s()}update(t){this.particle.links=[],this.mover.move(t),this.updateOpacity(t),this.updateSize(t),this.updateAngle(t),this.updateColor(t),this.updateStrokeColor(t),this.fixOutOfCanvasPosition(),this.updateOutMode(t)}updateOpacity(t){const e=this.particle;if(e.particlesOptions.opacity.animation.enable){switch(e.opacity.status){case Enums_1.OpacityAnimationStatus.increasing:e.opacity.value>=e.particlesOptions.opacity.value?e.opacity.status=Enums_1.OpacityAnimationStatus.decreasing:e.opacity.value+=(e.opacity.velocity||0)*t.factor;break;case Enums_1.OpacityAnimationStatus.decreasing:e.opacity.value<=e.particlesOptions.opacity.animation.minimumValue?e.opacity.status=Enums_1.OpacityAnimationStatus.increasing:e.opacity.value-=(e.opacity.velocity||0)*t.factor}e.opacity.value<0&&(e.opacity.value=0)}}updateSize(t){var e;const i=this.container,o=this.particle,s=o.particlesOptions.size,a=s.animation;if(a.enable){switch(o.size.status){case Enums_1.SizeAnimationStatus.increasing:o.size.value>=(null!==(e=o.sizeValue)&&void 0!==e?e:i.retina.sizeValue)?o.size.status=Enums_1.SizeAnimationStatus.decreasing:o.size.value+=(o.size.velocity||0)*t.factor;break;case Enums_1.SizeAnimationStatus.decreasing:o.size.value<=a.minimumValue?o.size.status=Enums_1.SizeAnimationStatus.increasing:o.size.value-=(o.size.velocity||0)*t.factor}switch(a.destroy){case Enums_1.DestroyType.max:o.size.value>=s.value*i.retina.pixelRatio&&o.destroy();break;case Enums_1.DestroyType.min:o.size.value<=a.minimumValue*i.retina.pixelRatio&&o.destroy()}o.size.value<0&&!o.destroyed&&(o.size.value=0)}}updateAngle(t){const e=this.particle,i=e.particlesOptions.rotate.animation,o=i.speed/360*t.factor,s=2*Math.PI;if(i.enable)switch(e.rotateDirection){case Enums_1.RotateDirection.clockwise:e.angle+=o,e.angle>s&&(e.angle-=s);break;case Enums_1.RotateDirection.counterClockwise:default:e.angle-=o,e.angle<0&&(e.angle+=s)}}updateColor(t){const e=this.particle;void 0!==e.color&&e.particlesOptions.color.animation.enable&&(e.color.h+=(e.colorVelocity||0)*t.factor,e.color.h>360&&(e.color.h-=360))}updateStrokeColor(t){const e=this.particle,i=e.stroke.color;"string"!=typeof i&&void 0!==i&&void 0!==e.strokeColor&&i.animation.enable&&(e.strokeColor.h+=(e.colorVelocity||0)*t.factor,e.strokeColor.h>360&&(e.strokeColor.h-=360))}fixOutOfCanvasPosition(){const t=this.container,e=this.particle,i=e.particlesOptions.move.outMode,o=e.particlesOptions.move.warp,s=t.canvas.size;let a;if(a=i===Enums_1.OutMode.bounce?{bottom:s.height,left:e.size.value,right:s.width,top:e.size.value}:i===Enums_1.OutMode.bounceHorizontal?{bottom:s.height+e.size.value-e.offset.y,left:e.size.value,right:s.width,top:-e.size.value-e.offset.y}:i===Enums_1.OutMode.bounceVertical?{bottom:s.height,left:-e.size.value-e.offset.x,right:s.width+e.size.value+e.offset.x,top:e.size.value}:{bottom:s.height+e.size.value-e.offset.y,left:-e.size.value-e.offset.x,right:s.width+e.size.value+e.offset.x,top:-e.size.value-e.offset.y},i===Enums_1.OutMode.destroy){const i=e.size.value;Utils_1.Utils.isPointInside(e.position,t.canvas.size,i)||t.particles.remove(e)}else{const t=e.size.value,i=Utils_1.Utils.calculateBounds(e.position,t);i.left>s.width-e.offset.x?(e.position.x=a.left,o||(e.position.y=Math.random()*s.height)):i.right<-e.offset.x&&(e.position.x=a.right,o||(e.position.y=Math.random()*s.height)),i.top>s.height-e.offset.y?(o||(e.position.x=Math.random()*s.width),e.position.y=a.top):i.bottom<-e.offset.y&&(o||(e.position.x=Math.random()*s.width),e.position.y=a.bottom)}}updateOutMode(t){switch(this.particle.particlesOptions.move.outMode){case Enums_1.OutMode.bounce:case Enums_1.OutMode.bounceVertical:case Enums_1.OutMode.bounceHorizontal:this.updateBounce(t)}}updateBounce(t){const e=this.container,i=this.particle;let o=!1;for(const[,s]of e.plugins)if(void 0!==s.particleBounce&&(o=s.particleBounce(i,t)),o)break;if(!o){const t=i.particlesOptions.move.outMode,o=i.getPosition();if(t===Enums_1.OutMode.bounce||t===Enums_1.OutMode.bounceHorizontal){const t=i.size.value,s=i.velocity.horizontal;Updater.checkBounds(o.x,t,e.canvas.size.width,s,()=>{i.velocity.horizontal*=-1})}if(t===Enums_1.OutMode.bounce||t===Enums_1.OutMode.bounceVertical){const t=i.size.value,s=i.velocity.vertical;Updater.checkBounds(o.y,t,e.canvas.size.height,s,()=>{i.velocity.vertical*=-1})}}}}exports.Updater=Updater;